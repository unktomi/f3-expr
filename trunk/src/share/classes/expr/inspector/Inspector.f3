package expr.inspector;
import f3.media.input.*;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import expr.choices.*;
import f3.lang.*;
import f3.util.*;
import f3.util.Observables;
import expr.*;
import expr.Reflect.*;
import f3.reflect.*;
import org.f3.runtime.*;
import expr.prog.Expression;
import expr.prog.Expression.*;
import f3.math.*;
import f3.math.LinearMath.*;
import java.lang.Math;

public abstract class Inspected of a 
{
    public var member is Member;
    public var label is String;
    public var observable is Observable of a;
    protected var index is Integer;
    public function get to a { null} 
    public function set from (x is a) to () {}
}

public class InspectedRange of a is Inspected of a {
    public function getAsString from (t is Number) to String
    {
	"{get(t)}";
    }
    public function get from (t is Number) to a { null }
    public function set from (t is Number) to () 
    { 
	set(get(t)); 
    }
}

public class InspectedNumber is InspectedRange of Number 
{
    public const low is Number;
    public const hi is Number;
    override function get from (t is Number) to Number 
    { 
	if (hi > low) then low + (hi - low)*t else t;
    }
}

public class InspectedDuration is InspectedRange of Duration 
{
    public const low is Duration;
    public const hi is Duration;
    override function get from (t is Number) to Duration
    { 
	if (hi > low) then low + (hi - low)*t else 1ms*t;
    }
}

public class InspectedChoice of a is InspectedRange of a 
{
    public const choices is (..a)[];
    public const labels is String[] = foreach (choice in choices) "{choice}";

    function getIndex from (t is Number) to Integer 
    {
	(t * choices.size()) as Integer
    }

    override function getAsString from (t is Number) to String
    {
	labels[getIndex(t)];
    }

    override function get from (t is Number) to a
    { 
	choices[getIndex(t)];
    }
}

public class InspectedBoolean is InspectedRange of Boolean
{
    override public function getAsString from (t is Number) to String
    {
	if (get(t)) then "Yes" else "No"
    }

    override public function get from (t is Number) to Boolean
    {
	t == 0.0
    }
}

public class InspectedString is Inspected of String
{
}

public class InspectedObservable of a is Inspected of Observable of a
{
}


const FG = Color.color(.2, .2, .2, 1);
const FG_PAINT = ColorPaint(FG);
const SELECTED_FG = Color.color(.9, .9, .9, 1);
const SELECTED_FG_PAINT = ColorPaint(SELECTED_FG);
const BG = Color.color(.7, .7, .7);
const BG_PAINT = ColorPaint(BG);
const SELECTED_BG = Color.color(.4, .4, .4);
const SELECTED_BG_PAINT = ColorPaint(SELECTED_BG);
const DARK_BG = Color.color(.5, .5, .5);
const DARK_BG_PAINT = ColorPaint(DARK_BG);

class NumberField is SliderField {
    public var i is InspectedNumber;
    var disp is Disposable;
    function onChange from (n is Number) to () 
    {
	println("on change {n}");
	t = n;
    }
    postinit {
	t = i.get();
	println("I.observable = {i.observable}");
	disp = i.observable.subscribe(onChange);
    }
    override var t on replace {
	println("t={t}");
    }
    override function getText from (t is Number) to String
    {
	"{%.04f t}"
    }
}

class BooleanField is SliderField {
    public var i is InspectedBoolean;
    var disp is Disposable;
    function onChange from (n is Boolean) to () 
    {
	println("on change {n}");
	t = if (n) then 1.0 else 0.0;
    }
    postinit {
	onChange(i.get());
	disp = i.observable.subscribe(onChange);
    }
    override var t on replace {
	println("t={t}");
    }
    override function getText from (t is Number) to String
    {
	if (t == 0.0) then "No" else "Yes";
    }
}

class DurationField is SliderField {
    public var i is InspectedDuration;
    var disp is Disposable;
    function onChange from (n is Duration) to () 
    {
	println("on change {n}");
	t = n.toMillis();
    }
    postinit {
	onChange(i.get());
	disp = i.observable.subscribe(onChange);
    }
    override var t on replace {
	println("t={t}");
    }
    override function getText from (t is Number) to String
    {
	"{t/1000}s"
    }
}

public class Inspector is ResizableNode, Focusable, KeyboardInputHandler {
    public var inspecting is (Inspected of ?)[];
    public var selectedIndex is Integer on replace {
	if (selectedIndex < low) {
	    low = selectedIndex;
	} else if (low + visibleRows < selectedIndex) {
	    low = selectedIndex - Math.round(visibleRows / 2.0) as Integer;
	}
    }
    var low is Integer;
    var hi is Integer = bind low + visibleRows;
    public var cellHeight is Number = 16;
    public var fieldWidth is Number = 64;
    public var font is Text.Font = bind layoutEngine.createFont("font-size:11;font-family:Lucida Grande");
    public var border is Number = 0;
    override function onKeyDown from (e is KeyboardEvent) to ()
    {
	if (e.keyCode == Keys.Down) {
	    selectedIndex = Math.min(inspecting.size()-1, selectedIndex+1);
	} else if (e.keyCode == Keys.Up) {
	    selectedIndex = Math.max(0, selectedIndex-1);
	} else if (e.keyCode == Keys.Home) {
	    selectedIndex = 0;
	} else if (e.keyCode == Keys.End) {
	    selectedIndex = inspecting.size()-1;
	}
    }

    function scroll from (amount is Integer) to ()
    {
	low = Math.max(0, Math.min(low+amount, inspecting.size()-1-visibleRows));
    }

    var visibleRows = bind ((height / (cellHeight+border)) as Integer) -1;
    var scrollOffset is Integer;

    override function preupdate {
	for (i in inspecting) {
	    i.index = indexof i;
	}
	super.preupdate();	
    }

    override var internalContent = Group {
	content:
	[Rectangle {
	     width: bind width;
	     height: bind height;
	     fillPaint: DARK_BG_PAINT;
	     override function onMouseDown from (e is MouseEvent) to ()
	     {
		 selectedIndex = low+(-e.location.y + height / 2) / (border+cellHeight) as Integer;
		 println("e={e}, selectedIndex=>{selectedIndex}");
	     }
	},
	Group {
          transform: bind translate(0, height/2-cellHeight/2);
	  content: bind foreach (i in inspecting[low..hi]) Group {
	    override var transform = bind translate(0, (low-i.index) * (border+cellHeight));
	    content: 
	    [Rectangle {
		 pickable: false;
		 width: bind width;
		 height: bind cellHeight;   
		 fillPaint: bind if (i.index <> selectedIndex) BG_PAINT else SELECTED_BG_PAINT;
	    },
	    TransformNode {
		//tx: bind -width / 2;
		content: Text.Label {
		    width: bind width;
		    indent: 4;	
		    text: bind i.label;
		    font: bind font;
		    foreground: bind if (i.index <> selectedIndex) FG_PAINT else SELECTED_FG_PAINT;
		    background: bind if (i.index <> selectedIndex) BG_PAINT else SELECTED_BG_PAINT;
		    height: bind cellHeight;	    
		}
	    },
	    if (i is InspectedNumber) then
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-4;
		content: NumberField {
		    i: bind i as InspectedNumber;
	            width: bind fieldWidth;
		    height: bind cellHeight;
		}
	    } else if (i is InspectedBoolean) then
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-4;
		content: BooleanField {
		    i: bind i as InspectedBoolean;
	            width: bind fieldWidth;
		    height: bind cellHeight;
		}
	    } else if (i is InspectedDuration) then
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-4;
		content: DurationField {
		    i: bind i as InspectedDuration;
	            width: bind fieldWidth;
		    height: bind cellHeight;
		}
	    } else if (i is InspectedObservable) {
		null
	    } else null]
	 }
      }]
    }
    const onWheel = 
	internalContent.observeMouseWheel().subscribe(function from (event is MouseWheelEvent) to () {
		const y = event.scroll.y as Integer;
		scroll(y);
	    });
}

public function inspect from (obj is Object) to (Inspected of ?)[]
{
    if (obj == null) then [] else {
	    const members = Expression.introspect(getType(obj.getClass()) as F3ClassType);
	    foreach (m in members) {
		println("m={m} {m.m} t={m.t}");
		if (m.isObservable)  {
		    if (m.m is F3VarMember and m.t == NUMBER_TYPE) {
			const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Number;
			InspectedNumber {
			    member: m;
			    label: m.m.getName();
			    observable: Observables.observe(ptr);
			    override function get to Number { ptr.get() }
			    override function set from (x is Number) to () { ptr.set(x) }
			}
		    } else if (m.m is F3VarMember and m.t == BOOLEAN_TYPE) {
			const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Boolean;
			InspectedBoolean {
			    member: m;
			    label: m.m.getName();
			    observable: Observables.observe(ptr);
			    override function get to Boolean { ptr.get() }
			    override function set from (x is Boolean) to () { ptr.set(x) }
			}
		    } else if (m.m is F3VarMember and m.t == DURATION_TYPE) {
			const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Duration;
			InspectedDuration {
			    member: m;
			    label: m.m.getName();
			    observable: Observables.observe(ptr);
			    override function get to Duration { ptr.get() }
			    override function set from (x is Duration) to () { ptr.set(x) }
			}
		    } else {
			InspectedObservable of Object {
			    member: m;
			    label: m.m.getName();
			}
		    }
		} else null;
	    }
	}
}