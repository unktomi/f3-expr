package expr.manipulator;
import f3.media.scene.*;
import f3.media.input.*;
import f3.util.*;
import f3.util.Observer.DefaultObserver;
import f3.math.*;
import f3.math.LinearMath.*;
import java.lang.Math;

public class Manipulator is AbstractNode 
{
    const assetUrl = "{__DIR__}/manipulator_full_v1.ma";
    const model = Ma.Model { url: assetUrl };

    public var target is TransformNode;

    public var viewer is ExaminerViewer; 
    
    public var scene is Scene;

    public readonly var viewScale = bind {
	var s = 0.2 * viewer.centerDistance / 10;
	if (s <> 0) s else 1.0;
    }

    const modelGroup is Group = Group {
	transform: bind LinearMath.scale(viewScale, 
					 viewScale, 
					 viewScale) 
	content: bind model.getSpatialRoot()
    }

    override var internalContent = Group {
	override var transform = bind target.toSceneTransform;
        content: bind modelGroup;
    }

    function doTranslate 
	from (event is MouseEvent, 
	      axis is Vec3,
	      worldTransform is Mat4) 
	to ()
    {
	if (event.screenDrag == Vec2.<<0>>) {
	    return;
	}
	//println("axis={axis}");
	//println("screen drag {event.screenDrag}");
	const camera = scene.camera;
	const sceneStartPos = worldTransform.getTranslation();
	const startPos is Point3 = 
	    camera.toScreen(sceneStartPos);
	const endPos is Point3 = 
	    camera.toScreen(worldTransform*(Point3.<<0>> + axis));
	const screenDir = (endPos - startPos).normalize();
	const dragDir = new Vec3(event.screenDrag.x, 
				 -event.screenDrag.y, 
				 0);
	const pt = startPos + 
	    (screenDir * dragDir.dot(screenDir));
	const sceneEndPos = camera.toScene(pt);
	/*
	println("screen={event.screenx},{event.screeny}");
	println("screen start {startPos} endPos={endPos}");
	println("screen end {pt}");
	println("scene start = {sceneStartPos}");
	println("scene end = {sceneEndPos}");
	*/
	const fromScene = target.parent.toSceneTransform.inverse();
	const d = (fromScene * sceneEndPos) - (fromScene * sceneStartPos);
	//println("d={d}");
	for (n in [d.x, d.y, d.z]) {
	    if (java.lang.Float.isNaN(n)) {
		println("d={d}");
		return;
	    }
	}
	target.tx += d.x;
	target.ty += d.y;
	target.tz += d.z;
    }

    var lastMouse is Ray3;

    public var rotateOrder = Quat.EULER_ZYX;
    
    function doRotate from (event is MouseEvent, axis is Vec3) to ()
    {
	println("DO ROTATE {event} {axis} {event.picked.node}");
	const worldTransform = target.getPivot();
	const translation = worldTransform.getTranslation();
	const worldAxis = worldTransform * axis;
	const planeNormal = worldAxis;
	const plane = Plane {
	    normal: planeNormal;
	    point: translation;
	}
	const y = event.screenx;
	scene.updateCamera();
	const endRay = scene.camera.getPickRay(event.screenx, event.screeny);
	const startRay = if (lastMouse == null) lastMouse = endRay else lastMouse;
	const hitStart = plane.intersectRay(startRay);
	const hitEnd = plane.intersectRay(endRay);
	if (hitStart == null or hitEnd == null) {
	    return;
	}
	const startPos = hitStart.point;
	const endPos = hitEnd.point;
	const originToStart = (startPos - translation).normalize();
	const originToEnd = (endPos - translation).normalize();
	const rotCrossStart = worldAxis.cross(originToStart).normalize();
	const rotCrossEnd = worldAxis.cross(originToEnd).normalize();
	const startCrossEnd = rotCrossStart.cross(rotCrossEnd).normalize();
	const dot = originToStart.dot(originToEnd);
	const angle = Math.toDegrees(Math.acos(dot) * Math.signum(worldAxis.dot(startCrossEnd)));
	const worldRotation = Quat.Quat(angle, worldAxis);
	const sceneToLocal = target.parent.toSceneTransform.inverse();
	const localRotation = (sceneToLocal * worldRotation.toMat4()).getRotation().normalize();
	var angles = localRotation.toAngles(rotateOrder);
	lastMouse = endRay;
	for (n in [angles.x, angles.y, angles.z]) {
	    if (java.lang.Float.isNaN(n)) {
		return;
	    }
	}
	if (angles.length() > 0) {
	    println("angles={angles}");
	}
	target.rx += angles.x;
	target.ry += angles.y;
	target.rz += angles.z;
    }

    const onRotateX = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to () 
	{
	    doRotate(event, Vec3.X_AXIS);
	}
    }

    const onRotateY = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to () 
	{
	    doRotate(event, Vec3.Y_AXIS);
	}
    }

    const onRotateZ = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to () 
	{
	    doRotate(event, Vec3.Z_AXIS);
	}
    }

    const onMoveX = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to () 
	{
	    doTranslate(event, Vec3.X_AXIS, moveX.toSceneTransform)
	}
    }

    const onMoveY = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to () 
	{
	    doTranslate(event, Vec3.Y_AXIS, moveY.toSceneTransform)
	}
    }

    const onMoveZ = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to () 
	{
	    doTranslate(event, Vec3.Z_AXIS, moveZ.toSceneTransform)
	}
    }

    var moveX is Node;
    var moveY is Node;
    var moveZ is Node;

    var rotateX is Node;
    var rotateY is Node;
    var rotateZ is Node;
    var rotateGuideX is Node;
    var rotateGuideY is Node;
    var rotateGuideZ is Node;

    function createHandlers {
	moveX = internalContent.lookup("mMoveX");
	moveX.blocksPointer = true;
	moveX.observeMouseDrag().subscribe(onMoveX);
	moveY = internalContent.lookup("mMoveY");
	moveY.blocksPointer = true;
	moveY.observeMouseDrag().subscribe(onMoveY);
	moveZ = internalContent.lookup("mMoveZ");
	moveZ.blocksPointer = true;
	moveZ.observeMouseDrag().subscribe(onMoveZ);

	rotateX = internalContent.lookup("mRotateX");
	rotateY = internalContent.lookup("mRotateY");
	rotateZ = internalContent.lookup("mRotateZ");
	/*
	rotateX.blocksPointer = true;
	rotateY.blocksPointer = true;
	rotateZ.blocksPointer = true;
	*/
	rotateX.observeMouseDrag().subscribe(onRotateX);
	rotateY.observeMouseDrag().subscribe(onRotateY);
	rotateZ.observeMouseDrag().subscribe(onRotateZ);

	rotateGuideX = internalContent.lookup("mGuideRotateX");
	rotateGuideY = internalContent.lookup("mGuideRotateY");
	rotateGuideZ = internalContent.lookup("mGuideRotateZ");
	/*
	rotateGuideX.blocksPointer = true;
	rotateGuideY.blocksPointer = true;
	rotateGuideZ.blocksPointer = true;
	*/
	rotateGuideX.observeMouseDrag().subscribe(onRotateX);
	rotateGuideY.observeMouseDrag().subscribe(onRotateY);
	rotateGuideZ.observeMouseDrag().subscribe(onRotateZ);
    }

    override function update {
	if (moveX == null) createHandlers();
    }   
}


