package expr.timeline;
import expr.*;
import expr.Names.*;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import f3.media.scene.KeyFrame.*;
import f3.media.input.*;
import f3.util.*;
import f3.util.Observer.*;
import f3.math.*;
import f3.math.LinearMath.*;
import java.lang.Math;
import expr.undo.*;

public const CLIP_COLOR = Color.rgb(50, 50, 50);
public const CLIP_SELECTED_COLOR = Color.rgb(77, 77, 77);
public const CLIP_LABEL_COLOR = Color.rgb(180, 180, 180);
public const CLIP_SELECTED_LABEL_COLOR = Color.rgb(230, 230, 230);

public const CHANNEL_COLOR = Color.rgb(140, 140, 140);
public const CHANNEL_LABEL_COLOR = Color.rgb(51, 51, 51);
public const CHANNEL_SELECTED_COLOR = Color.rgb(166, 166, 166);
public const CHANNEL_SELECTED_LABEL_COLOR = Color.rgb(26, 26, 26);

public const MODEL_COLOR = Color.rgb(80, 50, 50);
public const MODEL_SELECTED_COLOR = Color.rgb(130, 50, 50);

public const SOUND_COLOR = Color.rgb(50, 80, 50);
public const SOUND_SELECTED_COLOR = Color.rgb(50, 130, 50);

public const MOVIE_COLOR = Color.rgb(50, 50, 80);
public const MOVIE_SELECTED_COLOR = Color.rgb(50, 50, 130);


public const CLIP_PAINT = ColorPaint(CLIP_COLOR);
public const CLIP_SELECTED_PAINT = ColorPaint(CLIP_SELECTED_COLOR);

public const CLIP_LABEL_PAINT = ColorPaint(CLIP_LABEL_COLOR);
public const CLIP_SELECTED_LABEL_PAINT = ColorPaint(CLIP_SELECTED_LABEL_COLOR);

const CURVE_PAINT = ColorPaint(Color.YELLOW);
const yLegendFg = ColorPaint(Color.color(.9, .9, .9, .8));

function debugPrint of a (label is String, value is a) to a {
    println("{label}: {value}");
    return value;
}

class ContentHolder is TransformNode, Scissored {
}

class KeyEditor is AbstractNode {
    public var view is TimeNodeView;
    public var key is Key of Number;
    public var ch is Channel of Number;
    public var trax is Trax;
    bound var valueBounds is Vec2 = getValueBounds(ch.keys);
    public var viewHeight is Number = bind view.viewHeight;

    bound var tangent = getInterpolator(key, key.interpolator);
    bound var dy = bind valueBounds.y - valueBounds.x;
    bound var ty = bind valueBounds.x;
    bound var sy = bind if (dy == 0) then 1.0 else viewHeight/dy;
    bound var outVectors = bind getVectors(ty, sy, key.prev, tangent);
    bound var inVectors = bind getVectors(ty, sy, key, tangent);

    bound function getVectors 
        from (ty is Number, 
              sy is Number, 
              k is Key of Number, 
              i is KeyFrame.Tangent) 
        to Vec2[]
    {
        var frame1 = trax.durationToFrame(k.prev.position);
        var frame2 = trax.durationToFrame(k.position);
        var kox = i.kox;
        var koy = i.koy;
        var kix = i.kix;
        var kiy = i.kiy;
        var value1 = k.prev.value;
        var value2 =  k.value;
        var p0 = value1;
        var p3 = value2;
        var outTan = if (kox == 0) then 0 else koy / (kox * 24.0);
        var inTan = if (kix == 0) then 0 else  kiy / (kix * 24.0);
        var oneThirdDelta = (frame2 - frame1) / 3.0;
        var p1Delta = outTan * oneThirdDelta;
        var p2Delta = -inTan * oneThirdDelta;
        var x1 = oneThirdDelta;
        var y1 = p1Delta;
        var x2 = oneThirdDelta;
        var y2 = -p2Delta;
        xformResult(ty, sy, new Vec2(x1, y1), new Vec2(x2, y2));
    }

    function xformResult from (ty is Number, sy is Number, v1 is Vec2, v2 is Vec2) to Vec2[]
    {
        var x1 = v1.x;
        var y1 = v1.y;
        var x2 = v2.x;
        var y2 = v2.y;
        y1 -= ty;
        y2 -= ty;
        y1 *= sy;
        y2 *= sy;
        println("ty={ty}, sy={sy} viewHeight={viewHeight}");
        const frameX1 = frameToX(x1);
        const frameX2 = frameToX(x2);
        x1 = frameX1;
        x2 = frameX2;
        [new Vec2(x1, y1), new Vec2(x2, y2)];
    }

    bound function getInterpolator from (k is Key of Number, interp is Interpolator of Number) to KeyFrame.Tangent 
    {
        if (interp is KeyFrame.Tangent) {
            interp as KeyFrame.Tangent;
        } else { // Assume Linear
            var kpp = if k.prev.prev == null then k.prev else k.prev.prev;
            var frame0 = (kpp.position / (1s/24))  as Integer;
            var frame1 = k.prev.position / (1s/24);
            var frame2 = k.position / (1s/24);
            var y0 = kpp.value;
            var kox = frame1 - frame0;
            var kix = frame2 - frame1;
            var koy = k.prev.value - y0;
            var kiy = k.value - k.prev.value;
            //if (kox == 0) kox = 1.0;
            //if (kix == 0) kix = 1.0;
            /*
            var len1 = Math.sqrt(kix*kix + kiy*kiy);
            if (len1 <> 0) {
                kix /= len1;
                kiy /= len1;
            }
            var len2 = Math.sqrt(kox*kox + koy*koy);
            if (len2 <> 0) {
                kox /= len2;
                koy /= len2;
            }
            */
            var v1 = new Vec2(kox, koy);//.normalize();
            var v2 = new Vec2(kix, koy);//.normalize();
            var dummy = bind KeyFrame.Tangent {
                kox: v1.x;
                koy: v1.y;
                kix: v2.x;
                kiy: v2.y;
            }
        }
    }

    override var internalContent = Group {
        transform: bind translate(trax.durationToX(key.position), 0); 
        content:
        [Circle {
              transform: bind translate(-outVectors[0].x, outVectors[0].y);
              radius: 4;
              strokePaint: ColorPaint(Color.WHITE);
              onMouseDrag: function from (e is MouseEvent) to ()
              {
              }
        },
        Circle {
              radius: 4;
              strokePaint: ColorPaint(Color.YELLOW);
              transform: bind translate(inVectors[1].x, inVectors[1].y);
              onMouseDrag: function from (e is MouseEvent) to ()
              {
              }
        }]
    }
    
}

class KeyMark is Image, MouseInputHandler, KeyboardInputHandler {
    var kx = 0.0;
    override var url = "{__DIR__}keybubblemarker.png";
    public var k is Key of Number;
    public var ch is Channel of Number;
    public var trax is Trax;
    public var view is TimeNodeView;
    public var valueBounds is Vec2;
    public var sy is Number = 1.0;
    override var transform = bind translate(trax.durationToX(k.position), 0);
    var lockedValueBounds is Vec2;
    var lockedSy is Number;
    var lockX is Boolean;
    override function onMouseDown from (event is MouseEvent) to ()
    {
        if (event.clickCount > 1) {
            trax.editKey(view, ch, k);
        } 
        kx = trax.durationToX(k.position);
        lockedValueBounds = valueBounds;
        lockedSy = sy;
        lockX = event.metaKey;
    }
    override function onMouseDrag from (event is MouseEvent) to ()
    {
        println("view={view}");
        kx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
        var dy = (event.picked.dragPoint1 - event.picked.dragPoint0).y;
        if (lockX or view.rows == 1) {
            println("moving on x only");
            k = trax.moveKeyTo(ch, k, trax.frameTo(trax.xToDuration(kx)));
        } else {
            println("sy={sy}, dy={dy}");
            println("value={k.value} => {k.value + sy * dy}");
            k = ch.setKey(k, trax.frameTo(trax.xToDuration(kx)), k.value + dy / lockedSy, k.interpolator);
        }
        trax.updatePlayhead();
    }
    override function onMouseUp from (event is MouseEvent) to ()
    {
        //println("commit playTime={target.playTime}, pickable={target.pickable}");
        view.updateValueBounds();
        MasterUndoable.commit();
    }
}

class GroupKeyMark is Image, MouseInputHandler, KeyboardInputHandler {
    var kx = 0.0;
    override var url = "{__DIR__}keybubblemarker.png";
    public var k is Duration;
    public var ch is ResourceTarget.ChannelBoxGroup;
    public var trax is Trax;
    override var transform = bind translate(trax.durationToX(k), 0);
    override function onMouseDown from (event is MouseEvent) to ()
    {
        kx = trax.durationToX(k);
    }
    override function onMouseDrag from (event is MouseEvent) to ()
    {
        kx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
        k = ch.moveKeyTo(k, trax.frameTo(trax.xToDuration(kx)));
        trax.updatePlayhead();
    }
    override function onMouseUp from (event is MouseEvent) to ()
    {
        //println("commit playTime={target.playTime}, pickable={target.pickable}");
        MasterUndoable.commit();
    }
}


class TimeNodeView is AbstractNode 
{
    public var keyEditor is KeyEditor;
    public var cy is Number;
    public var row is Number;
    public var trax is Trax;
    public var target is TimeNode;
    public var playX is Number = bind getPlayX(target.playTime);
    public var content is TransformNode[] = bind getContent(target);
    public var expanded = false;

    var repeatMesh is LineMesh;

    function getRepeatMesh from (x is Number, w is Number, h is Number, repeats is Number) to MeshNode 
    {
        if (repeats <= 1) {
            repeatMesh = null;
            return null;
        }
        if (repeatMesh == null) {
            repeatMesh = LineMesh {};
        }
        repeatMesh.reset();
        for (i in [0..<Math.floor(repeats) as Integer]) {
            repeatMesh.moveTo(x + w * i, -h/2);
            repeatMesh.lineTo(x + w * i, h/2);
        }
        const mesh = repeatMesh.getMesh();
        mesh.updateBounds();
        MeshNode {
            mesh: mesh;
            shader: bind effectLoader.loadPaintShader(CLIP_LABEL_PAINT);
        }
    }
    function updateRows from (row is Number) to Number
    {
        this.row = row;
        var j = row + this.rows;
        if (expanded) {
            for (k in content) {
                const i = k.content[0] as TimeNodeView;
                j = i.updateRows(j);
            }
        } 
        rowCount = j - row; 
        return j;
    }

    override function toString to String 
    {
        "TimeNodeView {target}";
    }

    public function close to ()
    {
        expanded = false;
        if (target <> null and not (target is TimeGroup)) {
            rows = 1;
        }
    }

    function toggleOpen to ()
    {
        if (expanded) then close() else open();
    }

    function updateValueBounds to ()
    {
        if (target is Channel of Number) {
            bnds = getValueBounds((target as Channel of Number).keys);
        }
    }

    public function open to ()
    {
        getParentTimeNodeView().open();
        if (target <> null and not (target is TimeGroup)) {
            rows = openRows;
            updateValueBounds();
        }
        expanded = true;
    }

    public function getParentTimeNodeView to TimeNodeView {
        var p = parent;
        while (p <> null and not (p is TimeNodeView)) {
            p = p.parent;
            if (p is Trax) {
                return null;
            }
        }
        return p as TimeNodeView;
    }

    public function getRow from (row is Integer) to TimeNodeView {
        if (row == 0) {
            return this;
        }
        if (expanded) {
            var j = 1;
            for (k in content) {
                const i = k.content[0] as TimeNodeView;
                if (j + (i.rowCount as Integer) > row) {
                    return i.getRow(row-j);
                }
                j += i.rowCount as Integer;
            }
        }
        return null;
    }

    public var rowCount is Number;

    bound function getRowCount from (content is Group[], result is Integer) to Integer {
        if (content == []) then result else {
                var x = content[0].content[0] as TimeNodeView;
                var xs = content[1..];
                var dummy = getRowCount(xs, result + x.rowCount);
            }
    }

    public var selected is Boolean;

    function getPlayX from (d is Duration) to Number 
    {
        trax.durationToX(d, false);
    }

    function getWidth from (i0 is Interval, visible is Interval) to Number 
    {
        const i = if (i0.duration() == 0s or i0.duration() > 10000s) then visible.end - i0.start else i0.duration();
    	trax.durationToX(i);
    }

    bound var selected1 = selected and trax.focused;

    bound function blendColor from (c is Color, a is Number) to ColorPaint {
        ColorPaint(if (a == 1.0) then c else Color.color(c.red, c.green, c.blue, c.opacity * a));
    }

    bound function getFill from (target is TimeNode) to Paint 
    {
	if (selected) then blendColor(CLIP_SELECTED_COLOR, target.sceneBlendWeight) else blendColor(CLIP_COLOR, target.sceneBlendWeight);
    }

    bound function getContent from (target0 is TimeNode) to TransformNode[]
    {
        var target = if target0 is ResourceTimeNodeWrapper then (target0 as ResourceTimeNodeWrapper).wrapped else target0;
        if (target is TimeGroup) {
            var g = target as TimeGroup;
            foreach (x in g.content) TransformNode { content: bind trax.makeTimeNodeView(null, x) }
        } else []
    }

    override function update to () 
    {
        if (expanded) {
            var y = -trax.getViewHeight();
            for (i in content) {
                i.ty = y;
                const tv = i.content[0] as TimeNodeView;
                y -= trax.getViewHeight() * tv.rowCount;
            }
        }
        super.update();
    }
    var openRows = 8.0;
    const self = this;
    bound var w = getWidth(if target.hasIndefiniteDuration() then Interval.<<0>> else target.bounds, trax.visibleInterval);
    var rows is Number = 1;
    var bnds is Vec2 = Vec2.<<1>>;
    bound var h is Number = trax.getViewHeight() * rows;
    bound var viewHeight is Number = h;
    bound var fg = if w == 0 then bg else if (selected1) then CLIP_SELECTED_LABEL_PAINT else CLIP_LABEL_PAINT;//ColorPaint(Color.color(.7, .7, .7, 1));
    bound var bg = getFill(target);
    const bg1 = ColorPaint(Color.color(.83, .83, .83));
    override var transform = bind translate(playX + w / 2.0, 0);
    function getTrackName from (target is TimeNode) to String
    {
        const shouldFormat1 = not (target is ResourceTimeNode) or not (target as ResourceTimeNode).$useLiteralId;
        const shouldFormat2 = not (target is ResourceTarget.ChannelBoxGroup) or not (target as ResourceTarget.ChannelBoxGroup).$useLiteralId;
        const shouldFormat = shouldFormat1 and shouldFormat2;
        if ((target.parent is ResourceTimeNode and not (target.parent is ResourceTimeNodeWrapper)) and target.parent.id == target.id) then "Main Timeline" else if shouldFormat then formatName(target.id) else target.id;
    }   
    bound var labelX = 
        if (target.hasIndefiniteDuration() and trax.visibleInterval.start > target.playTime + target.contentBounds.start)
            then trax.durationToX(trax.visibleInterval.start) - playX
            else 
                trax.durationToX(target.contentBounds.start);//Math.min(trax.durationToX(target.contentBounds.start), 0.0);
    bound var rectY = Math.max(rows-1, 0) * -trax.getViewHeight()/2;

    override var internalContent = Group {
	content:
	Group {
            var dx is Number;
            var dy is Number;
            var resizing is Boolean;
            var dragging is Boolean;
            var dragOk = false;
	    content: bind
	    [if (target == null) then null else Group { 
                visible: bind row + rows - 1 > trax.scrollY;
		content: 
                [Rectangle {
                     var ww = bind w + trax.durationToX(target.contentBounds.start);              
                     transform: bind translate((ww - w) / 2.0, rectY);
                     width: bind ww
                     height: bind h;
		     fillPaint: bind bg1;
                },
                Rectangle is MouseInputHandler {
                     transform: bind translate(trax.durationToX(target.contentBounds.start), rectY)
                     height: bind h;
                     width: bind w;
		     fillPaint: bind bg;
		     strokePaint: bind CLIP_LABEL_PAINT;
		     blocksPointer: true;
                     cursor: bind if resizing then Cursor.SouthResize else null;
                     override function onMouseMove from  (event is MouseEvent) to ()
                     {
                         if (trax.graph and expanded and target is Channel and not dragging) {
                             resizing = event.location.y <= rectY - trax.getViewHeight()/2 + 3;
                         }
                     }
		     override function onMouseDown from (event is MouseEvent) to ()
		     {
                         if (event.isMouseButton3Down()) {
                             var menu = Menu {
                                 factory: trax.menuFactory;
                             };
                             if (trax.graph and target is ResourceTarget.ChannelBoxesGroup) {
                                 insert MenuItem {
                                     factory: trax.menuFactory;
                                     label: "Add Clip"
                                         action: function to ()
                                     {
                                         println("add clip");
                                         (target as ResourceTarget.ChannelBoxesGroup).target.addChannelBox();
                                     }
                                 } into menu.items;
                             }
                             if (not (target is ResourceTarget.ChannelBoxesGroup)) {
                                 insert MenuItem {
                                     factory: trax.menuFactory;
                                     label: "Delete"
                                         action: function to ()
                                     {
                                         trax.removeClip(target);
                                     }
                                 } into menu.items;
                             }
                             if (menu.items <> []) {
                                 event.stage.showPopupMenu(event.screenx, event.screeny+trax.getViewHeight(), menu);
                             }
                             resizing = false;
                             dragOk = false;
                         } else {
                             dragOk = true;
                             resizing = expanded and trax.graph and target is Channel and event.location.y <= rectY + 2;
                         }
                         dx = trax.durationToX(target.playTime);
                         dy = rows * trax.getViewHeight();
                         trax.selectTimeNodeView(self);
		     }
		     override function onMouseDrag from (event is MouseEvent) to ()
		     {
                         if (dragOk) {
                             dragging = true;
                             if (not resizing) {
                                 dx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
                                 target.playTime = trax.frameTo(trax.xToDuration(dx));
                                 trax.updatePlayhead();
                             } else {
                                 dy -= (event.picked.dragPoint1 - event.picked.dragPoint0).y;
                                 rows = Math.max(dy / trax.getViewHeight(), 1.0);
                             }
                         }
		     }
		     override function onMouseUp from (event is MouseEvent) to ()
		     {
			 //println("commit playTime={target.playTime}, pickable={target.pickable}");
                         if (not resizing) {
                             if (dragging) { 
                                 MasterUndoable.commit();
                             }
                         } else {
                             resizing = false;
                             openRows = rows = Math.max((dy / trax.getViewHeight()) as Integer, 1);
                         }
                         dragging = false;
		     }
		 },
                 Group {
                     transform: bind translate(trax.durationToX(target.contentBounds.start), 0)
                     content: bind getRepeatMesh(-w/2, trax.durationToX(target.contentBounds.duration()), h, target.playCount);
                 },
		 Text.Label {
		     blocksPointer: false;
                     transform: bind translate(20+labelX, 
                                               font.descent);
		     //height: bind h;
		     width: bind Math.max(w, 100);
		     background: null;
		     foreground: bind fg;
		     text: bind getTrackName(target);
		     font: bind timeNodeViewFont;
		 },
		 Rectangle is MouseInputHandler {
		     transform: bind translate(labelX+-w/2+5.0/2+2, 0);
		     height: 9.0;
		     width: 5.0;
		     fillPaint: bind if target.pickable then fg else TransparentPaint;
		     strokePaint: bind if not target.pickable then fg else TransparentPaint;
		     override function onMouseDown from (event is MouseEvent) to ()
		     {
			 target.pickable = not target.pickable;
		     }
                     blocksPointer: true;
		 },
                 TransformNode {
                     visible: bind (target is Channel or (target is TimeGroup and { var g = target as TimeGroup; g.content.size() > 0 }));
                     tx: bind labelX+-w/2 + 13;
                     rz: bind if (expanded) then -90 else 0;
                     content: Polygon is MouseInputHandler {
                         points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
                         fillPaint: bind fg;
                         override function onMouseDown from (event is MouseEvent) to ()
                         {
                             toggleOpen();
                         }
                     }
                 }]
              },
              if (not trax.graph) then null else Group {
                visible: bind row > trax.scrollY;
                  transform: bind translate(-w/2, 0);
                  content: bind if (target is ResourceTarget.ChannelBoxGroup) then {
                          var ch = target as ResourceTarget.ChannelBoxGroup;
                          foreach (k in ch.keyTimes) {
                              GroupKeyMark {
                                  ch: bind ch;
                                  k: k;
                                  trax: bind trax;
                              }
                          }
                      } else null;
              },
              if (not trax.graph or not (target is Channel of Number)) then null else Group {
                          //                  visible: bind row > trax.scrollY;
                          //                  pickable: false;
                          var graphHeight = bind h - trax.getViewHeight();
                          transform: bind translate(-w/2, if expanded then -trax.getViewHeight() else 0);
                          var ch = bind target as Channel of Number;
                          content: 
                          [MeshNode {
                              visible: bind expanded;
                              transform: bind translate(0, trax.getViewHeight() /2);
                              var line = PathLine {
                                  path: bind makeCurve3(target as Channel of Number, 
                                                        (target as Channel of Number).sortedKeys,
                                                        bnds,
                                                        if (expanded) then graphHeight else trax.getViewHeight()).path;
                              };
                              pickable: false;
                              mesh: bind line.mesh;
                              shader: bind effectLoader.loadPaintShader(CURVE_PAINT);
                          },
                          Group {
                              var extent = bind bnds.y - bnds.x;
                              var sy = bind if (extent == 0) then 1.0 else (if (expanded) then graphHeight else h) / extent;
                              var hoff = bind -graphHeight + 1.0 * trax.getViewHeight();
                              var chKeys = bind ch.keys;
                              content: 
                              [Group { 
                                      visible: bind expanded;
                                      transform: bind translate(-50+trax.frameToX(trax.currentFrame)-trax.durationToX(ch.boundsInScene.start), hoff+3);
                                      content: bind if extent == 0 then null else foreach (i in [0..<rows]) {
                                          Text.Label {
                                              width: 100;
                                              transform: bind translate(0, trax.getViewHeight() * i);
                                              font: bind trax.yLegendFont;
                                              text: bind "{%.04f bnds.x + i * (extent/(rows-1))}";
                                              rightJustified: true;
                                              foreground: bind yLegendFg;
                                              background: null;
                                         }
                                      }
                                  },
                               Group {
                                  transform: bind translate(0, if (expanded) then -trax.getViewHeight()/2 else 0);
                                  content: bind foreach (k in chKeys) {
                                      KeyMark {
                                          view: this;
                                          transform: bind translate(trax.durationToX(k.position), if (expanded) then hoff+(sy * (k.value - bnds.x)) else 0);                                      
                                          ch: bind ch;
                                          k: k;
                                          trax: bind trax;
                                          valueBounds: bind bnds;
                                          sy: bind sy;
                                      }
                                      
                                   }
                              }]
                          }]
              },
              if (not trax.graph or not (target is Channel of Number)) then null else {
                  Group {
                      visible: bind keyEditor <> null;
                      transform: bind translate(-w / 2, 0), 
                      content: bind keyEditor;
                  }
              }
              Group { 
                  transform: bind translate(-w/2, 0);
                  content: bind if (expanded) then content else [] 
              }
              ]
	 }
    }
}

public class Playhead is AbstractNode 
{
    public var x is Number;
    public var height is Number = 500;
    public var trax is Trax;

    override var transform = bind translate(x, 0);

    const playhead_top = Image { 
	url: "{__DIR__}playhead_top.png" 
	transform: bind translate(0, height/2-5);
    };

    const playhead_middle = Image { 
	url: "{__DIR__}playhead_middle.png";
	transform: bind translate(0, -5) * scale(1, (height-15)/8)
        pickable: false;
    };

    const playhead_bottom = Image { 
	url: "{__DIR__}playhead_bottom.png" 
	transform: bind translate(0, -height / 2);
    };

    const playhead_marker is Image = Image { 
	url: "{__DIR__}playhead_marker.png";
	transform: bind translate(0, height/2 -5);
    };

    override var internalContent = Group {
	content: bind [playhead_middle, playhead_bottom, playhead_top, playhead_marker];
    } 

    var tx = 0.0;
    var dragging = false;

    const onDown = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    dragging = true;
	    tx = trax.frameToX(trax.currentFrame-trax.scrollOffset);
	}
    }

    const onDrag = DefaultObserver of MouseEvent {

	override function onNext from (event is MouseEvent) to ()
	{
	    tx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
	    println("drag {tx}");
	    trax.movePlayheadTo(tx);
	}
    };

    const onUp = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    dragging = false;
	}
    };
	
    const down = observeMouseDown().subscribe(onDown);
    const drag = observeMouseDrag().subscribe(onDrag);
    const up = observeMouseUp().subscribe(onUp);
}

public class Trax is ResizableNode, Focusable, KeyboardInputHandler, Scrollable {

    public var menuFactory is MenuFactory;

    function editKey from (view is TimeNodeView, ch is Channel of Number, k is Key of Number) to () 
    {
        keyEditor.trax = this;
        keyEditor.key = k;
        keyEditor.ch = ch;
        keyEditor.view = view;
        view.keyEditor = keyEditor;
        println("Edit key {ch} {view} {k} outVectors={keyEditor.outVectors}, inVectors={keyEditor.inVectors}");
        const i = keyEditor.tangent;
        println("i={i.kox},{i.koy} {i.kix},{i.kiy}");
    }

    var keyEditor = KeyEditor {
    }

    const onWheel = 
	internalContent.observeMouseWheel().subscribe(function from (event is MouseWheelEvent) to () {
		const y = event.scroll.y as Integer;
		scrollVertically(y);
	    });

    public var graph is Boolean = true;
    const arrow is Polygon = Polygon {
	points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
	fillPaint: ColorPaint(Color.WHITE);
    };

    bound function arrowIcon (p is Paint, f is function from () to ()) to Node 
    {
	MeshNode is MouseInputHandler {
            blocksPointer: true;
            override function onMouseDown from (e is MouseEvent) to () 
            {
                println("mouse down {e}");
                f();
            }
	    mesh: bind arrow.fillMesh.mesh;
	    shader: bind effectLoader.loadPaintShader(p);
	}
    }

    public function onDrop from (where is Pick, clip is TimeNode, add is function from TimeNode to ()) to ()
    {
	//println("ON DROP {where} {clip}");
        const pt = toSceneTransform.inverse() * where.scenePoint;
        println("ON DROP {pt}");
        println("row={yToRow(pt.y)}");
        const row = yToRow(pt.y);
        const tv = rowToTimeNodeView(row);
        var targetNode = tv.target;
        println("targetNode={targetNode}");
        if (targetNode is ResourceTimeNodeWrapper) {
            targetNode = (targetNode as ResourceTimeNodeWrapper).wrapped;
        }
        if (targetNode is TimeGroup) {
            tv.getParentTimeNodeView().open();
            insert clip into (targetNode as TimeGroup).content;
        } else if (targetNode <> null) {
            tv.open();
            const g = targetNode as TimeGroup;
            insert clip after g.content[Sequences.indexOf(g.content, targetNode)];
        } else {
            add(clip);
        }
    }

    var timelineListener is Disposable;
    
    public var loop is Boolean;

    const onPlayhead = DefaultObserver of Duration {
	override function onNext from (event is Duration) to () {
            onPlayheadChange(event)
	}
    };

    const onPausedOb = DefaultObserver of Boolean {
	override function onNext from (event is Boolean) to () {
            onPaused(event)
	}
    };

    protected function onPaused from (b is Boolean) to ()
    {
    }

    protected function onPlayheadChange from (event is Duration) to ()
    {
        //const d = if (loop and not target.paused and targetNode.contentBounds.duration() > 0s) event.rem(targetNode.bounds.start + targetNode.contentBounds.duration()) else event;
        const d = event;
        currentFrame = (d.toMillis() / 1000) * frameRate;
        //println("currentFrame {event} => {currentFrame}");
        refreshPlayhead();
        if (target.paused) {
            playhead.x = frameToX(currentFrame);
        } else {
            playhead.x = durationToX(d);
        }
    }

    public var target is Timeline on replace {
	timelineListener.dispose();
	timelineListener = target.observePlayhead().subscribe(onPlayhead);
    }

    public var targetNode is TimeNode;

    public var temporalHierarchy is TemporalHierarchy;

    public var removeClip is function from TimeNode to ();


    var selectedTimeNodeView is TimeNodeView = null on replace old {
	old.selected = false;
	selectedTimeNodeView.selected = true;
    }
    
    const undoList = UndoList {};

    readonly var visibleInterval = bind
	new Interval(frameToDuration(scrollOffset), 
		     frameToDuration(scrollOffset+visibleFrameCount));

    public var clips is TimeNode[] on replace deleted[i..j] = inserted {
	for (x in deleted[i..j]) {
	    undoList.removeTarget(&x.playTime);
	    undoList.removeTarget(&x.pickable);
	}
	for (x in inserted) {
	    undoList.addTarget("{x.id}.playtime", &x.playTime);
	    undoList.addTarget("{x.id}.pickable", &x.pickable);
	}
    };

    override function update {
        super.update();
        performUpdate();
    }

    protected function performUpdate to ()
    {
        root.updateRows(0);
        rowCount = root.rowCount as Integer;
    }

    const root = TimeNodeView {
        expanded: true;
        trax: this;
        override var content = bind foreach (tv in timeNodeViews) TransformNode { content: bind tv }
    }

    var rowCount is Integer;

    readonly var timeNodeViews is TimeNodeView[] = bind getTimeNodes(clips);
    
    bound function getTimeNodes from (content is TimeNode[]) to TimeNodeView[] 
    {
	foreach (t in content) makeTimeNodeView(null, t)
    }

    public readonly var frameRate is Number = bind frameRateN on replace { frameRateGadget.setText("{Math.round(frameRate) as Integer}") };
    protected var frameRateN is Number = 24.0;

    const lineMesh = LineMesh {};
    const backgroundColor is Color = Color.color(0.6, 0.6, 0.6);//Color.color(0.90, 0.90, 0.90);
    const backgroundPaint is Paint = ColorPaint(backgroundColor);
    const foregroundPaint is Paint = ColorPaint(Color.color(0.2, 0.2, 0.2));

    function autoScrollLeft to () {
    }

    function autoScrollRight to () {
    }

    public var currentFrame is Number on replace { 
        frameGadget.setText("{(currentFrame as Integer)}");
        refreshPlayhead();
    }

    public function refreshPlayhead from () to () 
    {
	if (not playhead.dragging and not backgroundDragging and not horizontalScrolling) {
	    if (currentFrame < scrollOffset) {
		scrollOffset = currentFrame;
	    } else if (currentFrame > scrollOffset + visibleFrameCount) {
		scrollOffset = currentFrame - visibleFrameCount / 2;
	    }
	} else {
	    if (currentFrame < scrollOffset) {
		autoScrollLeft();
	    } else if (currentFrame > scrollOffset + visibleFrameCount) {
		autoScrollRight();
	    }
	}
    }
    
    const PIXELS_PER_FRAME = 10;
    const TICK_PIXELS = 10;
    
    var visibleFrameCount is Number = bind (width-10) / pixelsPerFrame();

    var unzoomedVisibleFrameCount is Number = bind (width-10) / PIXELS_PER_FRAME;
    var unzoomedVisibleDuration = bind 1s / 24 * unzoomedVisibleFrameCount;

    bound function durationToFrame from (d is Duration) to Number
    {
	Math.round((d / 1s) * frameRate);
    }

    bound function frameToDuration from (frames is Number) to Duration 
    {
	(1s / frameRate) * frames
    }
    
    bound function frameTo from (d is Duration) to Duration {
	var seconds = d / 1s;
	var frames = Math.round((seconds * frameRate));
	return (1s / frameRate) * frames;
    }
    
    function rowToTimeNodeView from (row is Integer) to TimeNodeView
    {
        var result is TimeNodeView = null;
        root.foldLeft((), function from (_ is (), t is Node) to () {
                if (t is TimeNodeView) {
                    const tv = t as TimeNodeView;
                    if (row >= tv.row and row < tv.row+tv.rows) {
                        result = tv;
                    }
                }
            });
        return result;
    }

    function yToRow from (y0 is Number) to Integer 
    {
        const y = y0 - height/2;
        -Math.round(y / getViewHeight() + 2) as Integer;
    }

    bound function xToDuration from (x is Number) to Duration
    {
	1s * x / (pixelsPerFrame() * frameRate);
    }

    bound function xToFrame from (x is Number) to Number
    {
	Math.round(x / pixelsPerFrame());
    }

    function xToFrameUnbound from (x is Number) to Number
    {
	Math.round(x / pixelsPerFrameUnbound());
    }

    bound function durationToX from (d0 is Duration) to Number
    {
	durationToX(d0, false);
    }

    bound function durationToX from (d0 is Duration, loop is Boolean) to Number
    {
        var dur = targetNode.contentBounds.duration();
	var d = if (loop and dur > 0s) d0.rem(dur) else d0;
	var pixels = d / 1s * pixelsPerSecond();
	return pixels;
    }

    bound function framesPerTick to Number {
        pixelsPerFrame() * TICK_PIXELS;
    }
    
    bound function pixelsPerSecond to Number {  
	pixelsPerFrame() * frameRate;
    }

    bound function pixelsPerFrame to Number { pixelsPerFrameUnbound() }

    function pixelsPerFrameUnbound to Number { PIXELS_PER_FRAME }
    
    bound function frameToX from (frame is Number) to Number 
    {
	frame * pixelsPerFrame();
    }

    public function getViewHeight to Number 
    {
	15
    }

    function updatePlayhead {
        const value = target.paused;
        target.paused = true;
	target.setPlayhead(target.playhead);
        target.paused = value;
    }

    public function setFrameRate from (fps is Integer) to ()
    {
        frameRateN = fps;
    }

    function advancePlayhead from (frames is Number) to ()
    {
	target.setPlayhead(target.playhead + frameToDuration(frames));
    }

    function movePlayheadTo from (x is Number) to ()
    {
	const scrollX = frameToX(scrollOffset);
	const d = xToDuration(x+scrollX);
	target.setPlayhead(frameToDuration(durationToFrame(d)));
	println("move playhead to {x}, scrollX={scrollX} d={d} frame={durationToFrame(d)}");
    }

    function getSelf to Trax { this }


    override bound function getTx to Number { 
        if (dur == 0s) then 0.0 else frameToDuration(scrollOffset) /  dur;
    }

    override bound function getSx to Number { 
        targetSx(visibleInterval.duration(), targetNode.contentBounds) * (frameRate / frameRateN)
    }

    function targetSx from (dur is Duration, bounds is Interval) to Number {
        if (0s == bounds.end) then 1.0 else dur/(dur + bounds.end);
    }

    var dur = bind visibleInterval.duration() + targetNode.contentBounds.end;
    var traxHeight = bind height - 20;
    var rootContent = bind getRootContent();
    var sy0 = bind Math.min(traxHeight / Math.max(rootContent.bounds.height(), 1), 1.0);
    var ty0 = bind if rootContent.bounds.height() == 0 then 0.0 else (scrollY * getViewHeight()) / rootContent.bounds.height();
    bound var visibleRows is Integer = Math.round(height / getViewHeight()) as Integer;

    override bound function getSy to Number { sy0 }

    override bound function getTy to Number { ty0 }

    function scrollVertically from (i is Integer) to ()
    {
        scrollY = Math.max(0, Math.min(i+scrollY, rowCount - (traxHeight / getViewHeight()) as Integer));
    }

    override public function setY from (ty is Number, sy is Number) to () {
        scrollY = (ty * rootContent.bounds.height() / getViewHeight()) as Integer;
    }

    override public function setX from (tx is Number, sx is Number) to ()
    {
        const cur = getSx();
        if (sx <> 0) {
            frameRateN *= cur / sx;
        }
        scrollOffset = durationToFrame(dur * tx);
    }

    const playhead is Playhead = Playhead {
	id: "playhead";
	trax: this;
	override var height = bind getSelf().height;
    }
    var scrollY is Integer;
    public var scrollOffset is Number;
    var visibleDuration is Duration = bind visibleInterval.duration();
    var labels is Node[] = bind drawLabels(width, height, scrollOffset, frameRate);
    var font = bind layoutEngine.createFont("font-size:8;font-family:Lucida Grande");
    var yLegendFont = bind layoutEngine.createFont("font-size:11;font-family:Lucida Grande");
    var timeNodeViewFont = bind layoutEngine.createFont(Names.DEFAULT_FONT);

    function makeTimeNodeView from (parent is TimeNodeView, t0 is TimeNode) to TimeNodeView 
    {
        var t = t0;
        /*
        if (t0 is ResourceTimeNode) {
            const rtn = t0 as ResourceTimeNode;
            const c = rtn.content[0];
            if (c is TransitionLayer) {
                t = c;
            } else if (c is BlendLayer) {
                t = c;
            }
        }
        */
        println("making time node view for target: {t} with content bounds {t.contentBounds}");
        TimeNodeView {
            trax: this;
            target: t;
        }
    }

    readonly var gadgetFont = bind layoutEngine.createFont(Names.DEFAULT_FONT);
    readonly var gadgetFg = ColorPaint(Color.color(.8, .8, .8));
    readonly var gadgetBg = ColorPaint(Color.color(.4, .4, .4));
        

    public var frameGadget is Text.Field = Text.Field {
        width: bind 64;
        rightJustified: true;
        font: bind gadgetFont;
        foreground: bind gadgetFg;
        background: bind gadgetBg;
        text: "0"
    };

    const onGadgetCommit = frameGadget.observeCommit().subscribe(function from (text is String) to () {
           const currentFrame = Integer.parseInt(text);
           target.setPlayhead(1s / frameRate * currentFrame);
        });

    public var frameRateGadget is Text.Field = Text.Field {
        width: 48
        rightJustified: true;
        font: bind gadgetFont;
        foreground: bind gadgetFg;
        background: bind gadgetBg;
        text: "24"
    };

    const onRateGadgetCommit = frameRateGadget.observeCommit().subscribe(function from (text is String) to () {
            frameRateN = Math.max(Integer.parseInt(text), 1);
        });

    public var combinedGadget is Node = Group {
        transform: bind translate(width / 2-64, 2)
        content: 
        [TransformNode {
            tx: -64
            content: frameGadget;
        },
        TransformNode {
            content: frameRateGadget;
        },
        TransformNode {
            tx: 31;
            content: Text.Label {
                text: "fps";
                font: bind gadgetFont;
                width: 19;
                foreground: bind gadgetFg;
                background: bind gadgetBg;
            }
        }]
    }


    bound function drawLabels from (w is Number, h is Number, offset is Number, frameRateN is Number) to Node[] 
    {
	//println("draw labels {offset}");
	var x0 = -w / 2 + 15 + 15;
	var y = h / 2 - 19;
        var slop = offset mod 10;
        var x = x0 - frameToX(slop);
	foreach (i in [0..(w+100) step 100]) {
            if (x+i < x0) then null else  {
                    var t = Text.Label {
                        height: 10;
                        width: 30;
                        background: bind this.backgroundPaint;
                        foreground: bind this.foregroundPaint;
                        transform: bind translate(x+i, y+10);
                        font: bind font;
                        text: bind "{Math.round(xToFrame(i)+offset-slop) as Integer}"
                    }
                    TransformNode {
                        tx: bind -t.content.textShape.getBounds().width() / 2;
                        content: t;
                    }
                }
	}
    }

    function drawLines from (w is Number, h is Number, viewHeight is Number, scroll is Number) to AbstractMesh {
	//println("TIMELINE={target} pp={pixelsPerFrame()}");
	const x0 = -w / 2 + 15;
	const y0 = Math.round(h / 2 - viewHeight-5);
	var x is Number = x0;
        var slop = scroll mod 2;
	var y is Number = y0;
	var mid is Boolean = false;
	lineMesh.reset();
	lineMesh.moveTo(x, y);
        const pp = PIXELS_PER_FRAME;
        var offset = 0;
        var off0 = offset mod pp;
	var off = (offset - off0) * pp;
        var off1 = off0 * pp;
        x -= frameToX(slop);
        //println("OFF={offset}");
	for (i in [0..(w+off) step PIXELS_PER_FRAME]) {
	    var n = if (mid) then 3 else 5;
	    mid = not mid;
            const x1 = -off1+x+i;
            if (x1 >= x0) {
                lineMesh.moveTo(x1, y);
                lineMesh.lineTo(x1, y+n);
            }
	}
        x = x0;
	for (i in [0..<h step pp]) {
	    lineMesh.moveTo(x, y);
	    lineMesh.lineTo(x + width, y);
	    y -= viewHeight;
	    //println("y={y}");
	}
	const mesh = lineMesh.getMesh();
	mesh.updateBounds();
	//println("draw lines: {mesh.bounds} {mesh.vertices.getVertexCount()}");
	return mesh;
    }

    public function selectClip from (clip is TimeNode) to ()
    {
	for (i in timeNodeViews) {
	    if (i.target == clip) {
		selectTimeNodeView(i);
		break;
	    }
	}
    }

    var horizontalScrolling = false;
    
    override function onScrollHorizontally from (b is Boolean) to ()
    {
        horizontalScrolling = b;
        if (not b) {
            frameRateN = Math.max(Math.round(frameRateN), 1.0);
            fixupPlayhead();
        }
    }

    function fixupPlayhead to () {
        if (currentFrame < scrollOffset) {
            target.setPlayhead(frameToDuration(scrollOffset));
        } else if (currentFrame > scrollOffset + visibleFrameCount) {
            target.setPlayhead(frameToDuration(scrollOffset + visibleFrameCount));
        }
    }

    var backgroundDragging = false;
    
    override var internalContent = Group {
	content: 
	[Rectangle is MouseInputHandler {
		id: "background"
		override var height = bind getSelf().height;
		override var width = bind getSelf().width;
		fillPaint: bind ColorPaint(backgroundColor);
		override function onMouseDown from (event is MouseEvent) to ()
		{
		    if (event.location.y >= height / 2 - 20) {
			movePlayheadTo(event.location.x+width/2-15);
		    } else {
                        backgroundDragging = true;
                    }
		    dx = 0;
		    startOff = scrollOffset;
		}
		var dx = 0.0;
		var startOff = 0.0;
		override function onMouseUp from (event is MouseEvent) to () 
                {
                    backgroundDragging = false;
                }
		override function onMouseDrag from (event is MouseEvent) to ()
		{
		    if (backgroundDragging) {
			dx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
			const off = scrollOffset;
			scrollOffset = Math.round(-xToFrame(dx) + startOff);
			const delta = scrollOffset - off;
                        if (target.playhead < visibleInterval.start) {
                            target.setPlayhead(visibleInterval.start);
                        } else if (target.playhead > visibleInterval.end) {
                            target.setPlayhead(visibleInterval.end - frameToDuration(1));
                        } else {
                            target.setPlayhead(target.playhead);
                        }
		    }
		}
	 },
	 Group { pickable: false, content: bind labels },
         MeshNode {
	     id: "lines"
	     pickable: false;
	     override var mesh = bind getSelf().drawLines(getSelf().width, getSelf().height, getViewHeight(), scrollOffset);
	     shader: bind effectLoader.loadPaintShader(foregroundPaint);
	 },
         ContentHolder {
             var sb = bind Bounds {
                 center: new Point3(0, -10, 0);
                 extent: new Tuple3(width/2, (height-20)/2, 0);
             }
             scissorBounds: bind sb;
             content:
             [
             TransformNode { 
                 tx: bind -getSelf().width/2+15-frameToX(scrollOffset);
                 content:
                 [TransformNode {
                         ty: bind height / 2 + 2 - 15 + scrollY * getViewHeight(); 
                         content: bind getRootContent();
                 }]
             },
             if (yes) then null else Rectangle {
                 pickable: false;
                 cx: bind sb.center.x;
                 cy: bind sb.center.y;
                 width: bind sb.width();
                 height: bind sb.height();
                 strokePaint: ColorPaint(Color.RED);
             }]
         },
         TransformNode { 
             tx: bind -getSelf().width/2+15-frameToX(scrollOffset);
             content: 
             TransformNode { ty: -6, content: bind playhead }
         }]
    }


    protected bound function getRootContent to Node { root }

    protected function advanceToNextKey to ()
    {
    }

    protected function advanceToPreviousKey to ()
    {
    }

    override function onKeyDown from (e is KeyboardEvent) to () {
	const i = selectedTimeNodeView.row;
	if (e.keyCode == Keys.F) {
            frameSelection();
            e.stopPropagation();
	} else if (e.keyCode == Keys.Down) {
	    const n = rowToTimeNodeView(i+selectedTimeNodeView.rows);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Up) {
            if (i > 1) {
                const n = rowToTimeNodeView(i-1);
                if (n <> null) {
                    selectTimeNodeView(n);
                }
            }
	} else if (e.keyCode == Keys.Home) {
	    const n = rowToTimeNodeView(1);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.End) {
	    const n = rowToTimeNodeView(rowCount-1);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Left) {
	    if (e.metaKey) {
		advancePlayhead(-1);
	    } else  if (selectedTimeNodeView.expanded) {
                selectedTimeNodeView.close();
            } else {
		selectedTimeNodeView.target.playTime -= frameToDuration(1);
		updatePlayhead()
	    }
	} else if (e.keyCode == Keys.S) {
            setKeys();
        } else if (e.keyCode == Keys.Period) {
            if (e.altKey) {
                advancePlayhead(1);
            } else {
                advanceToNextKey();
            }
        } else if (e.keyCode == Keys.Comma) {
            if (e.altKey) {
                advancePlayhead(-1);
            } else {
                advanceToPreviousKey();
            }
	} else if (e.keyCode == Keys.Right) {
	    if (e.metaKey) {
		advancePlayhead(1);
	    } else {
                if (not selectedTimeNodeView.expanded) {
                    selectedTimeNodeView.open();
                } else {
                    selectedTimeNodeView.target.playTime += frameToDuration(1);
                    updatePlayhead();
                }
	    }
        } else if (e.keyCode == Keys.Spacebar) {
            target.paused = not target.paused;
	} else if (e.keyCode == Keys.Delete or e.keyCode == Keys.Backspace) {
            handleDelete();
	}
    }

    protected function handleDelete to ()
    {
        if (selectedTimeNodeView.target <> null) {
            var selectedIndex = selectedTimeNodeView.row;
            removeClip(selectedTimeNodeView.target);
            selectedIndex = Math.min(selectedIndex, rowCount-1);
            selectTimeNodeView(rowToTimeNodeView(selectedIndex));
        }
    }


    override function onKeyUp from (e is KeyboardEvent) to () {
    }

    override function onKeyInput from (e is KeyboardEvent) to () {
    }

    function selectTimeNodeView from (x is TimeNodeView) to () {
	if (x <> null) {
            temporalHierarchy.selectTimeNode(x.target);
	}
	selectedTimeNodeView = x;
        if (x <> null) {
            println("row={x.row}, scrollY={scrollY} visibleRows={visibleRows}");
            if (x.row < scrollY) {
                scrollY = x.row as Integer;
            } else if (x.row > scrollY + visibleRows) {
                scrollY = Math.max(0, x.row - visibleRows / 2) as Integer
            }
        }
    }

    const FPS = 1s/24.0;

    protected function makeTangent from (ch is Channel, k0 is KeyFrame.Key of Number, 
                                         interp is KeyFrame.Interpolator of Number, 
                                         valueBounds is Vec2,
                                         viewHeight is Number) to TangentTool 
    {
        var k = k0;
        const ty = valueBounds.x;
        var dy = (valueBounds.y - valueBounds.x);
        var sy = if (dy == 0 or viewHeight == 0) then 1.0 else (viewHeight) / dy;
        println("VALUE BOUNDS {ch.id} {valueBounds}");
        println("VIEW HEIGHT {viewHeight}");
        println("ty={ty}, sy={sy}");
        if (sy == Number.POSITIVE_INFINITY) { sy = 1.0 }
        var x1 is Double;
        var y1 is Double;
        var x2 is Double;
        var y2 is Double;
        var kix is Double;
        var kiy is Double;
        var kox is Double;
        var koy is Double;
        println("k.position={k.position}");
        println("k.prev.position={k.prev.position}");
        println("FPS={FPS}, k.prev.position/FPS={k.prev.position/FPS}");
        println("k.position/FPS={k.position/FPS}");
        const frame1 = (k.prev.position / FPS);
        const frame2 = (k.position / FPS);

        if (interp is KeyFrame.Tangent) {
            const t = interp as KeyFrame.Tangent;
            kix = t.kix;
            kiy = t.kiy;
            kox = t.kox;
            koy = t.koy;
        } else { // Linear
            const kpp = if k.prev.prev == null then k.prev else k.prev.prev;
            const frame0 = (kpp.position / FPS);
            println("frame0={frame0}");
            println("frame1={frame1}");
            println("frame2={frame2}");
            const y0 = kpp.value;
            kox = frame1 - frame0;
            kix = frame2 - frame1;
            koy = k.prev.value - y0;
            kiy = k.value - k.prev.value;
            println("kox={kox}, koy={koy}  kix={kix}, kiy={kiy}");
            //if (kox == 0) kox = 1.0;
            //if (kix == 0) kix = 1.0;

            const len1 = Math.sqrt(kix*kix + kiy*kiy);
            if (len1 <> 0) {
                kix /= len1;
                kiy /= len1;
            }
            const len2 = Math.sqrt(kox*kox + koy*koy);
            if (len2 <> 0) {
                kox /= len2;
                koy /= len2;
            }
        }
        const value1 = k.prev.value;
        const value2 =  k.value;
        const p0 = value1;
        const p3 = value2;
        const outTan = if (kox == 0) then 0 else koy / (kox * 24.0);
        const inTan = if (kix == 0) then 0 else  kiy / (kix * 24.0);
        println("inTan={inTan}, outTan={outTan}");
        const oneThirdDelta = (frame2 - frame1) / 3.0;
        const p1Delta = outTan * oneThirdDelta;
        const p2Delta = -inTan * oneThirdDelta;
        println("p1Delta={p1Delta}");        
        println("p2Delta={p2Delta}");
        println("oneThirdDelta={oneThirdDelta}");
        x1 = oneThirdDelta;
        y1 = p1Delta;
        x2 = oneThirdDelta;
        y2 = -p2Delta;

        y1 -= ty;
        y2 -= ty;

        y1 *= sy;
        y2 *= sy;

        println("x1={x1},y1={y1},x2={x2},y2={y2}");
        /*
        const frameX1 = frameToX(x1);
        const frameX2 = frameToX(x2);
        x1 = frameX1;
        x2 = frameX2;
        */
        const outAngle is Number = Math.atan2(y1, x1);
        const inAngle is Number = Math.atan2(y2, x2);
        const outLength = Math.sqrt(x1*x1+y1*y1);
        const inLength = Math.sqrt(x2*x2+y2*y2);

        println("kox={kox}, koy={koy}  kix={kix}, kiy={kiy}");
        println("outAngle={Math.toDegrees(outAngle)}, outLen={outLength}");
        println("inAngle={Math.toDegrees(outAngle)}, inLen={inLength}");


        const tool = TangentTool {
            editable: true;
            transform: bind translate(durationToX(k.prev.position), -viewHeight);
            p1: bind new Vec2(0, (k.prev.value - ty)*sy);
            p2: bind new Vec2(durationToX(k.position-k.prev.position) / ch.toSceneTransform.rate,
                              (k.value - ty)*sy);
            inAngle: inAngle;
            inLength: inLength;
            outAngle: outAngle;
            outLength: outLength;
            isPointOnly: k.prev == null;
            var p1x = 0.0;
            clickPt1: function to ()
            {
                p1x = durationToX(k.prev.position);
            }
            movePt1: function from (dx is Number, dy is Number) to ()
            {
                p1x += dx;
                const t = xToDuration(p1x);
                const newValue = k.prev.value + dy / sy;
                ch.setKey(k.prev, t, newValue, k.prev.interpolator); 
            }
            releasePt1: function to ()
            {
                MasterUndoable.commit();
            }

            var p2x = 0.0;
            clickPt2: function to ()
            {
                p2x = durationToX(k.position);
            }
            movePt2: function from (dx is Number, dy is Number) to ()
            {
                p2x += dx;
                const t = xToDuration(p2x);
                const newValue = k.value + dy / sy;
                k = ch.setKey(k, t, newValue, k.interpolator); 
            }
            releasePt2: function to ()
            {
                MasterUndoable.commit();
            }
            setInTangent: function from (angle is Number, length is Number) to ()
            {
                const newKix = Math.cos(angle) * xToFrameUnbound(length);
                const newKiy = Math.sin(angle) * length / sy;
                kix = newKix;
                kiy = newKiy;
                println("set in tangent {kox},{koy}    {kix},{kiy}");
                k = ch.setKey(k, k.position, k.value, 
                              KeyFrame.Tangent {
                                  kox: kox;
                                  koy: koy;
                                  kix: kix;
                                  kiy: kiy;
                              }); 
            }
            setOutTangent: function from (angle is Number, length is Number) to () 
            {
                const newKox = Math.cos(angle) * xToFrameUnbound(length);
                const newKix = Math.sin(angle) * length / sy;
                kox = newKox;
                koy = newKix;
                println("set out tangent {kox},{koy}    {kix},{kiy}");
                k = ch.setKey(k, k.position, k.value, 
                              KeyFrame.Tangent {
                                  kox: kox;
                                  koy: koy;
                                  kix: kix;
                                  kiy: kiy;
                              }); 
            }
        }
        //tool.valueScale = new Vec2(1.0, 1.0 / sy);
        return tool;
    }

    protected function getValueBounds from (keys is (Key of Number)[]) to Vec2 {
        if (keys.size() == 0) {
            return Vec2.<<0>>;
        }
        var min is Number = Number.MAX_VALUE;
        var max is Number = Integer.MIN_VALUE;
        for (k in keys) {
            const n is Number = k.value;
            println("key={k.position},n={n} n<min={n<min}, n>max={n>max} max<0={max<0}");
            if ((n as Double) > (max as Double)) { 
                max = n;
            }
            if ((n as Double) < (min as Double)) { 
                min = n;
            }
            println("key={k.position},{n} min={min}, max={max}");
        }
        return new Vec2(min, max);
    }

    protected function makeCurveContent from (ch is Channel, k is KeyFrame.Key of Number, 
                                              interp is KeyFrame.Interpolator of Number, 
                                              valueBounds is Vec2,
                                              viewHeight is Number) to PathElement[]
    {
        makeCurveFromTangent(makeTangent(ch, k, interp, valueBounds, viewHeight), durationToX(k.prev.position), viewHeight);
    }

    protected function makeCurveContent2 from (ch is Channel, k is KeyFrame.Key of Number, 
                                              interp is KeyFrame.Interpolator of Number, 
                                              valueBounds is Vec2,
                                              viewHeight is Number) to Node
    {
        makeTangent(ch, k, interp, valueBounds, viewHeight);
    }

    protected function makeCurveFromTangent from (t is TangentTool, x is Number, viewHeight is Number) to PathElement[]
    {
        const off = new Vec2(x, -viewHeight+getViewHeight()/2); 
        if (t.isPointOnly) then [] else [moveTo(t.p1 + off), 
                                                cubicTo(t.cp1+off, t.cp2+off, t.p2+off)];
    }

    function makePathElements from (ch is Channel, keys is (KeyFrame.Key of Number)[], viewHeight is Number) to Shape2D.PathElement[] 
    {
        foreach (k in keys) makeCurveContent(ch, k, k.interpolator, getValueBounds(keys), viewHeight) 
    }

    protected function makeCurve3 from (ch is Channel of Number, keys is (Key of Number)[], valueBounds is Vec2, viewHeight is Number) to Path {
        Path {
            fillPaint: ColorPaint(Color.GREEN);
            content: makePathElements2(ch, keys, valueBounds, viewHeight);
        }
    }

    protected bound function makeCurve from (ch is Channel of Number, viewHeight is Number) to Path {
        Path {
            fillPaint: ColorPaint(Color.GREEN);
            content: bind makePathElements2(ch, ch.keys, getValueBounds(ch.keys), viewHeight);
        }
    }

    function makePathElements2(ch is Channel of Number, keys is (Key of Number)[], valueBounds is Vec2, viewHeight is Number) to PathElement[]
    {
        var ty = valueBounds.x;
        var dy = valueBounds.y - valueBounds.x;
        var sy = if (dy == 0 or viewHeight == 0) then 1.0 else (viewHeight) / dy;
        [moveTo(new Vec2(durationToX(keys[0].position), -viewHeight+(keys[0].value - ty)*sy)),
         foreach (k in keys[1..]) {
                lineTo(new Vec2(durationToX(k.position), -viewHeight+(k.value - ty)*sy))
        }]
    }

    protected bound function makeCurve2 from (ch is Channel of Number, viewHeight is Number) to Node[] {
        var keys = ch.keys;
        var vb = getValueBounds(keys);
        foreach (k in keys) makeCurveContent2(ch, k, k.interpolator, vb, viewHeight) 
    }

    public function setKey of a from (ch is Channel of a, i is Interpolator of a) to ()
    {
        if (not ch.pickable) { return }
        ch.setKey(i);
    }

    public function frameSelection to ()
    {
        var bounds is Interval;
        if (selectedTimeNodeView <> null) {
            const n = selectedTimeNodeView.target;
            if (not n.hasIndefiniteDuration()) {
                bounds = n.bounds;
            }
        } else {
            for (t in timeNodeViews) {
                const n = t.target;
                if (not n.hasIndefiniteDuration()) {
                    bounds = Interval.merge(bounds, n.bounds);
                }
            }
        }
        if (bounds.duration() == 0s) {
            return;
        }
        bounds.add(target.playhead);
        const margin = 10;
        const pixels = (width - 10.0) - margin;
        const ticks = pixels / TICK_PIXELS;
        const seconds = bounds.duration() / 1s;
        frameRateN = Math.max(ticks / seconds, 1.0);
        scrollOffset = durationToFrame(bounds.start);
        fixupPlayhead();
    }

    protected function setKeys to () 
    {
        root.foldLeft((), function from (_ is (), t is Node) to () {
                if (t is TimeNodeView) {
                    const tv = t as TimeNodeView;
                    tv.updateValueBounds();
                }
            });
    }

    public function moveKeyTo of a from (ch is Channel of a, k is KeyFrame.Key of a, pos is Duration) to Key of a
    {
        ch.moveKey(k, pos - k.position);
    }
}
