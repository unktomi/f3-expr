package expr;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import f3.media.input.*;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.util.*;
import f3.util.Observer.*;
import java.lang.Math;

class ContentHolder is Group, Scissored {
    //override var contentBounds = bind scissorBounds;
}

const selectedTitlePaint = ColorPaint(Color.color(.2, .2, .2));
const titlePaint = ColorPaint(Color.color(.3, .3, .3));

public interface HasGadget {
    public function getGadget to Node;
}

public class InternalWindow is ResizableNode, Focuser {

    public var containerBounds is Bounds;
    public var cx is Number;
    public var cy is Number;

    var dirty = true;

    public var selected is Boolean;

    override function resize from (w0 is Number, h0 is Number) to ()
    {
	const w = Math.round(w0);
	const h = Math.round(h0);
	super.resize(w, h);
	content.resize(w, h-26);
    }

    override var transform = bind translate(cx, cy);
    const self = this;

    const titleBar is Node = Group {
        override var transform = bind translate(0, self.height / 2 - 5);
        content:
        [Rectangle is Focuser {
                override function getTargetOfFocus from () to Focusable {  self.getTargetOfFocus() }
                height: 12;
                override var width = bind self.width;
                fillPaint: bind if selected then selectedTitlePaint else titlePaint;
            },
        Image {
            visible: false;
            url: bind "{__DIR__}close.png";
            transform: bind translate(-width/2+6.5, 0);
        }]
    };

    const line is Node = Rectangle {
	transform: bind translate(0, self.height / 2 - 9.5);
	height: 1.0;
	width: bind self.width;
	fillPaint: ColorPaint(Color.color(.44, .44, .44));
    }

   public var gadget is Node;

    var hasGadget is HasGadget;

    const buttonBar is Node = Group {
        transform: bind translate(0, self.height / 2 - 9 - 10);
        content: 
        [Rectangle {
            height: 18;
            width: bind self.width;
            fillPaint: bind titlePaint;
        },
        TransformNode {
            //transform: bind translate(width / 2.0 - gadget.bounds.width() / 2.0, 0);
            content: bind gadget
        }]
    };

    const resizeCorner is Node = Image {
	override var transform = bind translate(self.width/2 - 7, -self.height/2 + 7-1);
        url: bind "{__DIR__}resize-corner.png";
	//fillPaint: ColorPaint(Color.color(.65, .65, .65));
        override var cursor = Cursor.SouthEastResize;
    };

    const leftSide is Node = Rectangle {
	override var transform = bind translate(-self.width/2, 0);
	override var height = bind self.height;
	width: 1;
	fillPaint: ColorPaint(Color.color(.18, .18, .18));
    }

    const rightSide is Node = Rectangle {
	override var transform = bind translate(self.width/2, 0);
	override var height = bind self.height;
	width: 1;
	fillPaint: ColorPaint(Color.color(.18, .18, .18));
    }

    override public function getTargetOfFocus to Focusable 
    {
	if (content is Focuser) then (content as Focuser).getTargetOfFocus() else null;
    }

    public var content is ResizableNode;

    const contentHolder = ContentHolder {
        override var cursor = Cursor.Default;
	scissorBounds: bind Bounds.boundsFromRect(content.width+1, content.height+1);
	content: bind content;
    }

    override var internalContent = Group {
	content: bind [Group { cursor: Cursor.Default; content: [titleBar, buttonBar, line] },
                       TransformNode { ty: -14, content: bind contentHolder }, 
                       resizeCorner, leftSide, rightSide];
    };

    public var debugGadget is Boolean;
    
    override function update to ()
    {
	if (dirty) {
	    dirty = false;
	    resize(width, height);
	}
        var g = parent as Group;
        selected = g.content[g.content.size()-1] == this;
        var hasGadget is HasGadget = null;
	super.update();
        content.foldLeft((), function from (_ is (), n is Node) to () {
                if (debugGadget) {
                    println("checking {n} => {n is HasGadget}");
                }
                if (hasGadget == null and n is HasGadget) {
                    hasGadget = n as HasGadget;
                    println("found has gadget: {n}");
                }
            });
        if (hasGadget == null) {
            if (this.hasGadget <> null) {
                gadget = null;
                this.hasGadget = null;
            }
        }  else {
            gadget = (this.hasGadget = hasGadget).getGadget();
        }
        
    }

    var dx = 0.0;
    var dy = 0.0;

    const onDown = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    dx = cx;
	    dy = cy;
            toFront();
	}
    };

    const onButtonDown = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{

	}
    };

    const onUp = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    gridFit()
	}
    };

    function gridFit to () 
    {
	cx = cx as Integer;
	cy = cy as Integer;
    }

    const onMove = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{     	       		
	    const v = event.picked.dragPoint1 - event.picked.dragPoint0;
	    dx += v.x;
	    dy += v.y;
	    const p0 = toSceneTransform.getTranslation().xy() - new Tuple2(cx, cy);
	    const p1 = p0 + new Vec2(dx, dy);
	    const clamp = new Point2(Math.max(p1.x, width/2), 
				     Math.min(p1.y, containerBounds.top()-height/2));
				     //	    println("p0={p0}, p1={p1}, clamp={clamp}");
	    cx = dx + clamp.x - p1.x;
	    cy = dy + clamp.y - p1.y;
	    //	    println("cx={cx} cy={cy}");
	    gridFit()
	}
    };

    const onResize = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{     	       		
	    const v = event.picked.dragPoint1 - event.picked.dragPoint0;
	    width += v.x;
	    height -= v.y;
	    resize(width, height);
	    cx += v.x/2;
	    cy += v.y/2;
            const w = Math.min(containerBounds.width() - marginx, width);
            const h = Math.min(containerBounds.height() - marginy, height);
            const dx = w - width;
            const dy = h - height;
            cx += dx/2;
            cy -= dy/2;
            width = w;
            height = h;
	}
    };
    
    const marginx = 20;
    const marginy = 20;

    postinit {
	internalContent.observeMouseDown().subscribe(onDown);
        buttonBar.observeMouseDown().subscribe(onButtonDown);
	titleBar.observeMouseUp().subscribe(onUp);
	titleBar.observeMouseDrag().subscribe(onMove);
    	resizeCorner.observeMouseDrag().subscribe(onResize);
	resizeCorner.observeMouseUp().subscribe(onUp);
    }
}