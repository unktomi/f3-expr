package expr.prog;
import f3.media.scene.*;
import f3.util.*;
import f3.util.Observer.*;
import f3.util.Observable.*;
import Expression.Canvas;
import Expression.ExpressionView;
import Expression.LinkedView;
import Expression.LinkView;
import Expression.Member;
import Expression.MemberExpression;
import Expression.ExprScene;
import Expression.ExprNode;
import Expression.GetVarView;
import expr.Context;
import expr.Context.*;
import expr.EventLayer;

public class EvalContext {
    public const eventContext is Context.MemberContext;
    public const interactive is function from () to Boolean;
    public const targetNode is Node;
    public const debugger is ObservableDebugger = ObservableDebugger {
        override function debug of a from (xs is Observable of a, obj is Object) to Observable of a { xs }
    };
    public const instanceSpace is Group;
    public const targetTimeline is Timeline;
    const lookupVar is function from String to Object;
    const lookupSpatial is function from String to Node;
    const lookupTemporal is function from String to TimeNode;
    public const evaluator = 
        new org.f3.tools.script.ScriptShell(java.lang.Thread.currentThread().getContextClassLoader());

    public function evaluate from (prog is Program) to ()
    {
        const f = evaluator.compileAndRun(prog.sourceCode) 
            as function from (ObservableDebugger, Node, 
                              function from String to Object, function from String to Node, function from String to TimeNode) to Observable of ?;
        unsubscribe();
        const obs = f(debugger, targetNode, lookupVar, lookupSpatial, lookupTemporal);
        subscribe(obs, prog.sourceCode);
    }

    public function unsubscribe to () 
    {
	for (x in subs) x.dispose();
        subs = [];
    }

    var subs is Disposable[];

    public function subscribe of a from (obsvb is Observable of a, src is String) to ()
    {
	println("SUBSCRIBE {obsvb}");
        var count = 0;
        const f = interactive;
        var rs = foreach (x in eventContext.content) {
            if (x is Context.ResourceNodeContext) {
                (x as Context.ResourceNodeContext).resource;
            } else null;
        }
	insert obsvb.subscribe(DefaultObserver of a {
		override function onNext from (x is a) to ()
		{
                    if (f()) {
                        for (r in rs) {
                            var n = r.instance(r.id, lookupVar, lookupSpatial, lookupTemporal);
                            println("INSERTING {n} into {instanceSpace} at {targetTimeline.playhead}");
                            insert EventLayer.EventNode {
                                timestamp: targetTimeline.playhead;
                                event: n;
                            } into instanceSpace.content;
                        }
                        count++;
                        println("on next {src} {x}");
                    }
		}
	}) into subs;	
    }
}

public class Program {
    public var event is Member;
    public var canvas is Canvas;
    public var code is ExprScene;
    public var sourceCode is String;

    public const evalContext is EvalContext;

    public function evaluate to () {
        evalContext.evaluate(this)
    }

    public function evaluate from (sourceCode is String) to () {
        this.sourceCode = sourceCode;
        evaluate();
    }

    public function reset to ()
    {
        evalContext.unsubscribe();
    }

    public function deserialize to () {
        var idMap = new java.util.HashMap of (String, ExprNode);
        for (v in code.views) {
            idMap.put(v.id, v);
        }
        canvas.deserializationMap.clear();
        var viewMap = new java.util.HashMap of (String, ExpressionView);
        for (v in code.views) {
            const view = v.createView(canvas);
            println("deserialized {v} into {view}");
        }
        canvas.installLinks();
    }
}