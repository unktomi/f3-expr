package expr;
import f3.media.scene.*;
import f3.media.input.*;
import f3.media.scene.Text.*;
import f3.media.scene.Shape2D.*;
import f3.math.LinearMath.*;
import f3.math.*;
import f3.reflect.*;
import java.lang.Math;

const textFg = ColorPaint(Color.color(.8, .8, .8));
const labelFg = ColorPaint(Color.color(.25, .25, .25));
const textBg = ColorPaint(Color.color(.4, .4, .4));

public class CreateVar is ResizableNode, Focuser {
    public var assetModel is AssetTree.AssetModel;
    bound var font is Font = layoutEngine.createFont(Names.DEFAULT_FONT);
    bound var cellHeight = font.height();
    bound var labelWidth is Number = Math.max(font.width("Name:"), font.width("Type:"))+2;
    bound var fieldOffset is Number = labelWidth + 1;
    bound var fieldWidth is Number = width - 40 - labelWidth;
    public var popupLayer is PopupLayer;
    public var popupScene is Scene;

    public var create is function from (String, AssetTree.TypeAsset) to ();
    public var cancel is function from () to ();

    override public function getTargetOfFocus to Focusable 
    {
        nameField
    }

    function doCreate to ()
    {
        create(nameField.text, selectedType);
    }

    public function reset to ()
    {
        nameField.setText("");
        nameField.update();
        println("nameField=>{nameField.text}");
    }

    const nameLabel is Text.Label = Text.Label {
          text: "Name:"
          font: bind font;
          height: bind cellHeight;
          width: bind labelWidth;
          foreground: bind labelFg;
          background: null;
          transform: bind translate(-width/2+labelWidth, 0);
          rightJustified: true;
    }
    const typeLabel is Text.Label = Text.Label {
          text: "Type:"
          font: bind font;
          height: bind cellHeight;
          width: bind labelWidth;
          foreground: bind labelFg;
          background: null;
          transform: bind translate(-width/2+labelWidth, 0);
          rightJustified: true;
    }
    public const nameField is Text.Field = Text.Field {
        transform: bind translate(fieldOffset-20, 0);
        width: bind fieldWidth;
        height: bind cellHeight;      
        font: bind font;
        foreground: bind textFg;
        background: bind textBg;
    };
    public const typeField is Text.Field = Text.Field {
        transform: bind translate(fieldOffset-20, 0);
        width: bind fieldWidth;
        height: bind cellHeight;      
        font: bind font;
        foreground: bind textFg;
        background: bind textBg;
    };
    var chooseTypeTransform is Mat4 = Mat4.<<1>>;
    const self = this;
    const arrow is Polygon = Polygon {
        transform: rotate(-90, Vec3.Z_AXIS);
	points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
	fillPaint: textFg;
        override function onMouseDown from (e is MouseEvent) to ()
        {
            const v = e.sceneLocation;
            const a = self.boundsInScene.center + new Vec3(fieldOffset/2, -cellHeight*.5+0-200/2, 0);
            const d = a-v;
            const popupLoc = popupScene.mousePosition;
            println("d={d}");
            println("popupLoc={popupLoc}");
            const target = popupLoc + d;
            println("showing at {target}");
            toggleChooser(target);
        }
    };
    const applyButton = TextButton {
        text: "Create"
        transform: translate(30, 0);
        width: 45;
        height: 18;
        enabled: false;
        onPress: function to () 
        {
            self.doCreate();
        }
    }
    const cancelButton = TextButton {
        text: "Cancel";
        transform: translate(-30, 0);
        width: 45;
        onPress: function to () 
        {
            self.cancel();
        }
    }
    public var onApply is function from () to ();
    public var onCancel is function from () to ();
    const chooseType = ChooseType {
        onLoseFocus: hideChooser;
        transform: bind chooseTypeTransform;
        treeModel: bind assetModel;
        visible: false;
        chooseMembers: false;
        onSelectType: bind selectType;
        onEscape: hideChooser;
    };

    var selectedType is AssetTree.TypeAsset;

    function selectType from (t is AssetTree.TypeAsset) to ()
    {
        selectedType = t;
        chooseType.searchField.setText(t.name);
        hideChooser();
    }

    function hideChooser to ()
    {
        chooseType.visible = false;
        delete chooseType from popupLayer.content;
    }

    function showChooser from (target is Point3) to ()
    {
        if (not chooseType.visible) {
            chooseType.visible = true;
            chooseTypeTransform = translate(target); 
            insert chooseType into popupLayer.content;
            popupScene.setFocus(chooseType.getTargetOfFocus());
        }
    }

    function toggleChooser from (target is Point3) to ()
    {
        if (chooseType.visible) {
            hideChooser()
        } else {
            showChooser(target)
        }
    }

    const d1 = nameField.observeText().subscribe(function from (s is String) to () {
        checkButtons();
        });

    const d2 = chooseType.searchField.observeText().subscribe(function from (s is String) to () { 
            checkButtons();
        });
    
    function checkButtons to ()
    {
        if (selectedType == null) {
        }
        const enable = selectedType <> null and nameField.text <> "";
        applyButton.enabled = enable;
    }
    
    var chooseTypeHolder = TransformNode {
        ty: -cellHeight * 1.5 - 200 / 2;
        tx: bind fieldOffset/2;
    }

    override function resize from (w is Number, h is Number) to ()
    {
        super.resize(w, h);
        chooseType.resize(fieldWidth, 200);
    }

    override var internalContent = Group {
        content:
        [Rectangle {
            height: bind height;
            width: bind width;
            fillPaint: ColorPaint(Color.color(.7, .7, .7));
        },
        TransformNode {
            ty: bind 1.5*cellHeight + 1;
            content:             
            bind [nameLabel, nameField]
        },
        TransformNode {
            ty: bind cellHeight/2 - 1;
            content:             
            bind [typeLabel, 
                 TransformNode {
                    tx: bind fieldOffset/2-1;
                    content: bind chooseType.searchField
                 }, 
                 TransformNode {
                     tx: bind (fieldWidth + fieldOffset)/2  - 7;
                     ty: -3.5;
                     content: arrow;
                 }]
        },
        TransformNode {
            ty: bind -1.5*cellHeight -9 - 1;
            content:
            bind [cancelButton, applyButton]
        }]
    }
}