package expr;
import f3.jogl.awt.JoglStage;
import f3.jogl.awt.JoglStage.*;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.util.Bits;
import f3.util.*;
import f3.util.Observer.*;
import f3.media.scene.*;
import f3.media.input.*;
import f3.media.svg.SVG;
import f3.media.xhtml.XHTML;
import java.lang.Math;
import expr.choices.SliderField;
import expr.InternalWindow.HasGadget;
import expr.undo.*;
import expr.inspector.*;
import expr.inspector.Inspector.*;
import expr.ResourceNode.*;
import expr.ResourceTextField.*;
import expr.Resources.TextFieldResource;
import expr.Resources.TextOutputResource;
import expr.Resources.parseColor;
import expr.ResourceTimeNode.*;
import expr.AssetTree.*;
import expr.timeline.*;
import expr.prog.*;
import f3.util.*;
import f3.util.Observer.*;
import f3.util.Observable.*;

public function main from (argv is nativearray of String) to ()
{
    const app = com.apple.eawt.Application.getApplication();
    app.setDockIconImage(new javax.swing.ImageIcon(new java.net.URL("{__DIR__}dock.png")).getImage());
    java.awt.EventQueue.invokeLater(java.lang.Runnable {
            run: function to () {
                org.f3.runtime.Main.main(["expr.Main", argv]);
            }
        });
}

public class InternalWindowState {
    public var id is String;
    public var cx is Number;
    public var cy is Number;
    public var width is Number;
    public var height is Number;
}

public class EditorState {
    public var windowWidth is Integer;
    public var windowHeight is Integer;
    public var internalWindows: InternalWindowState[];
    public var cameraX is Number;
    public var cameraY is Number;
    public var cameraZ is Number;
    public var playheadFrame is Integer = 0;
    public var frameRate is Integer = 24;
    public var recent is String[];
}

function saveEditorState from (scene is Scene, player is Timeline, trax is Trax, recent is String[]) to () 
{
    var internalWindows is InternalWindowState[];
    const f is function from ((), Node) to () 
        = function from (_ is (), n is Node) to ()
        {
            if (n is InternalWindow) {
                const w = n as InternalWindow;
                if (not w.isTransient) {
                    insert InternalWindowState {
                        id: w.id;
                        cx: w.cx;
                        cy: w.cy;
                        width: w.width;
                        height: w.height;
                    } into internalWindows;
                }
            }
        };
    scene.root.foldLeft((), f);
    const file = new java.io.File(".expr.editorstate.tmp");
    const w = new java.io.BufferedWriter(new java.io.FileWriter(file));
    IO.writeObject(w, EditorState {
            windowHeight: scene.stage.outsideHeight;
            windowWidth: scene.stage.outsideWidth;
            internalWindows: internalWindows;
//            playheadFrame: trax.currentFrame as Integer;
            frameRate: trax.frameRate as Integer;
            recent: recent;
        });
    w.flush();
    w.close();
    file.renameTo(new java.io.File(".expr.editorstate"));
}

function loadEditorState from (stage is JoglStage, scene is Scene, player is Timeline, trax is Trax) to String[] 
{
    const file = new java.io.File(".expr.editorstate");
    if (file.exists()) {
        const s = IO.readObject(new java.io.BufferedReader(new java.io.FileReader(file))) as EditorState;
        const f is function from ((), Node) to () 
            = function from (_ is (), n is Node) to ()
        {
            if (n is InternalWindow) {
                const w = n as InternalWindow;
                if (not w.isTransient) for (x in s.internalWindows) {
                    if (x.id == w.id) {
                        w.cx = x.cx;
                        w.cy = x.cy;
                        w.width = x.width;
                        w.height = x.height;
                        break;
                    }
                }
            }
        };
        scene.root.foldLeft((), f);
        if (s.windowHeight <> 0 and s.windowWidth <> 0) {
            stage.resizeWindow(s.windowWidth, s.windowHeight);
        }
        trax.setFrameRate(s.frameRate);
        player.setPlayhead((1s / s.frameRate) * s.playheadFrame);
        var result is String[];
        for (u in s.recent) {
            const x = new java.io.File(new java.net.URL(u).toURI());
            const b = x.exists();
            if (b) insert u into result;
        }
        return result;
    }
    return [];
}

class CachedScene is Scene {
    public var scene is Scene[];
    override var camera = Camera2D {tx: bind -width/2, ty: bind -height/2}
    var stageNode is StageNode = StageNode {
        superSample: 1;
	content: bind scene;
    }
    override function update {
	if (stageNode.width <> width or stageNode.height <> height) {
	    stageNode.resize(width, height);
	}
	super.update();
    }
    override var content = bind stageNode;
}

class ResizableStageNode is ResizableNode, Focuser {
    const stage is StageNode = StageNode {
        background: Color.GRAY;
	content: Scene {
            background: Color.color(.3, .3, .3);
	    camera: Camera2D { tx: bind Math.round(-width / 2.0), ty: bind Math.round(-height / 2.0) }
	    content: bind content;
	}
    }
    override function resize from (w0 is Number, h0 is Number) to ()
    {
	const w = Math.ceil(w0);
	const h = Math.ceil(h0);
	super.resize(w, h);
	content.resize(w, h);
	stage.resize(w as Integer, h as Integer);
    }
    override var internalContent = Group { content: bind stage cursor: bind stage.cursor};
    public var content is ResizableNode;
    override public function getTargetOfFocus to Focusable 
    {
	return stage;
    }
}

function readTextFile from (url is String) to (String, Integer)
{
    const u = new java.net.URL(url);
    const reader = new java.io.BufferedReader(new java.io.InputStreamReader(u.openStream()));
    var line is Object; // sic!
    var buf = new java.lang.StringBuffer;
    var lineCount = 0;
    while ((line = reader.readLine()) <> null) {
	buf.append(line);
	buf.append("\n");
	lineCount++;
    }
    return (buf.toString(), lineCount);

}

public class MainContext is Context.MemberContext, Context.ResourceObjectContext, ResourceTarget {
    override public bound function getTarget to ResourceTarget { this }
    override var member = Expression.Member {
        name: "Start";
        t: Reflect.UNIT_TYPE;
        rt: Reflect.UNIT_TYPE;
        isObservable: yes;
        override function toEnglish to String { "Start" }
        override function toApply to String { "expr.ExprNode.Start" }
        m: Reflect.getVar(Reflect.findClass("expr.ExprNode"), "Start");
    }
    override function createChannels from (parent is ChannelBoxGroup) to (Channel of Number)[]
    {
        []
    }

    function createStart to ()
    {
        createProgram(member);
    }
}

var canUndo is Boolean;
var canRedo is Boolean;
var currentScenes is ResourceScene[] = [];
var doUpdate is Observer of (());

const IMAGE_LOADER = f3.jogl.awt.JoglStage.ImageLoader_INSTANCE;

public function run from (args is String[]) to ()
{
    var mainContext is MainContext = MainContext {
        name: "Start";
    }

    var contextTree is Treeview;

    var contextModel is Context.ContextTreemodel = Context.ContextTreemodel {
        rootContext: bind mainContext;
        transformHierarchy: bind transformHierarchy;
    } 

    contextModel.reset();

    var lastContext is Context;

    function handleContextVisibility from (ctx is Context, v is Boolean) to ()
    {
        //if (true) return;
        var c = ctx;
        while (c <> null) {
            //println("c={c.name} parent={c.parent.name} v={v}");
            for (c1 in [c, c.getContent()]) {
                if (c1 is Context.ResourceNodeContext) {
                    const rc = c1 as Context.ResourceNodeContext;
                    rc.resource.visible = v;
                    if (rc <> ctx and rc.resource is GroupResourceNode) {
                        handleContextVisibility(rc, v);
                    }
                }
            }
            c = c.parent;
        }
    }

    var selectionHandler = contextModel.selectionObserver.subscribe(function from (tn is Treeview.Treenode) to () 
                                                                    {
                                                                        mainContext.updateParent();
                                                                        const ctx = (tn as Context.ContextTreenode).context;
                                                                        handleContextVisibility(lastContext, false);
                                                                        lastContext = ctx;
                                                                        handleContextVisibility(ctx, true);
                                                                    });

    var currentScene is ResourceScene = bind transformHierarchy.selectedScene;

    var currentResource is ResourceGroup = bind currentScene.currentResource;

    const currentAnimResource is ResourceTimeGroup = ResourceTimeGroup {}

    const transformHierarchy is TransformHierarchy = TransformHierarchy {
	scenes: bind currentScenes inverse;
    }

    function selectNodeLater from (n is Node) to ()
    {
        java.awt.EventQueue.invokeLater(java.lang.Runnable {
                override function run to ()
                {
                    println("SELECT NODE LATER {n}");
                    transformHierarchy.selectNode(n);
                }
            });
    }


    const temporalHierarchy = TemporalHierarchy { root: bind currentAnimResource }
    const temporalHierarchy2 = TemporalHierarchy { root: ResourceTimeGroup {
            override var id = "Hierarchy";
            override protected function updateParent to () { // hack...
            }
            content: bind foreach (target in currentResource.resources) target.channelBoxes;
        }
    };
    const otherHierarchy = VariableHierarchy { root: bind mainContext }
    var currentCamera is Camera;
    var TheMovieLoader is MovieLoader;
    try {
	const clazz = 
	    java.lang.Class.forName("org.f3.media.video.macos.MovieLoaderImpl") as java.lang.Class of MovieLoader;
	TheMovieLoader = clazz.newInstance();
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't create corevideo movie loader");
    }
    
    var TheWebBrowserFactory is AbstractWebBrowserFactory;
    try {
	const clazz = 
	    java.lang.Class.forName("f3.media.web.awesomium.AwesomiumWebBrowserFactory") as java.lang.Class of AbstractWebBrowserFactory;
	TheWebBrowserFactory = clazz.newInstance();
	    
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load awesomium web browser factory");
    }

    var TheSoundLoader is SoundLoader;
    try {
	const clazz = 
	    java.lang.Class.forName("org.f3.media.audio.impl.fmod.SoundLoaderImpl") as java.lang.Class of SoundLoader;
	TheSoundLoader = clazz.newInstance();
	    
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load fmod sound factory");
    }

    var bulletDynamicsWorldFactory is DynamicsWorldFactory;
    try {
	const clazz = 
	    java.lang.Class.forName("org.f3.jbullet.JBulletDynamicsWorldFactory") as java.lang.Class of DynamicsWorldFactory;
	bulletDynamicsWorldFactory = clazz.newInstance();
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load jbullet dynamics world factory");
    }

    var box2dDynamicsWorldFactory is DynamicsWorldFactory;
    try {
	const clazz = 
	    java.lang.Class.forName("f3.dynamics.jbox2d.JBox2DDynamicsWorldFactory") as java.lang.Class of DynamicsWorldFactory;
	box2dDynamicsWorldFactory = clazz.newInstance();
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load jbox2d dynamics world factory");
        e.printStackTrace();
    }

    println("args={args}");

    var playerUrl is String;

    const mainTimeLayer = TimeGroup {
	id: "Hierarchy";
	content: currentAnimResource;
	playRange: bind if (nonInteractiveLoop) then null else Interval { start: 0s, end: Duration.INDEFINITE };
	playCount:  bind if (nonInteractiveLoop) then -1 else 1;
        override function lookup from (id is String) to TimeNode
        {
            if (id.startsWith("channelBox:")) {
                const target = id.substring(11);
                for (scene in currentScenes) {
                    for (m in scene.currentModels) {
                        const r = m.timeline.root.lookup(id);
                        if (r <> null) {
                            return r;
                        }
                    }
                }
                println("Time Node not found: {id}");
            }
            return super.lookup(id);
        }
    }

    

    const player = Timeline {
	override var paused = true on replace {
            if (not paused and playhead == 0s) {
                ExprNode.Start.onNext(())
            }
            for (scene in currentScenes) scene.dynamicsWorld.paused = paused;
        }
	content: mainTimeLayer;
    }

    const camera = PerspectiveCamera {
        id: "free";
	ty: 3.0;
	tz: 13;
	near: 1;
	far: 10000;
        content: [PointLight {}, SoundListener {}]
    }

    const freeCamera = camera;
    
    const playhead = player.observePlayhead().subscribe(function from (sceneTime is Duration) to () 
                                                        {
                                                           const finishDynamics = foreach (scene in currentScenes) scene.dynamicsWorld.update(sceneTime, camera);
                                                            for (f in finishDynamics) {
                                                                stage.invoke(f);
                                                            }
                                                        });

    const viewer = DefaultExaminerViewer {
	camera: camera;
    }

    const browser = if TheWebBrowserFactory == null then null else WebBrowser {
	//factory: TheWebBrowserFactory;
	//effectLoader: CGEffectLoader_INSTANCE;
	//pathFactory: ThePath2DFactory;
    }

    
    function addResource from (rn is ResourceNode, pt is Point3) to ()
    {
        println("ADDING {rn} to {currentResource} th.scenes={transformHierarchy.scenes}, th.selectedScene={transformHierarchy.selectedScene}");
        var groupContext is Context.GroupContext = contextModel.selectedGroupContext;
        if (transformHierarchy.selectedNode is GroupResourceNode) {
            insert rn into (transformHierarchy.selectedNode as GroupResourceNode).content;
            groupContext = mainContext.resolveNodeContext(transformHierarchy.selectedNode as ResourceNode);
        } else {
            insert rn into currentResource.resources;
        } 
        var ctx is Context.ResourceNodeContext;
        if (rn is ResourceTextField) {
            ctx = Context.ResourceTextFieldContext { 
                parent: groupContext;
                resource: rn;
            }
        } else if (rn is ResourceLabel) {
            ctx = Context.ResourceLabelContext { 
                parent: groupContext;
                resource: rn;
            }
        } else {
            ctx = Context.ResourceNodeContext { 
                parent: groupContext;
                resource: rn;
            }
        }
        insert ctx into groupContext.content;
        if (rn.displayName == "") {
            rn.displayName = if (rn.$useLiteralId) then rn.id else Names.formatName(rn.id);
        }
        if (currentScene == mainScene) {
            viewer.focusCamera(rn);
        }
        transformHierarchy.selectNode(rn);
        println("added asset to context { contextModel.selectedGroupContext } => {contextModel.selectedGroupContext.content}");
        if (currentScene.camera is Camera2D) {
            rn.tx = pt.x;
            rn.ty = pt.y;
        }
        rn.$dynamicsWorld = currentScene.dynamicsWorld;
    }

    function addTimeResource from (rn is ResourceTimeNode) to ()
    {
        if (rn.displayName == "") {
            rn.displayName = if (rn.$useLiteralId) then rn.id else Names.formatName(rn.id);
        }
        println("ADDING TIME RESOURCE { rn }");
        rn.updateParent();
	insert rn into currentAnimResource.resources;
        mainTimeLayer.content = [];
        mainTimeLayer.content = currentAnimResource;
        mainTimeLayer.updateParent();
        println("all bounds = {mainTimeLayer.bounds}");
        const ctx = Context.ResourceTimeNodeContext { 
            parent: contextModel.selectedGroupContext; 
            resource: rn;
        } 
        insert ctx into contextModel.selectedGroupContext.content;
    }

    function doDrop from (url is String, pt is Point3) to () 
    {
        println("DO DROP : {url}");
	playerUrl = url;
        const loweredUrl = url.toLowerCase();
	if (loweredUrl.endsWith(".expr")) {
	    const model = ExprNode {
                webBrowserFactory: TheWebBrowserFactory
		url: url;
                isInteractive: bind interactive;
                standalone: true;
	    }
	    const rn = ResourceNode {
                url: url;
                content: bind model;
	    }
	    addResource(rn, pt);
            if (not model.standalone) {
                const rtn = ResourceTimeNode {
                    url: url;
                    content: bind model.temporalRoot;
                    spatial: rn;
                }
                if (rtn.bounds.duration() > 0s) {
                    rn.temporal = rtn;
                    addTimeResource(rtn);
                }
            }
	} else if (loweredUrl.endsWith(".mp4") or loweredUrl.endsWith(".mov")) {
            const movie = Movie {
                url: url;
                paused: true;
            }
	    const rn = ResourceNode {
                url: url;
	        content: movie;
	    }
	    addResource(rn, pt);
            const clip = Movie.Clip { movie: movie };
	    const rtn = ResourceTimeNode {
		url: url;
		content: clip
		spatial: rn;
                override function playFromStart to ()
                {
                    super.playFromStart();
                    clip.playMovieFromStart();
                }
	    }
            addTimeResource(rtn);
	} else if (loweredUrl.endsWith(".aif") or 
                   loweredUrl.endsWith(".aiff") or 
                   loweredUrl.endsWith(".asf") or 
                   loweredUrl.endsWith(".asx") or
                   loweredUrl.endsWith(".dls") or
                   loweredUrl.endsWith(".flac") or
                   loweredUrl.endsWith(".fsb") or
                   loweredUrl.endsWith(".it") or
                   loweredUrl.endsWith(".m3u") or
                   loweredUrl.endsWith(".mid") or
                   loweredUrl.endsWith(".midi") or
                   loweredUrl.endsWith(".mod") or
                   loweredUrl.endsWith(".mp2") or
                   loweredUrl.endsWith(".mp3") or
                   loweredUrl.endsWith(".pls") or
                   loweredUrl.endsWith(".pls") or
                   loweredUrl.endsWith(".s3m") or
                   loweredUrl.endsWith(".vag") or
                   loweredUrl.endsWith(".wav") or
                   loweredUrl.endsWith(".wax") or
                   loweredUrl.endsWith(".wma") or
                   loweredUrl.endsWith(".xm") or
                   loweredUrl.endsWith(".xma")){
            const sound = Sound.Sample {
                monitorForChanges: yes;
                url: url;
                paused: true
            }
	    const rn = SoundResourceNode {
                url: url;
	        sound: sound;
	    }
	    const rtn = ResourceTimeNode {
		url: url;
		content: Sound.Clip { sound: sound };
		spatial: rn;
	    }
            rn.temporal = rtn;
	    addResource(rn, pt);
            addTimeResource(rtn);
	} else if (loweredUrl.endsWith(".ma")) {
	    const model = Ma.Model {
                monitorForChanges: yes;
                dynamicsWorld: currentScene.dynamicsWorld;
		url: url;
	    }
	    const rn = MaResourceNode {
	        model: model;
	    }
	    addResource(rn, pt);
	    const rtn = MaResourceTimeNode {
                model: model;
		spatial: rn;
	    }
            rn.temporal = rtn;
            addTimeResource(rtn);
	} else if (loweredUrl.endsWith(".fbx") or 
                   loweredUrl.endsWith(".blend") or
                   loweredUrl.endsWith(".dae") or
                   loweredUrl.endsWith(".3ds") or
                   loweredUrl.endsWith(".ase") or
                   loweredUrl.endsWith(".obj") or
                   loweredUrl.endsWith(".ifc") or
                   loweredUrl.endsWith(".xgl") or
                   loweredUrl.endsWith(".zgl") or
                   loweredUrl.endsWith(".ply") or
                   loweredUrl.endsWith(".dxf") or
                   loweredUrl.endsWith(".lwo") or
                   loweredUrl.endsWith(".lws") or
                   loweredUrl.endsWith(".lxo") or
                   loweredUrl.endsWith(".stl") or
                   loweredUrl.endsWith(".x") or
                   loweredUrl.endsWith(".ac") or
                   loweredUrl.endsWith(".ms3d") or
                   loweredUrl.endsWith(".cob") or
                   loweredUrl.endsWith(".scn") or
                   loweredUrl.endsWith(".bvh") or
                   loweredUrl.endsWith(".csm") or
                   loweredUrl.endsWith(".mdl") or
                   loweredUrl.endsWith(".md2") or
                   loweredUrl.endsWith(".md3") or
                   loweredUrl.endsWith(".pk3") or
                   loweredUrl.endsWith(".md5") or
                   loweredUrl.endsWith(".smd") or
                   loweredUrl.endsWith(".vta") or
                   loweredUrl.endsWith(".m3") or
                   loweredUrl.endsWith(".3d") or
                   loweredUrl.endsWith(".b3d") or
                   loweredUrl.endsWith(".q3d") or
                   loweredUrl.endsWith(".q3o") or
                   loweredUrl.endsWith(".q3s") or
                   loweredUrl.endsWith(".nff") or
                   loweredUrl.endsWith(".raw") or
                   loweredUrl.endsWith(".ter") or
                   loweredUrl.endsWith(".hmp") or
                   loweredUrl.endsWith(".ndo")
                   ) {
            const assimp = F3Assimp {
                monitorForChanges: yes;
                url: url;
            }
	    const rn = F3AssimpResourceNode {
                url: url;
                model: assimp;
		content: bind assimp.spatialRoot;
	    }	
	    addResource(rn, pt);
	    const rtn = ResourceTimeNode {
                url: url;
		spatial: rn;
                content: bind assimp.temporalRoot;
	    }
            rn.temporal = rtn;
            addTimeResource(rtn);
	} else if (loweredUrl.endsWith(".xhtmli")) {
	    const xhtml = XHTML.Text {
		content: readTextFile(url).first;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind xhtml;
	    }	
	    addResource(rn, pt);
	} else if (loweredUrl.endsWith(".xhtml")) {
	    const xhtml = XHTML.Document {
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind xhtml;
	    }	
	    addResource(rn, pt);
	} else if (loweredUrl.endsWith(".svg")) {
	    const svg = SVG {
                monitorForChanges: yes;
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind svg.root;
	    }	
	    addResource(rn, pt);
	} else if (loweredUrl.endsWith(".png") or 
                   loweredUrl.endsWith(".jpg") or 
                   loweredUrl.endsWith(".tif") or 
                   loweredUrl.endsWith(".tiff") or 
                   loweredUrl.endsWith(".bmp") or 
                   loweredUrl.endsWith(".dcx") or 
                   loweredUrl.endsWith(".gif") or 
                   loweredUrl.endsWith(".icns") or 
                   loweredUrl.endsWith(".ico") or 
                   loweredUrl.endsWith(".pcx") or 
                   loweredUrl.endsWith(".psd") or 
                   loweredUrl.endsWith(".rgbe") or 
                   loweredUrl.endsWith(".wbmp") or 
                   loweredUrl.endsWith(".xbm") or 
                   loweredUrl.endsWith(".xpm") or 
                   loweredUrl.endsWith(".tga")) {
	    const image= Image { 
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: image;
	    }	
	    addResource(rn, pt);
	} else {
	    const browser = WebBrowser {
                id: url;
		url: url
	    }
	    const rn = ResourceNode {
                $useLiteralId: true;
		url: url;
                id: url;
		content: browser;
                override function getFocusable to Focusable 
                {
                    browser
                }
	    }
	    const rtn = ResourceTimeNode {
                $useLiteralId: true;
                id: url;
		url: url;
		spatial: rn;
                content: bind [browser.videoClips, browser.audioClips];
	    }
            rn.temporal = rtn;
            addTimeResource(rtn);
	    addResource(rn, pt);
	}
	MasterUndoable.commit();
    }

    var trax is expr.timeline.Trax;
    var graphEditor is expr.timeline.GraphEditor;

    const inspector0 is Inspector = Inspector {
        popupLayer: bind popupLayer;
        var toInspect = bind { var t = temporalHierarchy2.selectedTimeNode; if t <> temporalHierarchy2.root then t else null };
        inspecting: bind Inspector.inspect(toInspect, Reflect.getType("f3.media.scene.TimeNode") as f3.reflect.F3ClassType);
    };

    const inspector1 is Inspector = Inspector {
        popupLayer: bind popupLayer;
        onSetKey: function to () { graphEditor.setKeys() }
        inspecting: bind Inspector.inspect(if (currentTransform == null) then currentScene else currentTransform);
    };

    const inspector2 is Inspector = Inspector {
        popupLayer: bind popupLayer;
        inspecting: bind Inspector.inspect(temporalHierarchy.selectedTransform);
    };

    const inspector3 is Inspector = Inspector {
        popupLayer: bind popupLayer;
        inspecting: bind [Inspector.inspect(otherHierarchy.selectedVariable)];
    }
    
    const inspectors = foreach (i in [inspector0, inspector1, inspector2, inspector3]) {
        Scrollpane { canZoomVertical: false, content: i }
    }

    var inspectorSelection is Integer;

    bound var selectedInspector is ResizableNode = inspectors[inspectorSelection];

    function inspectSpatial to () 
    {
        inspectorSelection = 1;
    }
    function inspectTemporal to () 
    {
        inspectorSelection = 2;
    }
    function inspectKeyable to () 
    {
        inspectorSelection = 0;
    }
    function inspectEventual to () 
    {
        inspectorSelection = 3;
    }

    bound var currentTransform = transformHierarchy.selectedTransform;
    currentCamera = camera;

    var savePoint is Integer;

    var editorScene is Scene;
    var internalWindowsLayer is Group;
    var popupLayerCallback is function from () to ();
    var popupLayer is PopupLayer = PopupLayer {
        height: bind editorScene.height;
        width: bind editorScene.width;
        //transform: bind translate(editorScene.width/2, editorScene.height/2);
        scene: bind editorScene;
    };

    function getUnderMouseInEditor to Pick[] 
    {
	var result is Pick[];
	foreach (x in editorScene.underMouse) {
	    insert x into result;
	    if (x.node is StageNode) {
		for (y in (x.node as StageNode).content) {
		    insert y.underMouse into result;
		}
	    }
	}
	return result;
    }

    const mainScene = ResourceScene {
        id: "Main Scene";
	background: Color.GRAY;
        camera: camera;
        dynamicsWorld: { var w = bulletDynamicsWorldFactory.createDynamicsWorld(); w.paused = true; w }
        paused: bind player.paused;
    }

    const renderComplete = 
        mainScene.observeRenderComplete().subscribe(function from (scene is Scene) to () 
                                                    {
                                                        mainScene.dynamicsWorld.debugDraw(scene.camera) 
                                                    });

    var windowContainingAssets is InternalWindow;
    var assetTreeview is Treeview;
    var assetSearch is AssetSearch = bind AssetSearch {
        tree: bind assetTreeview;
        transform: bind translate(180, 0);
    }

    const assetModel = AssetTree.AssetModel {
        resources: bind mainScene.currentResource;
    }

/*
    const cachedScene = CachedScene {
        background: null;
	scene: mainScene;
    }
*/
    bound function getCamerasFromModel from (m is Ma.Model) to Camera[] {
        foreach (c in m.getCameras()) {
            if (c.id == "topShape" or c.id == "perspShape" or c.id == "frontShape" or c.id == "sideShape") then null else c;
        }
    }

    var stepping is Boolean = false;
    var loop is Boolean = false;
    var nonInteractiveLoop = bind not interactive and loop;
    var full is Boolean = false;

    var interactive is Boolean;
    
    const toolMenu is expr.toolmenu.ToolMenu = expr.toolmenu.ToolMenu {
    	transform: bind translate(stage.width /2, stage.height - 10);
	height: 20;
	width: bind stage.width;
	pause: &player.paused;
	onRewind: function to () { 
            var paused = player.paused;
            player.paused = true;
            player.setPlayhead(0s);
            player.paused = paused;
            println("rewind");
            for (scene in currentScenes) scene.dynamicsWorld.reset();
        }
	onHideFloating: function from (b is Boolean) to ()
	{
	    internalWindowsLayer.visible = b;
	}
	toggleLoop: function { loop = not loop; () }
        toggleStepping: function { stepping = not stepping; () } 
	toggleFullscreen: function { full = not full; stage.setFullscreen(full) }
        onSetSelecting: function from () to () {
            interactive = false;
            delete mainScene.instanceSpace.content;
        }
        onSetScripting: function from () to () {
            interactive = true;
        }
    };

    readonly var toolCursor is Cursor = bind if (interactive) then toolMenu.scriptingCursor else toolMenu.selectingCursor;

    const sceneMenu = Tabview {
          transform: bind translate(stage.width/2, stage.height-30);
          tabs: bind foreach (scene in transformHierarchy.scenes) Tabview.Tab {
                title: bind scene.id;
                onSelect: function from () to () 
                {
                    transformHierarchy.selectScene(scene);                        
                }
          }
          override function update to ()
          {
              resize(stage.width, 20);
              super.update();
          }
    }
    
    const MENU_HEIGHT = 40;

    const disp = transformHierarchy.observeSceneSelection().subscribe(function from (n is ResourceScene) to () {        
            sceneMenu.selectedIndex = Sequences.indexOf(transformHierarchy.scenes, n);
	});
    
    var manip is expr.manipulator.Manipulator;

    function save to Boolean 
    {
        if (mainScene.currentResource.url == "") {
            var result = fileSave.open();
            if (result <> null) {
                if (not result.endsWith(".expr")) {
                    result = "{result}.expr";
                }
                mainScene.currentResource.url = "file:{result}";
            } else {
                return false;
            }
        }
        doSave();
    }

    function doSave to Boolean 
    {
        if (mainScene.currentResource.url <> "") {
            savePoint = MasterUndoable.now;
            updateRecent(mainScene.currentResource.url);
            Resources.save(mainScene.currentResource.url,
                           mainContext.programs,
                           mainScene,
                           mainScene.currentResource,
                           currentAnimResource,
                           currentScenes[x | x <> mainScene]);
            return true;
        }
        return false;
    }

    function doExport to () 
    {
        save();
        const u = new java.net.URL(mainScene.currentResource.url);
        fileSave.fileName = "{new java.io.File(u.getFile()).getName()}.zip";
        fileSave.title = "Export";
        var result = fileSave.open();
        if (result <> null) {
            Resources.export(result,
                             mainScene.currentResource.url,
                             mainScene,
                             mainScene.currentResource,
                             currentAnimResource,
                             currentScenes[x | x <> mainScene]);
        }
        return true;
    }

    
    function close from () to () 
    {
	savePoint = 0;
        for (scene in currentScenes) {
            scene.dynamicsWorld.reset();
        }
        mainScene.currentResource.url = "";
        currentScenes = [mainScene];
	mainScene.currentResource.resources = [];
        mainScene.instanceSpace.content = [];
        mainScene.camera = freeCamera;
	currentAnimResource.resources = [];
        mainTimeLayer.content = [];
        mainTimeLayer.content = currentAnimResource;
        mainContext = MainContext {
            name: "Start";
        }
        ExprNode.Start.disposeAll();
        contextModel.reset();
        contextTree.select(contextModel.root);
	transformHierarchy.clearSelection();
        transformHierarchy.selectScene(mainScene);
        temporalHierarchy.clearSelection();
        temporalHierarchy2.clearSelection();
        playerUrl = "";
	MasterUndoable.reset();
    }

    function findTypeAsset from (t is String) to TypeAsset 
    {
        const r = assetModel.findTypeAsset(t);
        println("FIND TYPE ASSET {t} => {r}");
        return r;
    }

    function resolveContext from (n is ResourceNode, p is Program) to Context.GroupContext
    {
        var r is Context.GroupContext;
        mainContext.foldLeft((), function from (_ is (), c is Context) to () 
                             {
                                 if (r == null and c is Context.ResourceNodeContext) {
                                     const rc = c as Context.ResourceNodeContext;
                                     if (rc.resource == n) {
                                         var rc1 = rc;
                                         if (p.targetPath <> "") {
                                             rc.foldLeft((), function from (_ is (), c is Context) to () {
                                                     if (c is Context.SubResourceNodeContext) {
                                                         const g = c as Context.SubResourceNodeContext;
                                                         if (g.node.id == p.targetPath) {
                                                             rc1 = g;
                                                         }
                                                     }
                                                 });
                                         }
                                         const mc is Context.MemberContext = rc1.createProgram(p.event);
                                         mc.program = p;
                                         r = mc;
                                     }
                                 }
                                 return ();
                             });
        return r;
    }

    const undoList = expr.undo.UndoList {} on replace {
	undoList.addTarget("timenodes", &currentAnimResource.resources);
    }

    function updateRecent from (url is String) to ()
    {
        delete url from recentList;
        insert url before recentList[0];
        delete recentList[10..];
    }

    function open from (url is String) to ()
    {
	close();
	const sceneRes = Resources.open(url);
        var allPrograms is Program[];
        var baseURL = new java.net.URL(url);
        function rebaseURL from (u is String) to String {
            if (u.startsWith("timenode://") or u.contains("#")) then u else new java.net.URL(baseURL, u).toString();
        }
        const topLevels = foreach (prog in sceneRes.programs where prog.code <> null) {
            const p = Program {
                event: mainContext.member,
                code: prog.code;
                sourceCode: prog.compiled;
                evalContext: Program.EvalContext {
                    eventContext: mainContext;
                    interactive: function from () to Boolean { interactive } 
                    targetNode: mainContext.getTarget();
                    instanceSpace: currentScene.instanceSpace;
                    lookupSpatial: currentScene.root.lookup;
                    targetTimeline: player;
                    lookupTemporal: mainTimeLayer.lookup;
                }
            }
            println("CREATED PROGRAM {p.event}");
            println("code=>{p.sourceCode}");
            var ps = [p];
            mainContext.program = p;
            for (d in prog.variables) {
                const v = Context.ClosureVarContext {
                    parent: mainContext,
                    variableName: d.varName;
                    varType: findTypeAsset(d.varType);
                }
                insert v into mainContext.content;
                println("CREATED VAR: {v}");
                const vp = Program {
                    parent: p
                    event: p.event;
                    code: d.code;
                    sourceCode: d.sourceCode;
                    evalContext: Program.EvalContext {
                        eventContext: mainContext;
                        varContext: v;
                        interactive: function from () to Boolean { interactive } 
                        targetNode: mainContext.getTarget();
                        instanceSpace: currentScene.instanceSpace;
                        lookupSpatial: currentScene.root.lookup;
                        targetTimeline: player;
                        lookupTemporal: mainTimeLayer.lookup;
                    }
                }
                v.program = vp;
                p.defineVar(v, vp);
                insert vp into ps;
            }
            insert p into allPrograms;
            ps
        }
        mainContext.programs = topLevels;
        function makeSpatRes from (i is Resources.SpatialResource) to ()
        {
            if (i is TextFieldResource) {
                const r = i as TextFieldResource;
                const tf = ResourceTextField {
                    id: r.id;
                    url: r.url;
                    fontSize: new FontSizeSelection(r.fontSize);
                    fontFamily: new FontFamilySelection(r.fontFamily);
                    fontStyle: new FontStyleSelection(r.fontStyle);
                    fontWeight: new FontWeightSelection(r.fontWeight);
                    foreground: parseColor(r.foreground);
                    background: parseColor(r.background);
                    width: r.width;
                };
                tf.setText(r.text);
                addResource(tf, new Point3(i.tx, i.ty, i.tz));
            } else if (i is TextOutputResource) {
                const r = i as TextOutputResource;
                const tf = ResourceLabel {
                    id: r.id;
                    url: r.url;
                    fontSize: new FontSizeSelection(r.fontSize);
                    fontFamily: new FontFamilySelection(r.fontFamily);
                    fontStyle: new FontStyleSelection(r.fontStyle);
                    fontWeight: new FontWeightSelection(r.fontWeight);
                    foreground: parseColor(r.foreground);
                    background: parseColor(r.background);
                    width: r.width;
                };
                tf.setText(r.text);
                addResource(tf, new Point3(i.tx, i.ty, i.tz));
            } else if (i is Resources.SpatialResourceGroup) {
                const gn = GroupResourceNode {
                    url: i.url;
                }
                addResource(gn, new Point3(i.tx, i.ty, i.tz));
            } else {
                doDrop(rebaseURL(i.url), new Point3(i.tx, i.ty, i.tz));
            }
	    currentTransform.tx = i.tx;
	    currentTransform.ty = i.ty;
	    currentTransform.tz = i.tz;

	    currentTransform.sx = i.sx;
	    currentTransform.sy = i.sy;
	    currentTransform.sz = i.sz;

	    currentTransform.rx = i.rx;
	    currentTransform.ry = i.ry;
	    currentTransform.rz = i.rz;

	    currentTransform.px = i.px;
	    currentTransform.py = i.py;
	    currentTransform.pz = i.pz;
            const rn = (currentTransform as ResourceNode);
            if (i.colliderResource <> null) {
                const r = i.colliderResource;
                rn.collidable = r.collidable;
                rn.collidableMass = r.mass;
                rn.collidableFriction = r.friction;
                rn.collidableRestitution = r.restitution;
                rn.collidableType = 
                    if (r.colliderType == "Dynamic") then RigidBodyType.Dynamic
                        else if (r.colliderType == "Kinematic") then RigidBodyType.Kinematic 
                            else RigidBodyType.Static;
                                                                     
            }
            rn.programs = foreach (prog in i.programs) {
                const mem = prog.event.deserialize();;
                const p = Program {
                    event: mem;
                    code: prog.code;
                    sourceCode: prog.compiled;
                    targetPath: prog.targetPath;
                    evalContext: Program.EvalContext {
                        interactive: function from () to Boolean { interactive } 
                        targetNode: (currentTransform as ResourceTarget).findTarget(prog.targetPath);
                        instanceSpace: currentScene.instanceSpace;
                        lookupSpatial: currentScene.root.lookup;
                        targetTimeline: player;
                        lookupTemporal: mainTimeLayer.lookup;
                    }
                }
                var ps = [p];
                var targetContext = resolveContext(rn, p);
                println("RESOLVED CONTEXT {rn} => {targetContext}");
                for (d in prog.variables) {
                    const v = Context.ClosureVarContext {
                        parent: targetContext;
                        variableName: d.varName;
                        varType: findTypeAsset(d.varType);
                        isShortcut: d.isShortcut;
                    }
                    insert v into targetContext.content;
                    println("CREATED VAR: {v}");
                    const vp = Program {
                        parent: p;
                        event: p.event;
                        code: d.code;
                        sourceCode: d.sourceCode;
                        targetPath: prog.targetPath;
                        evalContext: Program.EvalContext {
                            eventContext: targetContext as Context.MemberContext;
                            varContext: v;
                            interactive: function from () to Boolean { interactive } 
                            targetNode: (currentTransform as ResourceTarget).findTarget(prog.targetPath);
                            instanceSpace: currentScene.instanceSpace;
                            lookupSpatial: currentScene.root.lookup;
                            targetTimeline: player;
                            lookupTemporal: mainTimeLayer.lookup;
                        }
                    }
                    v.program = vp;
                    p.defineVar(v, vp);
                    insert vp into ps;
                }
                println("CREATING PROGRAM**** {prog} => {p.sourceCode}");
                insert p into allPrograms;
                ps
            }
            for (j in i.animation) {
                // @TODO handle layers
                if (j is Resources.ChannelBoxResource) {
                    const box = j as Resources.ChannelBoxResource;
                    const channelBox = rn.addChannelBox(box.n_id);
                    channelBox.playTime = box.playTime;
                    channelBox.playRate = box.playRate;
                    channelBox.playCount = box.playCount;
                    channelBox.blendWeight = 1.0;//i.animation.blendWeight;
                    foreach (x in box.channels) {
                        const c = channelBox.resolveChannel(x.target);
                        c.playTime = x.playTime;
                        c.playCount = x.playCount;
                        c.playRate = x.playRate;
                        c.blendWeight = x.blendWeight;
                        c.keys = foreach (k in x.keys) {
                            c.createKey(k.keyTime, k.keyValue, f3.media.scene.KeyFrame.Linear);
                        }
                    }
                }
            }
            if (i is Resources.SpatialResourceGroup) {
                const g = i as Resources.SpatialResourceGroup;
                for (x in g.resources) {
                    makeSpatRes(x);
                }
            }
        }
	for (i in sceneRes.spatialResources) {
            println("I={i}");
            /*
            if (i is TextFieldResource) {
                const r = i as TextFieldResource;
                const tf = ResourceTextField {
                    id: r.id;
                    url: r.url;
                    fontSize: new FontSizeSelection(r.fontSize);
                    fontFamily: new FontFamilySelection(r.fontFamily);
                    fontStyle: new FontStyleSelection(r.fontStyle);
                    fontWeight: new FontWeightSelection(r.fontWeight);
                    foreground: parseColor(r.foreground);
                    background: parseColor(r.background);
                    width: r.width;
                };
                tf.setText(r.text);
                addResource(tf, new Point3(i.tx, i.ty, i.tz));
            } else if (i is TextOutputResource) {
                const r = i as TextOutputResource;
                const tf = ResourceLabel {
                    id: r.id;
                    url: r.url;
                    fontSize: new FontSizeSelection(r.fontSize);
                    fontFamily: new FontFamilySelection(r.fontFamily);
                    fontStyle: new FontStyleSelection(r.fontStyle);
                    fontWeight: new FontWeightSelection(r.fontWeight);
                    foreground: parseColor(r.foreground);
                    background: parseColor(r.background);
                    width: r.width;
                };
                tf.setText(r.text);
                addResource(tf, new Point3(i.tx, i.ty, i.tz));
            } else {
                doDrop(rebaseURL(i.url), new Point3(i.tx, i.ty, i.tz));
            }
	    currentTransform.tx = i.tx;
	    currentTransform.ty = i.ty;
	    currentTransform.tz = i.tz;

	    currentTransform.sx = i.sx;
	    currentTransform.sy = i.sy;
	    currentTransform.sz = i.sz;

	    currentTransform.rx = i.rx;
	    currentTransform.ry = i.ry;
	    currentTransform.rz = i.rz;

	    currentTransform.px = i.px;
	    currentTransform.py = i.py;
	    currentTransform.pz = i.pz;
            const rn = (currentTransform as ResourceNode);
            if (i.colliderResource <> null) {
                const r = i.colliderResource;
                rn.collidable = r.collidable;
                rn.collidableMass = r.mass;
                rn.collidableFriction = r.friction;
                rn.collidableRestitution = r.restitution;
                rn.collidableType = 
                    if (r.colliderType == "Dynamic") then RigidBodyType.Dynamic
                        else if (r.colliderType == "Kinematic") then RigidBodyType.Kinematic 
                            else RigidBodyType.Static;
                                                                     
            }
            rn.programs = foreach (prog in i.programs) {
                const mem = prog.event.deserialize();;
                const p = Program {
                    event: mem;
                    code: prog.code;
                    sourceCode: prog.compiled;
                    targetPath: prog.targetPath;
                    evalContext: Program.EvalContext {
                        interactive: function from () to Boolean { interactive } 
                        targetNode: (currentTransform as ResourceTarget).findTarget(prog.targetPath);
                        instanceSpace: currentScene.instanceSpace;
                        lookupSpatial: currentScene.root.lookup;
                        targetTimeline: player;
                        lookupTemporal: mainTimeLayer.lookup;
                    }
                }
                var ps = [p];
                var targetContext = resolveContext(rn, p);
                println("RESOLVED CONTEXT {rn} => {targetContext}");
                for (d in prog.variables) {
                    const v = Context.ClosureVarContext {
                        parent: targetContext;
                        variableName: d.varName;
                        varType: findTypeAsset(d.varType);
                        isShortcut: d.isShortcut;
                    }
                    insert v into targetContext.content;
                    println("CREATED VAR: {v}");
                    const vp = Program {
                        parent: p;
                        event: p.event;
                        code: d.code;
                        sourceCode: d.sourceCode;
                        targetPath: prog.targetPath;
                        evalContext: Program.EvalContext {
                            eventContext: targetContext as Context.MemberContext;
                            varContext: v;
                            interactive: function from () to Boolean { interactive } 
                            targetNode: (currentTransform as ResourceTarget).findTarget(prog.targetPath);
                            instanceSpace: currentScene.instanceSpace;
                            lookupSpatial: currentScene.root.lookup;
                            targetTimeline: player;
                            lookupTemporal: mainTimeLayer.lookup;
                        }
                    }
                    v.program = vp;
                    p.defineVar(v, vp);
                    insert vp into ps;
                }
                println("CREATING PROGRAM**** {prog} => {p.sourceCode}");
                insert p into allPrograms;
                ps
            }
            for (j in i.animation) {
                // @TODO handle layers
                if (j is Resources.ChannelBoxResource) {
                    const box = j as Resources.ChannelBoxResource;
                    const channelBox = rn.addChannelBox(box.n_id);
                    channelBox.playTime = box.playTime;
                    channelBox.playRate = box.playRate;
                    channelBox.playCount = box.playCount;
                    channelBox.blendWeight = 1.0;//i.animation.blendWeight;
                    foreach (x in box.channels) {
                        const c = channelBox.resolveChannel(x.target);
                        c.playTime = x.playTime;
                        c.playCount = x.playCount;
                        c.playRate = x.playRate;
                        c.blendWeight = x.blendWeight;
                        c.keys = foreach (k in x.keys) {
                            c.createKey(k.keyTime, k.keyValue, f3.media.scene.KeyFrame.Linear);
                        }
                    }
                }
            }
            */
            makeSpatRes(i);
	}
        var tempResources = currentAnimResource.resources;
        currentAnimResource.resources = [];
	for (i in sceneRes.temporalResources) {
            var q is TimeNode;
            if (i.url.contains("#")) { // clip from library
                for (x in currentResource.resources) {
                    if (x is MaResourceNode) {
                        const j = (x as MaResourceNode).temporal;
                        q = j.lookup(i.url);
                    }
                }
            } else {
                for (j in tempResources) {
                    if (i.url == j.url) {
                        q = j;
                        break;
                    } 
                }
            }
            if (q <> null) {
                q.playTime = i.playTime;
                q.playRate = i.playRate;
                q.playCount = i.playCount;
                const qt = q as ResourceTimeNode;
                insert qt into currentAnimResource.resources;
                qt.programs = foreach (prog in i.programs) {
                    const p = Program {
                        event: prog.event.deserialize();
                        code: prog.code;
                        sourceCode: prog.compiled;
                        targetPath: prog.targetPath;
                        evalContext: Program.EvalContext {
                            interactive: function from () to Boolean { interactive } 
                            targetNode: qt;
                            instanceSpace: currentScene.instanceSpace;
                            lookupSpatial: currentScene.root.lookup;
                            targetTimeline: player;
                            lookupTemporal: mainTimeLayer.lookup;
                        }
                    }
                    println("CREATING PROGRAM**** {prog} => {p.sourceCode}");
                    insert p into allPrograms;
                    p;
                }
            } else {
                println("Couldn't resolve temporal resource: {i.url}");
                null;
            }
	}
        for (j in sceneRes.layers) {
            var scene = ResourceScene {
                paused: bind player.paused;
                background: null;
                id: j.name;
                camera: Camera2D { near: -1000, far: 1000, tz: 900 };   
                dynamicsWorld: {
                    var w = box2dDynamicsWorldFactory.createDynamicsWorld();
                    w.paused = player.paused;
                    w
                }
            }
            insert scene into currentScenes;
            transformHierarchy.selectScene(scene);
            foreach (i in j.spatialResources) {
                println("JI={i}");
                if (i is TextFieldResource) {
                    const r = i as TextFieldResource;
                    const tf = ResourceTextField {
                        url: r.url;
                        id: r.id;
                        fontSize: new FontSizeSelection(r.fontSize);
                        fontFamily: new FontFamilySelection(r.fontFamily);
                        fontStyle: new FontStyleSelection(r.fontStyle);
                        fontWeight: new FontWeightSelection(r.fontWeight);
                        foreground: parseColor(r.foreground);
                        background: parseColor(r.background);
                        width: r.width;
                    };
                    tf.setText(r.text);
                    addResource(tf, new Point3(i.tx, i.ty, i.tz));
                } else if (i is TextOutputResource) {
                    const r = i as TextOutputResource;
                    const tf = ResourceLabel {
                        url: r.url;
                        id: r.id;
                        fontSize: new FontSizeSelection(r.fontSize);
                        fontFamily: new FontFamilySelection(r.fontFamily);
                        fontStyle: new FontStyleSelection(r.fontStyle);
                        fontWeight: new FontWeightSelection(r.fontWeight);
                        foreground: parseColor(r.foreground);
                        background: parseColor(r.background);
                        width: r.width;
                    };
                    tf.setText(r.text);
                    addResource(tf, new Point3(i.tx, i.ty, i.tz));
                } else {
                    doDrop(rebaseURL(i.url), new Point3(i.tx, i.ty, i.tz));
                }
                currentTransform.tx = i.tx;
                currentTransform.ty = i.ty;
                currentTransform.tz = i.tz;
                
                currentTransform.sx = i.sx;
                currentTransform.sy = i.sy;
                currentTransform.sz = i.sz;
                
                currentTransform.rx = i.rx;
                currentTransform.ry = i.ry;
                currentTransform.rz = i.rz;
                
                currentTransform.px = i.px;
                currentTransform.py = i.py;
                currentTransform.pz = i.pz;
                const rn = (currentTransform as ResourceNode);
                if (i.colliderResource <> null) {
                    const r = i.colliderResource;
                    rn.collidable = r.collidable;
                    rn.collidableMass = r.mass;
                    rn.collidableFriction = r.friction;
                    rn.collidableRestitution = r.restitution;
                    rn.collidableType = 
                        if (r.colliderType == "Dynamic") then RigidBodyType.Dynamic
                            else if (r.colliderType == "Kinematic") then RigidBodyType.Kinematic 
                                else RigidBodyType.Static;
                                                                     
                }
                rn.programs = foreach (prog in i.programs) {
                    const p = Program {
                        event: prog.event.deserialize();
                        code: prog.code;
                        sourceCode: prog.compiled;
                        targetPath: prog.targetPath;
                        evalContext: Program.EvalContext {
                            interactive: function from () to Boolean { interactive } 
                            targetNode: currentTransform;
                            instanceSpace: currentScene.instanceSpace;
                            lookupSpatial: currentScene.root.lookup;
                            targetTimeline: player;
                            lookupTemporal: mainTimeLayer.lookup;
                        }
                    }
                    var ps = [p];
                    var targetContext = resolveContext(rn, p);
                    println("RESOLVED CONTEXT {rn} => {targetContext}");
                    for (d in prog.variables) {
                        const v = Context.ClosureVarContext {
                            parent: targetContext;
                            variableName: d.varName;
                            varType: findTypeAsset(d.varType);
                            isShortcut: d.isShortcut;
                        }
                        insert v into targetContext.content;
                        println("CREATED VAR: {v}");
                        const vp = Program {
                            parent: p;
                            event: p.event;
                            code: d.code;
                            sourceCode: d.sourceCode;
                            targetPath: prog.targetPath;
                            evalContext: Program.EvalContext {
                                eventContext: targetContext as Context.MemberContext;
                                varContext: v;
                                interactive: function from () to Boolean { interactive } 
                                targetNode: (currentTransform as ResourceTarget).findTarget(prog.targetPath);
                                instanceSpace: currentScene.instanceSpace;
                                lookupSpatial: currentScene.root.lookup;
                                targetTimeline: player;
                                lookupTemporal: mainTimeLayer.lookup;
                            }
                        }
                        v.program = vp;
                        p.defineVar(v, vp);
                        insert vp into ps;
                    }
                    println("CREATING PROGRAM**** {prog} => {p.sourceCode}");
                    insert p into allPrograms;
                    ps;
                }
            }
        }
        function convertTimeResource from (i is Resources.TemporalResource) to TimeNode {
            var t is TimeNode;
            if (i.url.startsWith("timenode://TransitionLayer")) {
                t = TransitionLayer {
                    id: i.url;
                    content: foreach (j in i.content) {
                        convertTimeResource(j)
                    }
                }
                const rtn = ResourceTimeNodeWrapper {
                    url: i.url;
                    wrapped: t as TimeGroup;
                    blendWeight: i.blendWeight;
                    playTime: i.playTime;
                    playRate: i.playRate;
                    playCount: i.playCount;
                };
                t = rtn;
                // addTimeResource(rtn);
            } else if (i.url.startsWith("timenode://BlendLayer")) {
                t = BlendLayer {
                    id: i.url;
                    content: foreach (j in i.content) {
                        convertTimeResource(j)
                    }
               }
               const rtn = ResourceTimeNodeWrapper {
                    blendWeight: i.blendWeight;
                    playTime: i.playTime;
                    playRate: i.playRate;
                    playCount: i.playCount;
                    url: i.url;
                    wrapped: t as TimeGroup;
                };
                t = rtn;
                //addTimeResource(rtn);
            } else if (i.url.startsWith("timenode://Layer")) {
                t = TimeGroup {
                    id: i.url;
                    content: foreach (j in i.content) {
                        convertTimeResource(j)
                    }
                }
                const rtn = ResourceTimeNodeWrapper {
                    blendWeight: i.blendWeight;
                    playTime: i.playTime;
                    playRate: i.playRate;
                    playCount: i.playCount;
                    url: i.url;
                    wrapped: t as TimeGroup;
                };
                t = rtn;
                //addTimeResource(rtn);
            } else {
                const u = rebaseURL(i.url);
                t = mainTimeLayer.lookup(u);
                if (t == null) {
                    for (x in currentResource.resources) {
                        if (u == x.url) {
                            t = x.temporal;
                            break;
                        } else {
                            if (x is MaResourceNode) {
                                const j = (x as MaResourceNode).temporal;
                                t = j.lookup(u);
                                if (t <> null) {
                                    const rtn = ResourceTimeNodeWrapper {
                                        url: i.url;
                                        wrapped: t as TimeGroup;
                                        blendWeight: i.blendWeight;
                                        playTime: i.playTime;
                                        playRate: i.playRate;
                                        playCount: i.playCount;
                                    };
                                    t = rtn;
                                    break;
                                }
                            }
                        }
                    }
                } 
            }
            println("CONVERT TIME RESOURCE : {i.url} => {t}");
            t;
        }
        var resulting = 
            foreach (i in sceneRes.temporalResources) {
                convertTimeResource(i);
            }
        currentAnimResource.resources = resulting as ResourceTimeNode[];
        mainTimeLayer.content = [];
        mainTimeLayer.content = currentAnimResource;
        println("SET ANIM RESOURCES bounds={mainTimeLayer.bounds}");
        transformHierarchy.selectScene(mainScene);
        for (p in allPrograms) p.evaluate();
	MasterUndoable.reset();
	MasterUndoable.commit();
	savePoint = MasterUndoable.now;
	mainScene.currentResource.url = url;
        updateRecent(url);
    }

    var recentList is String[];

    const yesNo = Dialog.YesNoCancel {}

    const fileSave = FileDialog.FileSave {}

    const fileOpen = FileDialog.FileOpen {
	filterExtensions: [".expr"]
    }

    function fileDirty to Boolean {
	MasterUndoable.canUndo();
    }

    var manipLayer = Scene {
        //visible: bind internalWindowsLayer.visible;
        background: null;
        camera: bind currentScene.camera;
        override var content = 
            [manip = expr.manipulator.Manipulator {
                visible: bind currentTransform <> null;
                viewer: viewer;
                target: bind currentTransform;
                scene: this;
            }, 
            Group {
                var viewScale = bind uniformScale(manip.viewScale*.5);
                content: bind foreach  (cam in currentScene.currentCameras) {
                    var cameraModel = Ma.Model {
                        url: "{__DIR__}camera.ma";
                    }
                    Group {
                        transform: bind cam.toSceneTransform;
                        content: Group {
                            transform: bind viewScale;
                            content: bind cameraModel.getSpatialRoot();
                        }
                    }
                }
            }]
        };
        
        var _ = editorScene = Scene {
            var lastTime is Long;
            override function update {
                const now = java.lang.System.currentTimeMillis();
                if (lastTime == 0) {
                    recentList = loadEditorState(joglStage(), this, player, trax);
                    lastTime = now;
                } else if (now - lastTime > 2000) {
                    saveEditorState(this, player, trax, recentList);
                    if (savePoint <> MasterUndoable.now) {
                        doSave();
                    }
                    lastTime = now;
                }
                super.update();
            }
            background: null;
            camera: Camera2D {}; 
            override var content =
		    [internalWindowsLayer = Group { 

                       content: 
                       [windowContainingAssets = InternalWindow {

                        id: "Editor3";
                        //debugGadget: true;
			containerBounds: bind Bounds.boundsFromRect(0, 
                                                                    0, 
                                                                    width,
                                                                    height-MENU_HEIGHT)
		    	height: 400, width: 300;
                                    content: ResizableStageNode {
                                        content: Tabview  {
                                            tabs: 
                                            [
                                 Tabview.Tab {
                                     var browse = BrowseControl of Context {
                                         history: bind contextModel.history;
                                         transform: bind translate(-windowContainingAssets.width/2+20, 1);
                                     }
                                     onSelect: function to ()
                                     { 
                                         windowContainingAssets.gadget = browse;
                                     }
                                        onLoseSelection: function to () 
                                     {
                                         windowContainingAssets.gadget = null;
                                     }
                                     title: "Events";
                                     content: Scrollpane {
                                         canZoomVertical: false;
                                         content: contextTree = Treeview {
                                             var handleCreate is function from (String, AssetTree.TypeAsset) to ();
                                             var createVar = CreateVar {
                                                     assetModel: bind assetModel;
                                                     popupLayer: bind popupLayer;
                                                     popupScene: bind editorScene;
                                                     create: function from (name is String, asset is AssetTree.TypeAsset) to () {
                                                         handleCreate(name, asset);
                                                         delete win from popupLayer.content;
                                                         popupLayer.modal = false;
                                                     }
                                                     cancel: function to () {
                                                         delete win from popupLayer.content;
                                                         popupLayer.modal = false;
                                                     }
                                             };
                                             var win = InternalWindow {
                                                 isMovable: false;
                                                 isResizable: false;
                                                 isTransient: true;
                                                 gadget: Text.Label {
                                                     text: "Create Variable";
                                                     override var font = bind layoutEngine.createFont(Names.DEFAULT_FONT); 
                                                     background: null;
                                                     foreground: Shape2D.ColorPaint(Color.color(.8, .8, .8));
                                                     transform: translate(2, 2);
                                                 }
                                                 containerBounds: bind Bounds.boundsFromRect(0, 
                                                                                             0, 
                                                                                             width,
                                                                                             height-MENU_HEIGHT);
                                                 content: createVar;
                                                 height: 140, width: 300;
                                                 //cx: e.sceneLocation.x, cy: e.sceneLocation.y;
                                             };
                                             model: bind contextModel;
                                                        override function onMouseDown from (e is MouseEvent) to ()
                                                        {
                                                            if (e.isMouseButton3Down()) {
                                                                const ctx = (contextTree.selectedTreenode as Context.ContextTreenode).context;
                                                                if (ctx is Context.ResourceObjectContext) {
                                                                    const r = ctx as Context.ResourceObjectContext;
                                                                    const members = r.getMembers();
                                                                    const menu = Menu {
                                                                        items: 
                                                                        [if (members == []) then null else Menu {
                                                                            label: "Events"
                                                                            items: 
                                                                            foreach (j in members) {
                                                                                MenuItem {
                                                                                    label: Names.formatName(j.name);
                                                                                    action: function to () 
                                                                                    {
                                                                                        println("calling create program {j} on {r}");
                                                                                        r.createProgram(j);
                                                                                    }
                                                                                }
                                                                            }
                                                                        },
                                                                        Menu {
                                                                            label: "New";
                                                                            items:[
                                                                                   MenuItem {
                                                                                       label: "Variable"
                                                                                           action: function to () 
                                                                                       {
                                                                                           createVar.reset();
                                                                                           win.cx = windowContainingAssets.boundsInScene.center.x;
                                                                                           win.cy = windowContainingAssets.boundsInScene.center.y;
                                                                                           handleCreate = function from (name is String, asset is AssetTree.TypeAsset) to () 
                                                                                               {
                                                                                                   var g = ctx as Context.GroupContext;
                                                                                                   insert Context.ClosureVarContext { 
                                                                                                       variableName: name;
                                                                                                       varType: asset;
                                                                                                       parent: g;
                                                                                                       isShortcut: false;
                                                                                                   }
                                                                                                   into g.content;
                                                                                                   
                                                                                               }
                                                                                           insert win into popupLayer.content;
                                                                                           editorScene.setFocus(createVar.nameField);
                                                                                           popupLayer.modal = true;
                                                                                       }
                                                                                   },
                                                                                   MenuItem {
                                                                                       label: "Function";
                                                                                   }
                                                                                ]
                                                                        }]
                                                                    };
                                                                    e.stage.showPopupMenu(e.screenx, e.screeny+contextTree.cellHeight, menu);
                                                                }
                                                            }
                                                        }
                                                        override function onKeyDown from (e is KeyboardEvent) to ()
                                                        {
                                                            if (e.keyCode == Keys.Delete or
                                                                e.keyCode == Keys.Backspace) {
                                                                const toDelete = contextModel.selectedContext;
                                                                if (toDelete.parent is Context.GroupContext) {
                                                                    println("delete parent={toDelete.parent}");
                                                                    var par = toDelete.parent;
                                                                    while (par <> null) {
                                                                        if (par is Context.ResourceObjectContext) {
                                                                            const targ = (par as Context.ResourceObjectContext).getTarget();
                                                                            println("delete targ={targ}");
                                                                            for (p in targ.programs) {
                                                                                println("delete checking {p}");
                                                                                if (p.evalContext.varContext == toDelete) {
                                                                                    p.reset();
                                                                                    delete p from targ.programs;
                                                                                    p.parent.undefineVar(p.evalContext.varContext);
                                                                                    println("deleted VAR {p.evalContext.varContext.variableName}");
                                                                                    break;
                                                                                }
                                                                            }
                                                                            break;
                                                                        }
                                                                        par = par.parent;
                                                                    }
                                                                    if (par == null) par = toDelete.parent;
                                                                    const gp = (par as Context.GroupContext);
                                                                    gp.deleteContent(toDelete);
                                                                    println("deleted {toDelete} from {toDelete.parent}");
                                                                    toDelete.foldLeft((), function from (_ is (), c is Context) to () 
                                                                                      {
                                                                                          if (c is Context.ProgramContext) {
                                                                                              (c as Context.ProgramContext).program.reset();
                                                                                          }
                                                                                      });
                                                                }
                                                            } else super.onKeyDown(e);
                                                        }                                       
                                                    }
                                                }
                                            },

                                    Tabview.Tab {
                                        onSelect: function to ()
                                        { 
                                            tv.width;
                                            windowContainingAssets.gadget = assetSearch.searchField;
                                        }
                                        onLoseSelection: function to () 
                                        {
                                            windowContainingAssets.gadget = null;
                                        }
				     title: "Assets";
                                     var tv is Treeview = assetTreeview = Treeview  {
                                             model: assetModel;
                                             override function onKeyInput from (e is KeyboardEvent) to ()
                                             {
                                                 assetSearch.searchField.onKeyInput(e);
                                             }

					 var dragger is TransformNode;
                                         var tn is AssetTree.AssetTreenode;

					 override function onMouseDrag from (e is MouseEvent) to () {
					     if (dragger == null) {
						 dragger = TransformNode {
						     pickable: false;
						     content: Group {
							 transform: translate(-e.location.x, 0);
							 content: getDragCell();
						     }
						 }
						 insert dragger into popupLayer.content;
					     }
					     dragger.tx = editorScene.mousePosition.x;
					     dragger.ty = editorScene.mousePosition.y;
                                             tn = (selectedTreenode as AssetTreenode);
					 }

					 override function onMouseUp from (e is MouseEvent) to () 
					 {
                                             if (dragger == null) {
                                                 return;
                                             }
                                             for (q in getUnderMouseInEditor()) {
                                                 if (q.node == this) return ();
                                             }
                                             
					     var asset = tn.asset;
					     if (asset is AssetTree.MaAsset) {
						 const t = (asset as AssetTree.MaAsset).model.getTemporalRoot();
						 if (t.bounds.duration() > 0s) {
						     asset = AssetTree.ClipAsset {
							 override function getClip to TimeNode { t }
							 url: asset.url;
							 name: asset.name;
						     }
						 }
					     }
					     if (asset is AssetTree.ClipAsset) {
						 const clip = (asset as AssetTree.ClipAsset).getClip();
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
						     println("j={j.node}");
						     if (j.node is Trax) { 
                                                         const rtn = 
                                                             if (clip is ResourceTimeNode) 
                                                                 then clip as ResourceTimeNode 
                                                                 else ResourceTimeNodeWrapper {
                                                                         playCount: if clip is BlendLayer then -1 else 1; // hack...
                                                                         url: asset.url;
                                                                         wrapped: clip as TimeGroup;
                                                                     };
							 (j.node as Trax).onDrop(j, rtn, 
                                                                                 function from (t is TimeNode) to ()
                                                                                 {
                                                                                     const rtn = t as ResourceTimeNode;
                                                                                     addTimeResource(rtn);
                                                                                 });
							 break;
						     }
						 }
					     }
                                             if (asset is AssetTree.ResourceNodeAsset) {
						 const clip = (asset as AssetTree.ResourceNodeAsset).rn.temporal;
                                                 if (clip <> null) {
                                                     const picked = getUnderMouseInEditor();
                                                     for (j in picked) {
                                                         println("j={j.node}");
                                                         if (j.node is Trax) { 
                                                             const rtn = clip;
                                                             (j.node as Trax).onDrop(j, rtn, 
                                                                                     function from (t is TimeNode) to ()
                                                                                     {
                                                                                         const rtn = t as ResourceTimeNode;
                                                                                         addTimeResource(rtn);
                                                                                     });
                                                             break;
                                                         }
                                                     }
                                                 }
                                             }
                                             if (asset is AssetTree.TextFieldAsset) {
                                                 const picked = getUnderMouseInEditor();
                                                 if (picked == []) {
                                                     const f = (asset as AssetTree.TextFieldAsset).getTextField();
                                                     addResource(f, currentScene.mousePosition);
                                                     MasterUndoable.commit();
                                                 }
                                             }
                                             if (asset is AssetTree.TextOutputAsset) {
                                                 const picked = getUnderMouseInEditor();
                                                 if (picked == []) {
                                                     const f = (asset as AssetTree.TextOutputAsset).getTextOutput();
                                                     addResource(f, currentScene.mousePosition);
                                                     MasterUndoable.commit();
                                                 }
                                             }
                                             if (asset is AssetTree.MaAsset) {
                                                 const picked = getUnderMouseInEditor();
                                                 if (picked == []) {
                                                     const f = (asset as AssetTree.MaAsset);
                                                     doDrop(f.url, currentScene.mousePosition);
                                                     MasterUndoable.commit();
                                                 }
                                             }
                                             if (asset is AssetTree.ResourceNodeAsset) {
                                                 const picked = getUnderMouseInEditor();
                                                 if (picked == []) {
                                                     const f = (asset as AssetTree.ResourceNodeAsset);
                                                     doDrop(f.url, currentScene.mousePosition);
                                                     MasterUndoable.commit();
                                                 }
                                             }
                                             if (asset is AssetTree.GroupAsset) {
                                                 const picked = getUnderMouseInEditor();
                                                 if (picked == []) {
                                                     const f = (asset as AssetTree.GroupAsset).getGroup();
                                                     addResource(f, currentScene.mousePosition);
                                                     MasterUndoable.commit();
                                                 }
                                             }
                                             if (asset is AssetTree.SceneAsset) {
                                                 const picked = getUnderMouseInEditor();
                                                 if (picked == []) {
                                                     const scene = (asset as AssetTree.SceneAsset).getScene();
                                                     insert scene into currentScenes;
                                                     if (asset is AssetTree.Scene2DAsset) {
                                                         scene.dynamicsWorld = box2dDynamicsWorldFactory.createDynamicsWorld();

                                                     } else {
                                                         scene.dynamicsWorld = bulletDynamicsWorldFactory.createDynamicsWorld();
                                                     }
                                                     scene.dynamicsWorld.paused = player.paused;
                                                     transformHierarchy.selectScene(scene);
                                                     MasterUndoable.commit();
                                                 }
                                             }
                                             if (asset is AssetTree.TypeAsset) {
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
                                                     if (j.node == contextTree) {
                                                         contextModel.rootContext.updateParent();
                                                         const pt = j.node.toSceneTransform.inverse() * j.scenePoint;
                                                         var target = (contextTree.pick(pt.y) as Context.ContextTreenode).context;
                                                         var ctx = target;
                                                         var insertionPoint = 0;
                                                         if (not (ctx is Context.GroupContext)) {
                                                             ctx = ctx.parent;
                                                             insertionPoint = 0;
                                                             for (x in (ctx as Context.GroupContext).content) {
                                                                 if (x == target) {
                                                                     insertionPoint = indexof x;
                                                                     break;
                                                                 }
                                                             }
                                                         } 
                                                         if (ctx is Context.GroupContext) {
                                                             var g = ctx as Context.GroupContext;
                                                             insert (Context.ClosureVarContext { varType: asset as TypeAsset, parent: g })
                                                                 before g.content[insertionPoint];
                                                         }
                                                         println("TN ={tn.label} y={pt.y}");
                                                         break;
                                                     } 
                                                 }
                                             }
                                             if (asset is AssetTree.MemberAsset) {
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
                                                     if (j.node is Expression.Canvas) {
                                                         const ma = asset as AssetTree.MemberAsset;
                                                         (j.node as Expression.Canvas).onDrop(j, ma.member);
                                                         break;
                                                     } 
                                                 }
                                             } else if (asset is AssetTree.TypeAsset) {
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
                                                     if (j.node is Expression.Canvas) {
                                                         const ma = asset as AssetTree.TypeAsset;
                                                         (j.node as Expression.Canvas).onDrop(j, ma.t);
                                                         break;
                                                     } 
                                                 }
                                             }
					     delete dragger from popupLayer.content;
					     dragger = null;
					 }
				       }
				     content:
                                     Scrollpane { 
                                         canZoomVertical: false;
                                         content: bind tv
                                     }
                                    },
                                            Tabview.Tab {
                                                title: "Console";
                                                content:
                                                Scrollpane { 
                                                    canZoomVertical: false;
                                                    content: Console {}
                                                }
                                            },
                                            Tabview.Tab {
                                                title: "Cameras";
                                                content: Tabview {
                                                    var sn = Scene {
                                                        content: bind currentScene.root;
                                                    }
                                                    var st = StageNode {
                                                        superSample: 1
                                                        content: sn;
                                                    }
                                                tabs:
                                                    bind foreach (m in currentScene.currentModels) {
                                                        var cams = bind foreach (cam in getCamerasFromModel(m.model)) cam;
                                                        if (cams.size() == 0) then null else
                                                        Tabview.Tab {
                                                        title: m.id;

                                                        content: Tabview {
                                                            tabs:
                                                             bind foreach ( cam in cams) 
                                                                Tabview.Tab {
                                                                title: cam.id;
                                                                var g is Group = Group {};
                                                                onSelect: function to () {
                                                                    g.content = st;
                                                                    sn.camera = cam;
                                                                }
                                                                content: ResizableNode {
                                                                    override function resize from (w is Number, h is Number) to () 
                                                                    {
                                                                        st.resize(w as Integer, h as Integer);
                                                                    }
                                                                    override var internalContent = bind g;
                                                                }
                                                            }
                                                        }
                                                        }
                                                    }
                                                }
                                            },
                                            Tabview.Tab {
                                               title: "Inspector";
                                               content: bind selectedInspector;
                                            }]
                                        }
                                    },
                       },
                       InternalWindow {
                        id: "Editor1";            
			containerBounds: bind Bounds.boundsFromRect(0, 
                                                                    0, 
                                                                    width,
                                                                    height-MENU_HEIGHT)
		    	height: 400, width: 300;
			cx: 160, cy: 800-300;	   
			    content: ResizableStageNode {
			    
			      content: Tabview {
				tabs: 
				[
				 Tabview.Tab {
				     title: "Spatial";
                                     onSelect: inspectSpatial;
                                     content: Scrollpane {
                                         canZoomVertical: false;
                                         content:
                                         Treeview {
                                             model: TransformHierarchy.Model {
                                                 h: bind transformHierarchy;
                                             }
                                             override function onKeyDown from (e is KeyboardEvent) to ()
                                             {
                                                 if (e.keyCode == Keys.Delete or
                                                     e.keyCode == Keys.Backspace) {
                                                     if (currentTransform <> null) {
                                                         const toDelete = currentTransform;
                                                         transformHierarchy.deleteSelection();
                                                         deleteResource(toDelete);
                                                     } else {
                                                         if (transformHierarchy.selectedScene <> mainScene) {
                                                             delete transformHierarchy.selectedScene from
                                                                 currentScenes;
                                                         }
                                                     }
                                                 } else super.onKeyDown(e);
                                             }
                                             var dragger is TransformNode;
                                             var clip is Node;
                                             override function onMouseDrag from (e is MouseEvent) to () {
                                                 if (dragger == null) {
                                                     clip = (selectedTreenode as TransformHierarchy.Treenode).n;
                                                     dragger = TransformNode {
                                                         pickable: false;
                                                         content: Group {
                                                             transform: translate(-e.sceneLocation.x, 0);
                                                             content: getDragCell();
                                                         }
                                                     }
                                                     insert dragger into popupLayer.content;
                                                 }
                                                 dragger.tx = editorScene.mousePosition.x;
                                                 dragger.ty = editorScene.mousePosition.y;
                                             }
                                             
                                             override function onMouseUp from (e is MouseEvent) to () 
                                             {
                                                 if (clip <> null) {
                                                     for (j in getUnderMouseInEditor()) {
                                                         if (j.node is Expression.Canvas) {
                                                             (j.node as Expression.Canvas).onDrop(j, clip);
                                                             break;
                                                         }
                                                     }
                                                     for (j in getUnderMouseInEditor()) {
                                                         if (j.node == this) {
                                                             const pt = j.node.toSceneTransform.inverse() * j.scenePoint;
                                                             const tn = pick(pt.y) as TransformHierarchy.Treenode;
                                                             println("PICKED => {tn} for {e.location.y}");
                                                             if (tn <> null) {
                                                                 const n = tn.n;
                                                                 println("PICKED => {n}");
                                                                 if (clip <> n) {
                                                                     transformHierarchy.move(clip, n);
                                                                     selectNodeLater(clip);
                                                                 }
                                                             }
                                                             break;
                                                         }
                                                     }
                                                 }
                                                 delete dragger from popupLayer.content;
                                                 clip = null;
                                                 dragger = null;
                                             }
                                         }
				     }
				 },
				 Tabview.Tab {
				     title: "Temporal";
                                     onSelect: inspectTemporal;
				     content:
                                     Scrollpane {
                                         canZoomVertical: false;
                                         content:
                                         Treeview {
                                             model: TemporalHierarchy.Model {
                                                 h: bind temporalHierarchy
                                                     }
                                             override function onKeyDown from (e is KeyboardEvent) to ()
                                             {
                                                 if (e.keyCode == Keys.Delete or
                                                     e.keyCode == Keys.Backspace) {
                                                     const toDelete = temporalHierarchy.selectedTransform;
                                                     temporalHierarchy.deleteSelection();
                                                     deleteAnimResource(toDelete);
                                                 } else super.onKeyDown(e);
                                             }
                                             var dragger is TransformNode;
                                             var clip is TimeNode;
                                             override function onMouseDrag from (e is MouseEvent) to () {
                                                 if (dragger == null) {
                                                     clip = (selectedTreenode as TemporalHierarchy.Treenode).n;
                                                     dragger = TransformNode {
                                                         pickable: false;
                                                         content: Group {
                                                             transform: translate(-e.sceneLocation.x, 0);
                                                             content: getDragCell();
                                                         }
                                                     }
                                                     insert dragger into popupLayer.content;
                                                 }
                                                 dragger.tx = editorScene.mousePosition.x;
                                                 dragger.ty = editorScene.mousePosition.y;
                                             }
                                             
                                             override function onMouseUp from (e is MouseEvent) to () 
                                             {
                                                 for (j in getUnderMouseInEditor()) {
                                                     if (j.node is Expression.Canvas) {
                                                         (j.node as Expression.Canvas).onDrop(j, clip);
                                                         break;
                                                     }
                                                 }
                                                 delete dragger from popupLayer.content;
                                                 clip = null;
                                                 dragger = null;
                                             }
                                         }
                                     }
                                 },
                                 Tabview.Tab {
                                            onSelect: inspectEventual;
				            title: "Eventual";
                                            content: Scrollpane {
                                                 canZoomVertical: false;
                                                 content:
                                                 Treeview {
                                                     model: VariableHierarchy.Model {
                                                         h: bind otherHierarchy;
                                                     }
                                                     override function onKeyDown from (e is KeyboardEvent) to ()
                                                     {
                                                         if (e.keyCode == Keys.Delete or
                                                             e.keyCode == Keys.Backspace) {
                                                             const toDelete = otherHierarchy.selectedVariable;
                                                             otherHierarchy.deleteSelection();
                                                             //deleteAnimResource(toDelete);
                                                         } else super.onKeyDown(e);
                                                     }
                                                     var dragger is TransformNode;
                                                     var clip is Context;
                                                     override function onMouseDrag from (e is MouseEvent) to () {
                                                         if (dragger == null) {
                                                             clip = (selectedTreenode as VariableHierarchy.Treenode).n;
                                                             dragger = TransformNode {
                                                                 pickable: false;
                                                                 content: Group {
                                                                     transform: translate(-e.sceneLocation.x, 0);
                                                                     content: getDragCell();
                                                                 }
                                                             }
                                                             insert dragger into popupLayer.content;
                                                         }
                                                         dragger.tx = editorScene.mousePosition.x;
                                                         dragger.ty = editorScene.mousePosition.y;
                                                     }
                                                     
                                                     override function onMouseUp from (e is MouseEvent) to () 
                                                     {
                                                         for (j in getUnderMouseInEditor()) {
                                                             if (j.node is Expression.Canvas) {
                                                                 (j.node as Expression.Canvas).onDrop(j, clip);
                                                                 break;
                                                             }
                                                         }
                                                         delete dragger from popupLayer.content;
                                                         clip = null;
                                                         dragger = null;
                                                     }
                                                 }
                                             }
                                 },
Tabview.Tab {
				     title: "Keyable";
                                     onSelect: inspectKeyable;
                                     content:
                                           Scrollpane {
                                               canZoomVertical: false;
                                               content:
                                               Treeview {
                                                   model: TemporalHierarchy.Model {
                                                       h: bind temporalHierarchy2;
                                                   }
                                                   var dragger is TransformNode;
                                                   var clip is TimeNode;
                                                   override function onMouseDrag from (e is MouseEvent) to () {
                                                       if (dragger == null) {
                                                           clip = (selectedTreenode as TemporalHierarchy.Treenode).n;
                                                           dragger = TransformNode {
                                                               pickable: false;
                                                               content: Group {
                                                                   transform: translate(-e.sceneLocation.x, 0);
                                                                   content: getDragCell();
                                                               }
                                                           }
                                                           insert dragger into popupLayer.content;
                                                       }
                                                       dragger.tx = editorScene.mousePosition.x;
                                                       dragger.ty = editorScene.mousePosition.y;
                                                   }
                                                   
                                                   override function onMouseUp from (e is MouseEvent) to () 
                                                   {
                                                       for (j in getUnderMouseInEditor()) {
                                                           if (j.node is Expression.Canvas) {
                                                               (j.node as Expression.Canvas).onDrop(j, clip);
                                                               break;
                                                           }
                                                       }
                                                       delete dragger from popupLayer.content;
                                                       clip = null;
                                                       dragger = null;
                                                   }
                                               }
                                           }
                                 }];
                               }
                           }
                     },
		     InternalWindow {
                        id: "Editor2";            
                        gadget: bind trax.combinedGadget;
			containerBounds: bind Bounds.boundsFromRect(0, 
								    0, 
								    width,
								    height-MENU_HEIGHT)
		    	height: 305, width: 820;
			cx: 520, cy: 160;	   
			      //imageLoader: null;
			      content: ResizableStageNode {
                              debug: true
			    content: Tabview {
				tabs: 
				[Tabview.Tab {
				    title: "Timeline"
				    content: Scrollpane {
                                             canZoomVertical: false;
                                             content: trax = expr.timeline.Trax {
                                                 assetModel: bind assetModel;
                                                 menuFactory: the MenuFactory;
                                                 clips: bind currentAnimResource.resources;
                                                 loop: bind nonInteractiveLoop;
                                                 target: player;
                                                 targetNode: mainTimeLayer;
                                                 temporalHierarchy: temporalHierarchy;
                                                 removeClip: function from (clip is TimeNode) to ()
                                                 {
                                                     temporalHierarchy.deleteSelection();
                                                     deleteAnimResource(clip);
                                                 }
                                             }
                                         }
				 },
                                            Tabview.Tab {
                                                title: "Graph Editor"
                                                    content: Scrollpane {
                                                    canZoomVertical: false;
                                                    content: graphEditor = expr.timeline.GraphEditor {
                                                        menuFactory: the MenuFactory;
                                                        mainTrax: bind trax;
                                                        assetModel: bind assetModel;
                                                        eventTarget: bind contextModel.selectedMemberContext;
                                                        variableTargets: bind [contextModel.selectedVarContext];
                                                        resourceTargets: bind currentResource.resources;
                                                        loop: bind nonInteractiveLoop;
                                                        target: player;
                                                        targetNode: mainTimeLayer;
                                                        temporalHierarchy: temporalHierarchy2;
                                                        removeClip: function from (clip is TimeNode) to ()
                                                        {
                                                            if (clip is ResourceTarget.ChannelBoxGroup) {
                                                                const cb = 
                                                                    clip as ResourceTarget.ChannelBoxGroup;
                                                                const p = (cb.parent as ResourceTarget.ChannelBoxesGroup);
                                                                delete cb from p.content;
                                                            } else {
                                                                delete clip from (clip.parent as TimeGroup).content;
                                                            }
                                                            MasterUndoable.commit();
                                                        }
                                                    }
                                                }
                                            },
				 Tabview.Tab {
				    title: bind if (contextModel.selectedVarContext <> null) then "Variable: {contextModel.selectedVarContext.name}" else "Event: {contextModel.selectedMemberContext.name}"
				    content: expr.prog.Expression.Editor {
                                                 assetModel: bind assetModel;
                                                 go: function from (c is Context) to ()
                                                 {
                                                     const tn = contextModel.toTreeNode(c);
                                                     contextTree.select(tn);
                                                     contextModel.selectionObserver.onNext(tn);
                                                 }
                                                 menuFactory: THE_MENU_FACTORY;
                                                 //event: bind inspector1.inspecting[inspector1.selectedIndex].member;
                                                 stepping: bind stepping;
                                                 varContext: bind contextModel.selectedVarContext;
                                                 eventContext: bind contextModel.selectedMemberContext;
                                                 targetObject: bind contextModel.selectedObjectContext.getTarget();
                                                 targetSpace: bind currentScene.root;
                                                 instanceSpace: bind currentScene.instanceSpace;
                                                 targetTime: bind mainTimeLayer;
                                                 targetTimeline: bind player;
                                                 popupLayer: bind popupLayer;
                                                 popupScene: bind editorScene;
                                                 interactive: function from () to Boolean { interactive } 
                                             }
				 }]
			    }
                        }
		    }]
                   },
	    toolMenu, 
            sceneMenu,
            popupLayer]
        };

     function saveChangesIfNecessary to Boolean 
     {
         if (fileDirty()) {
             var doSave = true;
             if (mainScene.currentResource.url == "") {
                 yesNo.title = "Tool";
                 yesNo.message = "Save Changes?";
                 var cancel is Boolean = false;
                 yesNo.onCancel = function to () { cancel = true }
                 yesNo.onNo = function to () { doSave = false } 
                 yesNo.onYes = function to () { }
                 yesNo.open();
                 if (cancel) return false;
             }
             if (doSave) {
                 if (not save()) {
                     return false;
                 }
             }
         }
         return true;
     }
    
     function joglStage to JoglStage {
         stage
     }
     
     var stage is JoglStage = JoglStage {

        defaultCursor: bind toolCursor;
        /*
        content: CachedScene {
             scene: bind [currentScenes, manipLayer, editorScene];
        }
        */
        content: bind [currentScenes, manipLayer, editorScene];
	
        onClose: function from () to Boolean 
        {
            if (not saveChangesIfNecessary()) {
                return false;
            }
            saveEditorState(editorScene, player, trax, recentList);
            return true;
        }
        title: bind "{mainScene.currentResource.url} {if (savePoint <> MasterUndoable.now) then " (Unsaved)" else ""}";
        menubar: Menu.Bar 
        {
	    menus: 
	    [Menu 
             { 
		 label: "File";
		 shortcut: Menu.Shortcut { keyCode: Keys.F }
		 items:
		 [MenuItem 
                  {
                      shortcut: Menu.Shortcut { keyCode: Keys.O }
                      label: "Open...";
                      enabled: bind player.paused;
                      action: function {
                          if (saveChangesIfNecessary()) {
                              const result = fileOpen.open();
                              if (result <> null) {
                                  open("file:{result}");
                              }
                          }
                      }
                  },
                  Menu 
                  {
                      label: "Open Recent";
                      enabled: bind player.paused;
                      items: bind foreach (x in recentList) {
                          MenuItem {
                              label: x;
                              action: function to () {
                                  open(x);
                              }
                          }
                      }
                  },
                  MenuItem 
                  {
                      shortcut: Menu.Shortcut { keyCode: Keys.S }
                      label: "Save As...";
                      enabled: true;//bind mainScene.currentResource.url == ""
                      action: function {
                          if (mainScene.currentResource.url <> "") {
                              const u = new java.net.URL(mainScene.currentResource.url);
                              fileSave.fileName = new java.io.File(u.getFile()).getName();
                          } else {
                              fileSave.fileName = "";
                          }
                          fileSave.title = "Save As";
                          var result = fileSave.open();
                          if (result <> null) {
                              if (not result.endsWith(".expr")) {
                                  result = "{result}.expr";
                              }
                              mainScene.currentResource.url = "file:{result}";
                              save();
                          }
                      }
                  },
                  MenuItem 
                  {
                      shortcut: Menu.Shortcut { keyCode: Keys.W }
                      label: "Close";
                      enabled: bind player.paused;
                      action: function {
                          if (saveChangesIfNecessary()) {
                              close();
                          }
                      }
                  },
                  MenuItem {
                      label: "Export...";
                      enabled: bind player.paused and mainScene.currentResource.url <> "";
                      action: doExport;
                  }];
             },
	     Menu 
             { 
		 shortcut: Menu.Shortcut { keyCode: Keys.E }
		 label: "Edit"
		 items:
		 [MenuItem 
                  {
                      shortcut: Menu.Shortcut { keyCode: Keys.X, metaKey: yes }
                      label: "Cut";
                  },
                  MenuItem 
                  {
                      shortcut: Menu.Shortcut { keyCode: Keys.C, metaKey: yes }
                      label: "Copy";
                  },
                  MenuItem 
                  {
                      shortcut: Menu.Shortcut { keyCode: Keys.V, metaKey: yes }
                      label: "Paste";
                  }
                  Menu.Separator {},
                  MenuItem 
                  {
                      label: "Undo";
                      enabled: bind canUndo;
                      shortcut: Menu.Shortcut { keyCode: Keys.Z }
                      action: MasterUndoable.undo;
                  },
                  MenuItem 
                  {
                      label: "Redo";
                      enabled: bind canRedo;
                      shortcut: Menu.Shortcut { keyCode: Keys.Z, shiftKey: yes }
                      action: MasterUndoable.redo;
                  }];
             },
	     Menu 
             { 
		 label: "Animate"
		 items:
		 [MenuItem 
                  {
                      label: "Set Key";
                      action: function {
                          graphEditor.setKeys();
                      }
                  }];
             }]
	     
	}

	height: 800, width: 1020;
	
    }

    function setCamera from (i is Integer) to ()
    {
	/*
	if (i == 0) {
	    currentCamera = camera;
	} else if (i == 9) {
	    currentCamera = Camera2D {};
	} else {
	    const cam = model.getCameras()[i-1];
	    if (cam <> null) {
		currentCamera = cam;
	    }
	}
	println("camera={camera.tx}, {camera.ty}, {camera.tz}");
	*/
    }

    function deleteAnimResource from (n is TimeNode) to () 
    {
        var x = n;
        n.updateParent();
        while (x <> null) {
            println("DELETE {x.getClass()} => {x}");
            if (x is ResourceTimeNode) {
                const rn = x as ResourceTimeNode;
                rn.foldLeft((), function from (_ is (), n is TimeNode) to () {
                        n.pause();
                    });
                if (x.parent is ResourceTimeGroup) {
                    delete (x as ResourceTimeNode) from (x.parent as ResourceTimeGroup).resources;
                } else {
                    delete x from (x.parent as TimeGroup).content;
                }
                return;
            }
            x = x.parent;
        }
    }

    function deleteResource from (n is Node) to () {
	if (n is ResourceNode) {
	    const rn = n as ResourceNode;
            if (rn.parent is GroupResourceNode) {
                (rn.parent as GroupResourceNode).deleteContent(rn);
            } else {
                delete n as ResourceNode from currentResource.resources;
                if (rn.temporal <> null) {
                    delete rn.temporal from currentAnimResource.resources;
                    //trax.setClips(currentAnimResource.resources);
                }
                MasterUndoable.commit();        
            }
            var toDelete is Context[];
            mainContext.foldLeft((), 
                                 function from (_ is (), c is Context) to () 
                                 {
                                     if (c is Context.ResourceNodeContext) {
                                         const rnc = c as Context.ResourceNodeContext;
                                         if (rnc.resource == rn) {
                                             insert c into toDelete;
                                         }
                                     } else if (c is Context.ResourceTimeNodeContext) {
                                         const rtnc = c as Context.ResourceTimeNodeContext;
                                         if (rtnc.resource == rn.temporal) {
                                             insert c into toDelete;
                                         }
                                     }
                                 });
            for (x in toDelete) {
                (x.parent as Context.GroupContext).deleteContent(x);
            }
	}
    }

    function setClip from (i is Integer) to ()
    {
	//currentResource.setClip(i);
    }

    stage.addMouseInputHandler(MouseInputHandler.Delegate { 
            delegate: viewer;
            override function onMouseWheel from (event is MouseWheelEvent) to ()
            {
                if (editorScene.underMouse <> []) { return }
                for (scene in currentScenes) {
                    if (scene.underMouse <> []) {
                        return;
                    }
                }
                delegate.onMouseWheel(event);
            }
        });
    stage.addKeyboardInputHandler(KeyboardInputHandler {

	    override function onKeyInput from (event is KeyboardEvent) to () 
	    {
		if (event.keyChar == "-" or event.keyChar == "_") {
		    manip.shrink();
		} else if (event.keyChar == "+" or event.keyChar == "=") {
		    manip.expand();
		}
	    }
		
	    override function onKeyUp from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    if (event.keyCode == Keys.D) {
			manip.exitPivotMode();
		    }
		}
	    }

	    override function onKeyDown from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    println("event={event}");
		    if (event.keyCode == Keys.Delete or event.keyCode == Keys.Backspace) {
			//const toDelete = currentTransform;
			//transformHierarchy.deleteSelection();
			//deleteResource(toDelete);
		    } else if (event.keyCode == Keys.D) {
			manip.enterPivotMode();
			/* } else if (event.keyCode == Keys.Z and event.metaKey) {
			if (event.shiftKey) {
			    MasterUndoable.redo();
			} else {
			    MasterUndoable.undo();
			    }*/
		    } else if (event.keyCode == Keys._3 and event.ctrlKey) {
                        currentScene.dynamicsWorld.debug = not currentScene.dynamicsWorld.debug;
		    } else if (event.keyCode == Keys.G) {
                        java.lang.System.gc();
                        println("{java.lang.Runtime.getRuntime().freeMemory()} / {java.lang.Runtime.getRuntime().totalMemory()}");
		    } else if (event.keyCode == Keys.S) {
                        graphEditor.setKeys();
		    } else if (event.keyCode == Keys.F) {
                        if (currentScene == mainScene) {
                            if (currentTransform <> null) {
                                viewer.focusCamera(currentTransform);
                            } else {
                                viewer.focusCamera(mainScene.root);
                            }
                        }
		    } else if (event.keyCode >= Keys._0 and event.keyCode <= Keys._9) {
			const index = event.keyCode - Keys._0;
			if (event.metaKey) {
			    setClip(index);
			} else {
			    setCamera(index);
			}
		    } else if (event.keyCode == Keys.G) {
			java.lang.System.gc();
			//showMemory = not showMemory;
		    }
		}
	    }
	});

    stage.addDnDInputHandler(DnDInputHandler {
	    override function onDrop from (event is DropEvent) to () 
	    {
		const url = event.url;
		event.accept();
		try {
		    const checkProtocol = new java.net.URL(url);
                    const pt = currentScene.camera.toScene(event.screenx, event.screeny);
                    println("DROP on SCENE {event.screenx}, {event.screeny} => {pt} ");
		    doDrop(url, pt);
		} catch (exception is java.lang.Exception) {
		    exception.printStackTrace();
		}
	    }
	});
    doUpdate = DefaultObserver of (()) {
        override function onNext from (_ is ()) to () {
            (the SoundLoader).update();
            canUndo = MasterUndoable.canUndo();
            canRedo = MasterUndoable.canRedo();
            for (z in currentScenes) {
                z.instanceSpace.content = z.instanceSpace.content[ x | { var y = x as EventLayer.EventNode; y.timestamp <= player.playhead }];
            }
        }
    };
    Inspector.allFontFamilies = (the Text.LayoutEngine).allFontFamilies;
    currentScenes = [mainScene];
    undoList.addTarget("currentScenes", &currentScenes);
    transformHierarchy.selectedScene = mainScene;
    println("SET MAIN SCENE {transformHierarchy.selectedScene}");
    stage.observeUpdate().subscribe(doUpdate);
    MasterUndoable.commit();
}




