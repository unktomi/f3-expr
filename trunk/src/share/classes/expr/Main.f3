package expr;
import f3.jogl.awt.JoglStage;
import f3.jogl.awt.JoglStage.*;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.util.Bits;
import f3.util.*;
import f3.util.Observer.*;
import f3.media.scene.*;
import f3.media.input.*;
import f3.media.svg.SVG;
import java.lang.Math;
import expr.choices.SliderField;
import expr.undo.*;
import expr.inspector.*;
import expr.inspector.Inspector.*;
import expr.ResourceNode.*;
import expr.AssetTree.*;
import expr.timeline.*;
import expr.prog.*;

public class InternalWindowState {
    public var id is String;
    public var cx is Number;
    public var cy is Number;
    public var width is Number;
    public var height is Number;
}

public class EditorState {
    public var windowWidth is Integer;
    public var windowHeight is Integer;
    public var internalWindows: InternalWindowState[];
}

function saveEditorState from (scene is Scene) to () 
{
    var internalWindows is InternalWindowState[];
    const f is function from ((), Node) to () 
        = function from (_ is (), n is Node) to ()
        {
            if (n is InternalWindow) {
                const w = n as InternalWindow;
                insert InternalWindowState {
                    id: w.id;
                    cx: w.cx;
                    cy: w.cy;
                    width: w.width;
                    height: w.height;
                } into internalWindows;
            }
        };
    scene.root.foldLeft((), f);
    const w = new java.io.BufferedWriter(new java.io.FileWriter(".expr.editorstate"));
    IO.writeObject(w, EditorState {
            windowHeight: scene.stage.height+21;
            windowWidth: scene.stage.width;
            internalWindows: internalWindows;
        });
    w.flush();
    w.close();
}

function loadEditorState from (scene is Scene) to () 
{
    const file = new java.io.File(".expr.editorstate");
    if (file.exists()) {
        const s = IO.readObject(new java.io.BufferedReader(new java.io.FileReader(file))) as EditorState;
        const f is function from ((), Node) to () 
            = function from (_ is (), n is Node) to ()
        {
            if (n is InternalWindow) {
                const w = n as InternalWindow;
                for (x in s.internalWindows) {
                    if (x.id == w.id) {
                        w.cx = x.cx;
                        w.cy = x.cy;
                        w.width = x.width;
                        w.height = x.height;
                        break;
                    }
                }
            }
        };
        scene.root.foldLeft((), f);
        if (s.windowHeight <> 0 and s.windowWidth <> 0) {
            (scene.stage as JoglStage).resizeWindow(s.windowWidth, s.windowHeight);
        }
    }
}

class CachedScene is Scene {
    public var scene is Scene;
    override var camera = Camera2D {tx: bind -scene.width/2, ty: bind -scene.height/2}
    var stageNode is StageNode = StageNode {
	content: scene;
    }
    override function update {
	if (stageNode.width <> width or stageNode.height <> height) {
	    stageNode.resize(width, height);
	}
	super.update();
    }
    override var content = bind stageNode;
}

class ResizableStageNode is ResizableNode, Focuser {
    const stage is StageNode = StageNode {
        background: Color.GRAY;
	content: Scene {
            background: Color.color(.3, .3, .3);
	    camera: Camera2D { tx: bind Math.round(-width / 2.0), ty: bind Math.round(-height / 2.0) }
	    content: bind content;
	}
    }
    override function resize from (w0 is Number, h0 is Number) to ()
    {
	const w = Math.ceil(w0);
	const h = Math.ceil(h0);
	super.resize(w, h);
	content.resize(w, h);
	stage.resize(w as Integer, h as Integer);
    }
    override var internalContent = Group { content: bind stage };
    public var content is ResizableNode;
    override public function getTargetOfFocus to Focusable {
	return stage;
    }
}

function readTextFile from (url is String) to (String, Integer)
{
    const u = new java.net.URL(url);
    const reader = new java.io.BufferedReader(new java.io.InputStreamReader(u.openStream()));
    var line is Object;
    var buf = new java.lang.StringBuffer;
    var lineCount = 0;
    while ((line = reader.readLine()) <> null) {
	buf.append(line);
	buf.append("\n");
	lineCount++;
    }
    return (buf.toString(), lineCount);

}

public class MainContext is Context.MemberContext {
    override var member = Expression.Member {
        name: "Start";
        t: Reflect.UNIT_TYPE;
        rt: Reflect.UNIT_TYPE;
        isObservable: true;
    }
}

var canUndo is Boolean;
var canRedo is Boolean;
var currentScenes is ResourceScene[] = [];
var doUpdate is Observer of (());


public function run from (args is String[]) to ()
{
    var mainContext is Context = MainContext {
        name: "Start";
    }

    var contextTree is Treeview;

    var contextModel is Context.ContextTreemodel = Context.ContextTreemodel {
        rootContext: bind mainContext;
    } 

    var lastContext is Context;

    function handleContextVisibility from (ctx is Context, v is Boolean) to ()
    {
        var c = ctx;
        while (c <> null) {
            //println("c={c.name} parent={c.parent.name} v={v}");
            for (c1 in [c, c.getContent()]) {
                if (c1 is Context.ResourceNodeContext) {
                    const rc = c1 as Context.ResourceNodeContext;
                    println("visible = {v} => {rc.resource}");
                    rc.resource.visible = v;
                }
            }
            c = c.parent;
        }
    }

    var selectionHandler = contextModel.selectionObserver.subscribe(function from (tn is Treeview.Treenode) to () {
            mainContext.updateParent();
            const ctx = (tn as Context.ContextTreenode).context;
            handleContextVisibility(lastContext, false);
            lastContext = ctx;
            handleContextVisibility(ctx, true);
        });

    var currentScene is ResourceScene = bind transformHierarchy.selectedScene;

    var currentResource is ResourceGroup = bind currentScene.currentResource;

    const currentAnimResource is ResourceTimeGroup = ResourceTimeGroup {
	id: "Temporal Hierarchy";
    }

    const transformHierarchy is TransformHierarchy = TransformHierarchy {
	scenes: bind currentScenes;
    }

    const temporalHierarchy = TemporalHierarchy { root: bind currentAnimResource }
    const otherHierarchy = VariableHierarchy { root: bind mainContext }
    var currentCamera is Camera;
    var TheMovieLoader is MovieLoader;
    try {
	const clazz = 
	    java.lang.Class.forName("org.f3.media.video.macos.MovieLoaderImpl") as java.lang.Class of MovieLoader;
	TheMovieLoader = clazz.newInstance();
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't create corevideo movie loader");
    }
    
    var TheWebBrowserFactory is AbstractWebBrowserFactory;
    try {
	const clazz = 
	    java.lang.Class.forName("f3.media.web.awesomium.AwesomiumWebBrowserFactory") as java.lang.Class of AbstractWebBrowserFactory;
	TheWebBrowserFactory = clazz.newInstance();
	    
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load awesomium web browser factory");
    }

    println("args={args}");

    var playerUrl is String;

    const mainTimeLayer = TimeGroup {
	id: "Hierarchy";
	content: bind currentAnimResource;
	playRange: bind if (loop) then null else Interval { start: 0s, end: Duration.INDEFINITE };
	playCount:  bind if (loop) then -1 else 1;
    }

    const player = Timeline {
	paused: true;
	content: mainTimeLayer;
    }

    const camera = PerspectiveCamera {
        id: "free";
	ty: 3.0;
	tz: 13;
	near: 1;
	far: 1000;
        content: PointLight {}
    }

    const viewer = DefaultExaminerViewer {
	camera: camera;
    }

    const browser = if TheWebBrowserFactory == null then null else WebBrowser {
	//factory: TheWebBrowserFactory;
	//effectLoader: CGEffectLoader_INSTANCE;
	//pathFactory: ThePath2DFactory;
    }

    
    function addResource from (rn is ResourceNode, pt is Point3) to ()
    {
        println("ADDING {rn} to {currentResource} th.scenes={transformHierarchy.scenes}, th.selectedScene={transformHierarchy.selectedScene}");
	insert rn into currentResource.resources;
	transformHierarchy.selectNode(rn);
        if (currentScene == mainScene) {
            viewer.focusCamera(rn);
        }
        insert Context.ResourceNodeContext { 
            parent: contextModel.selectedGroupContext; 
            resource: rn;
        } 
        into contextModel.selectedGroupContext.content;
        println("added asset to context { contextModel.selectedContext }");
        if (currentScene.camera is Camera2D) {
            rn.tx = pt.x;
            rn.ty = pt.y;
        }
    }

    function addTimeResource from (rn is ResourceTimeNode) to ()
    {
        rn.updateParent();
	insert rn into currentAnimResource.resources;
        insert Context.ResourceTimeNodeContext { 
            parent: contextModel.selectedGroupContext; 
            resource: rn;
        } 
        into contextModel.selectedGroupContext.content;
    }

    function doDrop from (url is String, pt is Point3) to () 
    {
	playerUrl = url;
	if (url.endsWith(".expr")) {
	    const model = ExprNode {
                webBrowserFactory: TheWebBrowserFactory
		url: url;
	    }
	    const rn = ResourceNode {
                url: url;
                content: bind model.spatialRoot;
	    }
	    addResource(rn, pt);
	    const rtn = ResourceTimeNode {
		url: url;
		content: bind model.temporalRoot;
		spatial: rn;
	    }
	    if (rtn.bounds.duration() > 0s) {
		rn.temporal = rtn;
		addTimeResource(rtn);
	    }
	} else if (url.endsWith(".mp4")) {
            const movie = Movie {
                url: url;
            }
	    const rn = ResourceNode {
                url: url;
	        content: movie;
	    }
	    addResource(rn, pt);
	    const rtn = ResourceTimeNode {
		url: url;
		content: Movie.Clip { movie: movie };
		spatial: rn;
	    }
            addTimeResource(rtn);
	} else if (url.endsWith(".ma")) {
	    const model = Ma.Model {
		url: url;
	    }
	    const rn = MaResourceNode {
	        model: model;
	    }
	    addResource(rn, pt);
	    const rtn = ResourceTimeNode {
		url: url;
		content: bind model.getTemporalRoot();
		spatial: rn;
	    }
	    if (rtn.bounds.duration() > 0s) {
		rn.temporal = rtn;
		addTimeResource(rtn);
	    }
	} else if (url.endsWith(".svg")) {
	    const svg = SVG {
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind svg.root;
	    }	
	    addResource(rn, pt);
	} else if (url.endsWith(".png") or url.endsWith(".jpg") or url.endsWith(".tif") or url.endsWith(".tiff") or url.endsWith(".tga")) {
	    const image= Image { 
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: image;
	    }	
	    addResource(rn, pt);
	} else {
	    const browser = WebBrowser {
		url: url
	    }
	    const rn = ResourceNode {
		url: url;
		content: browser;
	    }
	    addResource(rn, pt);
	}
	MasterUndoable.commit();
    }

    var trax is expr.timeline.Trax;
    var inspector1 is Inspector;
    var inspector2 is Inspector;
    var inspector3 is Inspector;
    var currentTransform = bind transformHierarchy.selectedTransform;
    currentCamera = camera;

    var savePoint is Integer;

    var editorScene is Scene;
    var internalWindowsLayer is Group;
    var popupLayer = Group {};

    function getUnderMouseInEditor to Pick[] 
    {
	var result is Pick[];
	foreach (x in editorScene.underMouse) {
	    insert x into result;
	    if (x.node is StageNode) {
		for (y in (x.node as StageNode).content) {
		    insert y.underMouse into result;
		}
	    }
	}
	return result;
    }

    const mainScene = ResourceScene {
        id: "Main Scene";
	background: Color.GRAY;
        camera: camera;
    }

/*
    const cachedScene = CachedScene {
        background: null;
	scene: mainScene;
    }
*/
    bound function getCamerasFromModel from (m is Ma.Model) to Camera[] {
        foreach (c in m.getCameras()) {
            if (c.id == "topShape" or c.id == "perspShape" or c.id == "frontShape" or c.id == "sideShape") then null else c;
        }
    }


    var loop is Boolean = true;
    var full is Boolean = false;

    var interactive is Boolean;

    const toolMenu is expr.toolmenu.ToolMenu = expr.toolmenu.ToolMenu {
    	transform: bind translate(stage.width /2, stage.height - 10);
	height: 20;
	width: bind stage.width;
	pause: &player.paused;
	onRewind: player.setPlayhead.apply(0s);
	onHideFloating: function from (b is Boolean) to ()
	{
	    internalWindowsLayer.visible = b;
	}
	toggleLoop: function { loop = not loop; () }
	toggleFullscreen: function { full = not full; stage.setFullscreen(full) }
        onSetSelecting: function from () to () {
            interactive = false;
        }
        onSetScripting: function from () to () {
            interactive = true;
        }
    };

    readonly var toolCursor is Cursor = bind if (interactive) then toolMenu.scriptingCursor else toolMenu.selectingCursor;

    const sceneMenu = Tabview {
          height: 20; width: bind stage.width;
          transform: bind translate(stage.width/2, stage.height-30);
          tabs: bind foreach (scene in transformHierarchy.scenes) Tabview.Tab {
                title: bind scene.id;
                onSelect: function from () to () 
                {
                    transformHierarchy.selectScene(scene);                        
                }
          }
    }
    
    const MENU_HEIGHT = 40;

    const disp = transformHierarchy.observeSceneSelection().subscribe(function from (n is ResourceScene) to () {        
            sceneMenu.selectedIndex = Sequences.indexOf(transformHierarchy.scenes, n);
	});
    
    var manip is expr.manipulator.Manipulator;

    function save {
	savePoint = MasterUndoable.now;
	Resources.save(currentResource.url,
		       mainScene,
		       currentResource,
		       currentAnimResource);
    }
    
    function close from () to () {
	savePoint = 0;
	currentResource.resources = [];
	currentAnimResource.resources = [];
	transformHierarchy.clearSelection();
	MasterUndoable.reset();
    }

    const undoList = expr.undo.UndoList {} on replace {
	undoList.addTarget("nodes", &currentResource.resources);
	undoList.addTarget("timenodes", &currentAnimResource.resources);
    }


    function open from (url is String) to ()
    {
	close();
	currentResource.url = url;
	const sceneRes = Resources.open(currentResource.url);
	for (i in sceneRes.spatialResources) {
	    doDrop(i.url, new Point3(i.tx, i.ty, i.tz));
	    currentTransform.tx = i.tx;
	    currentTransform.ty = i.ty;
	    currentTransform.tz = i.tz;

	    currentTransform.sx = i.sx;
	    currentTransform.sy = i.sy;
	    currentTransform.sz = i.sz;

	    currentTransform.rx = i.rx;
	    currentTransform.ry = i.ry;
	    currentTransform.rz = i.rz;

	    currentTransform.px = i.px;
	    currentTransform.py = i.py;
	    currentTransform.pz = i.pz;
	}
	for (i in sceneRes.temporalResources, j in currentAnimResource.resources) {
	    if (i.url == j.url) {
		j.playTime = i.playTime;
		j.playRate = i.playRate;
		j.playCount = i.playCount;
	    }
	}
	//trax.setClips(currentAnimResource.resources);
	MasterUndoable.reset();
	MasterUndoable.commit();
	savePoint = MasterUndoable.now;
    }

    const fileSave = FileDialog.FileSave {
    }

    const fileOpen = FileDialog.FileOpen {
	filterExtensions: [".expr"]
    }

    function fileDirty to Boolean {
	MasterUndoable.canUndo();
    }

    var manipLayer = Scene {
                //visible: bind internalWindowsLayer.visible;
                      background: null;
                      camera: bind currentScene.camera;
		      override var content = [manip = expr.manipulator.Manipulator 
		      {
			  visible: bind currentTransform <> null;
                          viewer: viewer;
			  target: bind currentTransform;
			  scene: this;
		      }, 
                      Group {
                          var viewScale = bind uniformScale(manip.viewScale*.5);
                          content: bind foreach  (cam in currentScene.currentCameras) {
                              var cameraModel = Ma.Model {
                                  url: "{__DIR__}camera.ma";
                              }
                              Group {
                                  transform: bind cam.toSceneTransform;
                                  content: Group {
                                      transform: bind viewScale;
                                      content: bind cameraModel.getSpatialRoot();
                                  }
                              }
                          }
                      }]
        };
        
        var _ = editorScene = Scene {
                    var lastTime is Long;
                    override function update {
                        const now = java.lang.System.currentTimeMillis();
                        if (lastTime == 0) {
                            loadEditorState(this);
                            lastTime = now;
                        } else if (now - lastTime > 2000) {
                            saveEditorState(this);
                            lastTime = now;
                        }
                        super.update();
                    }
                    background: null;
                    camera: Camera2D {}; 
		    override var content =
		    [internalWindowsLayer = Group { 

                       content: 
                       [InternalWindow {
                                    id: "Editor3";
			containerBounds: bind Bounds.boundsFromRect(0, 
                                                                    0, 
                                                                    width,
                                                                    height-MENU_HEIGHT)
		    	height: 400, width: 300;
                                    content: ResizableStageNode {
                                        content: Tabview {
                                            tabs: 
                                            [Tabview.Tab {
                                                title: "Events";
                                                content: Scrollpane {
                                                    canZoomVertical: false;
                                                    content: contextTree = Treeview {
                                                        model: bind contextModel;
                                                        override function onKeyDown from (e is KeyboardEvent) to ()
                                                        {
                                                            if (e.keyCode == Keys.Delete or
                                                                e.keyCode == Keys.Backspace) {
                                                                const toDelete = contextModel.selectedContext;
                                                                delete toDelete from contextModel.selectedGroupContext.content;
                                                            } else super.onKeyDown(e);
                                                        }                                       
                                                    }
                                                }
                                            },
                                            Tabview.Tab {
                                                title: "Cameras";
                                                content: Tabview {
                                                    var sn = Scene {
                                                        content: bind currentScene.root;
                                                    }
                                                    var st = StageNode {
                                                        content: sn;
                                                    }
                                                tabs:
                                                    bind foreach (m in currentScene.currentModels) {
                                                        var cams = bind foreach (cam in getCamerasFromModel(m.model)) cam;
                                                        if (cams.size() == 0) then null else
                                                        Tabview.Tab {
                                                        title: m.id;

                                                        content: Tabview {
                                                            tabs:
                                                             bind foreach ( cam in cams) 
                                                                Tabview.Tab {
                                                                title: cam.id;
                                                                var g is Group = Group {};
                                                                onSelect: function to () {
                                                                    g.content = st;
                                                                    sn.camera = cam;
                                                                }
                                                                content: ResizableNode {
                                                                    override function resize from (w is Number, h is Number) to () 
                                                                    {
                                                                        st.resize(w as Integer, h as Integer);
                                                                    }
                                                                    override var internalContent = bind g;
                                                                }
                                                            }
                                                        }
                                                        }
                                                    }
                                                }
                                            }]
                                        }
                                    }
                       },
                       InternalWindow {
                        id: "Editor1";            
			containerBounds: bind Bounds.boundsFromRect(0, 
                                                                    0, 
                                                                    width,
                                                                    height-MENU_HEIGHT)
		    	height: 400, width: 300;
			cx: 160, cy: 800-300;	   
			    content: ResizableStageNode {
			    
			      content: Tabview {
				tabs: 
				[Tabview.Tab {
				     title: "Assets";
				     content:
                                     Scrollpane { 
                                         canZoomVertical: false;
                                         content: Treeview {
					 model: AssetTree.AssetModel {
					     resources: bind currentResource;
					 }

					 var dragger is TransformNode;
                                         var tn is AssetTree.AssetTreenode;

					 override function onMouseDrag from (e is MouseEvent) to () {
					     if (dragger == null) {
						 dragger = TransformNode {
						     pickable: false;
						     content: Group {
							 transform: translate(-e.location.x, 0);
							 content: getDragCell();
						     }
						 }
						 insert dragger into popupLayer.content;
					     }
					     dragger.tx = editorScene.mousePosition.x;
					     dragger.ty = editorScene.mousePosition.y;
                                             tn = (selectedTreenode as AssetTreenode);
					 }

					 override function onMouseUp from (e is MouseEvent) to () 
					 {
					     var asset = tn.asset;
					     if (asset is AssetTree.MaAsset) {
						 const t = (asset as AssetTree.MaAsset).model.getTemporalRoot();
						 if (t.bounds.duration() > 0s) {
						     asset = AssetTree.ClipAsset {
							 override function getClip to TimeNode { t }
							 url: asset.url;
							 name: asset.name;
						     }
						 }
					     }
					     if (asset is AssetTree.ClipAsset) {
						 const clip = (asset as AssetTree.ClipAsset).getClip();
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
						     println("j={j.node}");
						     if (j.node is Trax) { 
							 (j.node as Trax).onDrop(j, clip, 
                                                                                 function from (t is TimeNode) to ()
                                                                                 {
                                                                                     const rtn = 
                                                                                         if (t is ResourceTimeNode) 
                                                                                             then t as ResourceTimeNode 
                                                                                             else ResourceTimeNode {
                                                                                                     url: asset.url;
                                                                                                     content: t;
                                                                                                 };
                                                                                     addTimeResource(rtn);
                                                                                 });
							 break;
						     }
						 }
					     }
                                             if (asset is AssetTree.SceneAsset) {
                                                 const picked = getUnderMouseInEditor();
                                                 if (picked == []) {
                                                     insert (asset as AssetTree.SceneAsset).getScene() into currentScenes;
                                                 }
                                             }
                                             if (asset is AssetTree.TypeAsset) {
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
                                                     if (j.node == contextTree) {
                                                         contextModel.rootContext.updateParent();
                                                         const pt = j.node.toSceneTransform.inverse() * j.scenePoint;
                                                         var target = (contextTree.pick(pt.y) as Context.ContextTreenode).context;
                                                         var ctx = target;
                                                         var insertionPoint = 0;
                                                         if (not (ctx is Context.GroupContext)) {
                                                             ctx = ctx.parent;
                                                             insertionPoint = 0;
                                                             for (x in (ctx as Context.GroupContext).content) {
                                                                 if (x == target) {
                                                                     insertionPoint = indexof x;
                                                                     break;
                                                                 }
                                                             }
                                                         } 
                                                         if (ctx is Context.GroupContext) {
                                                             var g = ctx as Context.GroupContext;
                                                             insert (Context.ClosureVarContext { varType: asset as TypeAsset, parent: g })
                                                                 before g.content[insertionPoint];
                                                         }
                                                         println("TN ={tn.label} y={pt.y}");
                                                         break;
                                                     } 
                                                 }
                                             }
                                             if (asset is AssetTree.MemberAsset) {
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
                                                     if (j.node is Expression.Canvas) {
                                                         const ma = asset as AssetTree.MemberAsset;
                                                         (j.node as Expression.Canvas).onDrop(j, ma.member);
                                                         break;
                                                     } 
                                                 }
                                             }
					     delete dragger from popupLayer.content;
					     dragger = null;
					 }
				       }
                                     }
				 },
				 Tabview.Tab {
				     title: "Spatial";
				     content:
				     Tabview {
					 tabs:
					 [Tabview.Tab {
					     title: "Inspector";
                                                 content: Scrollpane {
                                                     canZoomVertical: false;
                                                     content: inspector1 = Inspector {
                                                         inspecting: bind Inspector.inspect(if (currentTransform == null) then currentScene else currentTransform);
                                                     }
                                                 }
					  },
					  Tabview.Tab {
					     title: "Hierarchy"
                                             content: Scrollpane {
                                                  canZoomVertical: false;
                                                  content:
                                                  Treeview {
                                                      model: TransformHierarchy.Model {
                                                          h: bind transformHierarchy;
                                                      }
                                                      override function onKeyDown from (e is KeyboardEvent) to ()
                                                      {
                                                          if (e.keyCode == Keys.Delete or
                                                              e.keyCode == Keys.Backspace) {
                                                              if (currentTransform <> null) {
                                                                  const toDelete = currentTransform;
                                                                  transformHierarchy.deleteSelection();
                                                                  deleteResource(toDelete);
                                                              } else {
                                                                  if (transformHierarchy.selectedScene <> mainScene) {
                                                                      delete transformHierarchy.selectedScene from
                                                                          currentScenes;
                                                                  }
                                                              }
                                                          } else super.onKeyDown(e);
                                                      }
                                                      var dragger is TransformNode;
                                                      var clip is Node;
                                                      override function onMouseDrag from (e is MouseEvent) to () {
                                                          if (dragger == null) {
                                                              clip = (selectedTreenode as TransformHierarchy.Treenode).n;
                                                              dragger = TransformNode {
                                                                  pickable: false;
                                                                  content: Group {
                                                                      transform: translate(-e.sceneLocation.x, 0);
                                                                      content: getDragCell();
                                                                  }
                                                              }
                                                              insert dragger into popupLayer.content;
                                                          }
                                                          dragger.tx = editorScene.mousePosition.x;
                                                          dragger.ty = editorScene.mousePosition.y;
                                                      }
                                                      
                                                      override function onMouseUp from (e is MouseEvent) to () 
                                                      {
                                                          for (j in getUnderMouseInEditor()) {
                                                              if (j.node is Expression.Canvas) {
                                                                  (j.node as Expression.Canvas).onDrop(j, clip);
                                                                  break;
                                                              }
                                                          }
                                                          delete dragger from popupLayer.content;
                                                          clip = null;
                                                          dragger = null;
                                                      }
                                                  }
                                              }
					 }]
				     }
				 },
				 Tabview.Tab {
				     title: "Temporal";
				     content:
                                         Tabview {
                                             tabs:
                                             [Tabview.Tab {
                                                     title: "Inspector";
                                                     content: Scrollpane {
                                                         canZoomVertical: false;
                                                         content: inspector2 = Inspector {
                                                             inspecting: bind Inspector.inspect(temporalHierarchy.selectedTransform);
                                                         }
                                                     }
                                                 },
                                                 Tabview.Tab {
                                                     title: "Hierarchy";
                                                     content:
                                                     Scrollpane {
                                                         canZoomVertical: false;
                                                         content:
                                                         Treeview {
                                                             model: TemporalHierarchy.Model {
                                                                 h: bind temporalHierarchy
                                                             }
                                                             override function onKeyDown from (e is KeyboardEvent) to ()
                                                             {
                                                                 if (e.keyCode == Keys.Delete or
                                                                     e.keyCode == Keys.Backspace) {
                                                                     const toDelete = temporalHierarchy.selectedTransform;
                                                                     temporalHierarchy.deleteSelection();
                                                                     deleteAnimResource(toDelete);
                                                                 } else super.onKeyDown(e);
                                                             }
                                                             var dragger is TransformNode;
                                                             var clip is TimeNode;
                                                             override function onMouseDrag from (e is MouseEvent) to () {
                                                                 if (dragger == null) {
                                                                     clip = (selectedTreenode as TemporalHierarchy.Treenode).n;
                                                                     dragger = TransformNode {
                                                                         pickable: false;
                                                                         content: Group {
                                                                             transform: translate(-e.sceneLocation.x, 0);
                                                                             content: getDragCell();
                                                                         }
                                                                     }
                                                                     insert dragger into popupLayer.content;
                                                                 }
                                                                 dragger.tx = editorScene.mousePosition.x;
                                                                 dragger.ty = editorScene.mousePosition.y;
                                                             }
                                                             
                                                             override function onMouseUp from (e is MouseEvent) to () 
                                                             {
                                                                 for (j in getUnderMouseInEditor()) {
                                                                     if (j.node is Expression.Canvas) {
                                                                         (j.node as Expression.Canvas).onDrop(j, clip);
                                                                         break;
                                                                     }
                                                                 }
                                                                 delete dragger from popupLayer.content;
                                                                 clip = null;
                                                                 dragger = null;
                                                             }
                                                         }
                                                     }
					     }]; 
                                           }
                                         },
                                         Tabview.Tab {
				            title: "Other";
                                             content:
                                             Tabview {
                                                 tabs:
                                                 [Tabview.Tab {
                                                     title: "Inspector";
                                                     content: Scrollpane {
                                                        canZoomVertical: false;
                                                             content: inspector3 = Inspector {
                                                                   inspecting: bind Inspector.inspect(otherHierarchy.selectedVariable);
                                                             }
                                                     }
                                                  },
                                                  Tabview.Tab {
                                                      title: "Hierarchy";
                                                      content:
                                                      Scrollpane {
                                                          canZoomVertical: false;
                                                         content:
                                                         Treeview {
                                                             model: VariableHierarchy.Model {
                                                                 h: bind otherHierarchy
                                                             }
                                                             override function onKeyDown from (e is KeyboardEvent) to ()
                                                             {
                                                                 if (e.keyCode == Keys.Delete or
                                                                     e.keyCode == Keys.Backspace) {
                                                                     const toDelete = otherHierarchy.selectedVariable;
                                                                     otherHierarchy.deleteSelection();
                                                                     //deleteAnimResource(toDelete);
                                                                 } else super.onKeyDown(e);
                                                             }
                                                             var dragger is TransformNode;
                                                             var clip is Context;
                                                             override function onMouseDrag from (e is MouseEvent) to () {
                                                                 if (dragger == null) {
                                                                     clip = (selectedTreenode as VariableHierarchy.Treenode).n;
                                                                     dragger = TransformNode {
                                                                         pickable: false;
                                                                         content: Group {
                                                                             transform: translate(-e.sceneLocation.x, 0);
                                                                             content: getDragCell();
                                                                         }
                                                                     }
                                                                     insert dragger into popupLayer.content;
                                                                 }
                                                                 dragger.tx = editorScene.mousePosition.x;
                                                                 dragger.ty = editorScene.mousePosition.y;
                                                             }
                                                             
                                                             override function onMouseUp from (e is MouseEvent) to () 
                                                             {
                                                                 for (j in getUnderMouseInEditor()) {
                                                                     if (j.node is Expression.Canvas) {
                                                                         (j.node as Expression.Canvas).onDrop(j, clip);
                                                                         break;
                                                                     }
                                                                 }
                                                                 delete dragger from popupLayer.content;
                                                                 clip = null;
                                                                 dragger = null;
                                                             }
                                                         }
                                                     }
                                                  }];
                                             }
                                         }];
                             }
                         }
                     },
		     InternalWindow {
                        id: "Editor2";            
			containerBounds: bind Bounds.boundsFromRect(0, 
								    0, 
								    width,
								    height-MENU_HEIGHT)
		    	height: 305, width: 820;
			cx: 520, cy: 160;	   
			      //imageLoader: null;
			      content: ResizableStageNode {
			    content: Tabview {
				tabs: 
				[Tabview.Tab {
				    title: "Timeline"
				    content: Scrollpane {
                                             canZoomVertical: false;
                                             content: trax = expr.timeline.Trax {
                                                 clips: bind currentAnimResource.resources;
                                                 loop: bind loop;
                                                 target: player;
                                                 targetNode: mainTimeLayer;
                                                 temporalHierarchy: temporalHierarchy;
                                                 removeClip: function from (clip is TimeNode) to ()
                                                 {
                                                     temporalHierarchy.deleteSelection();
                                                     deleteAnimResource(clip);
                                                 }
                                             }
                                         }
				 },
				 Tabview.Tab {
				    title: bind "Event Handler: {contextModel.selectedContext.name}"
				    content: expr.prog.Expression.Editor {
					 //event: bind inspector1.inspecting[inspector1.selectedIndex].member;
                                         eventContext: bind contextModel.selectedMemberContext;
					 targetNode: bind currentTransform as ResourceNode;
					 targetSpace: bind currentScene.root;
                                         instanceSpace: bind currentScene.instanceSpace;
					 targetTime: bind mainTimeLayer;
                                         targetTimeline: bind player;
                                         popupLayer: bind popupLayer;
                                         popupScene: bind editorScene;
                                         interactive: function from () to Boolean { interactive } 
				    }
				 }]
			    }
                        }
		    }]
                   },
	    toolMenu, 
            sceneMenu,
            popupLayer]
        };
     
    var stage is JoglStage = JoglStage {

        defaultCursor: bind toolCursor;

        override var content = bind [currentScenes, manipLayer, editorScene];
	
        onClose: function from () to Boolean {
            if (fileDirty()) {
                save();
            }
            saveEditorState(editorScene);
            return true;
        }
        title: bind "{currentResource.url} {if (savePoint <> MasterUndoable.now) then " (Unsaved)" else ""}";
        menubar: Menu.Bar {
	    menus: 
	    [Menu 
             { 
		 label: "File";
		 shortcut: Menu.Shortcut { keyCode: Keys.F }
		 items:
		 [MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.O }
		     label: "Open";
		     action: function {
			 const result = fileOpen.open();
			 if (result <> null) {
			     if (fileDirty()) {
				 save();
			     }
			     open("file:{result}");
			 }
		     }
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.S }
		     label: "Save";
		     enabled: bind currentResource.url <> ""
		     action: save;
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.A }
		     label: "Save As";
		     enabled: bind currentResource.url == ""
		     action: function {
			 fileSave.fileName = currentResource.url;
			 const result = fileSave.open();
			 if (result <> null) {
			     currentResource.url = "file:{result}";
			     save();
			 }
		     }
		 }]
	     },
	     Menu 
             { 
		 shortcut: Menu.Shortcut { keyCode: Keys.E }
		 label: "Edit"
		 items:
		 [MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.X }
		     label: "Cut"
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.C }
		     label: "Copy"
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.V }
		     label: "Paste"
		 }
                 Menu.Separator {},
		 MenuItem {
		     label: "Undo";
		     enabled: bind canUndo;
		     shortcut: Menu.Shortcut { keyCode: Keys.Z }
		     action: MasterUndoable.undo
		 },
		 MenuItem {
		     label: "Redo";
		     enabled: bind canRedo;
		     shortcut: Menu.Shortcut { keyCode: Keys.Z, shiftKey: true }
		     action: MasterUndoable.redo
		 }]
	     }]
	     
	}

	height: 800, width: 1020;
	
    }

    function setCamera from (i is Integer) to ()
    {
	/*
	if (i == 0) {
	    currentCamera = camera;
	} else if (i == 9) {
	    currentCamera = Camera2D {};
	} else {
	    const cam = model.getCameras()[i-1];
	    if (cam <> null) {
		currentCamera = cam;
	    }
	}
	println("camera={camera.tx}, {camera.ty}, {camera.tz}");
	*/
    }

    function deleteAnimResource from (n is TimeNode) to () 
    {
        var x = n;
        n.updateParent();
        while (x <> null) {
        println("DELETE {x.getClass()} => {x}");
            if (x is ResourceTimeNode) {
                const rn = x as ResourceTimeNode;
                delete x as ResourceTimeNode from currentAnimResource.resources;
                return;
            }
            x = x.parent;
        }
    }

    function deleteResource from (n is Node) to () {
	if (n is ResourceNode) {
	    const rn = n as ResourceNode;
	    delete n as ResourceNode from currentResource.resources;
	    if (rn.temporal <> null) {
		delete rn.temporal from currentAnimResource.resources;
		//trax.setClips(currentAnimResource.resources);
	    }
	}
    }

    function setClip from (i is Integer) to ()
    {
	//currentResource.setClip(i);
    }

    stage.addMouseInputHandler(MouseInputHandler.Delegate { 
            delegate: viewer;
            override function onMouseWheel from (event is MouseWheelEvent) to ()
            {
                if (editorScene.underMouse == []) {
                    delegate.onMouseWheel(event);
                }
            }
        });
    stage.addKeyboardInputHandler(KeyboardInputHandler {

	    override function onKeyInput from (event is KeyboardEvent) to () 
	    {
		if (event.keyChar == "-" or event.keyChar == "_") {
		    manip.shrink();
		} else if (event.keyChar == "+" or event.keyChar == "=") {
		    manip.expand();
		}
	    }
		
	    override function onKeyUp from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    if (event.keyCode == Keys.D) {
			manip.exitPivotMode();
		    }
		}
	    }

	    override function onKeyDown from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    println("event={event}");
		    if (event.keyCode == Keys.Delete or event.keyCode == Keys.Backspace) {
			//const toDelete = currentTransform;
			//transformHierarchy.deleteSelection();
			//deleteResource(toDelete);
		    } else if (event.keyCode == Keys.D) {
			manip.enterPivotMode();
			/* } else if (event.keyCode == Keys.Z and event.metaKey) {
			if (event.shiftKey) {
			    MasterUndoable.redo();
			} else {
			    MasterUndoable.undo();
			    }*/
		    } else if (event.keyCode == Keys.F) {
                        if (currentScene == mainScene) {
                            viewer.focusCamera(currentTransform);
                        }
		    } else if (event.keyCode >= Keys._0 and event.keyCode <= Keys._9) {
			const index = event.keyCode - Keys._0;
			if (event.metaKey) {
			    setClip(index);
			} else {
			    setCamera(index);
			}
		    } else if (event.keyCode == Keys.G) {
			java.lang.System.gc();
			//showMemory = not showMemory;
		    }
		}
	    }
	});

    stage.addDnDInputHandler(DnDInputHandler {
	    override function onDrop from (event is DropEvent) to () 
	    {
		const url = event.url;
		event.accept();
		try {
		    const checkProtocol = new java.net.URL(url);
                    const pt = currentScene.camera.toScene(event.screenx, event.screeny);
                    println("DROP on SCENE {event.screenx}, {event.screeny} => {pt} ");
		    doDrop(url, pt);
		} catch (exception is java.lang.Exception) {
		    exception.printStackTrace();
		}
	    }
	});
    doUpdate = DefaultObserver of (()) {
        override function onNext from (_ is ()) to () {
            canUndo = MasterUndoable.canUndo();
            canRedo = MasterUndoable.canRedo();
            for (z in currentScenes) {
                z.instanceSpace.content = z.instanceSpace.content[ x | { var y = x as EventLayer.EventNode; y.timestamp <= player.playhead }];
            }
        }
    };
    currentScenes = [mainScene];
    transformHierarchy.selectedScene = mainScene;
    println("SET MAIN SCENE {transformHierarchy.selectedScene}");
    stage.invoke(function {
	    //viewer.focusCamera(currentTransform);
            
	});
    stage.observeUpdate().subscribe(doUpdate);
    MasterUndoable.commit();

}




