package expr;
import f3.jogl.awt.JoglStage;
import f3.jogl.awt.JoglStage.*;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.util.Bits;
import f3.util.*;
import f3.util.Observer.*;
import f3.media.scene.*;
import f3.media.input.*;
import f3.media.svg.SVG;
import f3.media.xhtml.XHTML;
import java.lang.Math;
import expr.choices.SliderField;
import expr.undo.*;
import expr.inspector.*;
import expr.inspector.Inspector.*;
import expr.ResourceNode.*;
import expr.ResourceTimeNode.*;
import expr.AssetTree.*;
import expr.timeline.*;
import expr.prog.*;
import f3.util.*;
import f3.util.Observer.*;
import f3.util.Observable.*;

public class InternalWindowState {
    public var id is String;
    public var cx is Number;
    public var cy is Number;
    public var width is Number;
    public var height is Number;
}

public class EditorState {
    public var windowWidth is Integer;
    public var windowHeight is Integer;
    public var internalWindows: InternalWindowState[];
    public var cameraX is Number;
    public var cameraY is Number;
    public var cameraZ is Number;
    public var playheadFrame is Integer = 0;
    public var frameRate is Integer = 24;
}

function saveEditorState from (scene is Scene, player is Timeline, trax is Trax) to () 
{
    var internalWindows is InternalWindowState[];
    const f is function from ((), Node) to () 
        = function from (_ is (), n is Node) to ()
        {
            if (n is InternalWindow) {
                const w = n as InternalWindow;
                insert InternalWindowState {
                    id: w.id;
                    cx: w.cx;
                    cy: w.cy;
                    width: w.width;
                    height: w.height;
                } into internalWindows;
            }
        };
    scene.root.foldLeft((), f);
    const file = new java.io.File(".expr.editorstate.tmp");
    const w = new java.io.BufferedWriter(new java.io.FileWriter(file));
    IO.writeObject(w, EditorState {
            windowHeight: scene.stage.outsideHeight;
            windowWidth: scene.stage.outsideWidth;
            internalWindows: internalWindows;
//            playheadFrame: trax.currentFrame as Integer;
            frameRate: trax.frameRate as Integer;
        });
    w.flush();
    w.close();
    file.renameTo(new java.io.File(".expr.editorstate"));
}

function loadEditorState from (stage is JoglStage, scene is Scene, player is Timeline, trax is Trax) to () 
{
    const file = new java.io.File(".expr.editorstate");
    if (file.exists()) {
        const s = IO.readObject(new java.io.BufferedReader(new java.io.FileReader(file))) as EditorState;
        const f is function from ((), Node) to () 
            = function from (_ is (), n is Node) to ()
        {
            if (n is InternalWindow) {
                const w = n as InternalWindow;
                for (x in s.internalWindows) {
                    if (x.id == w.id) {
                        w.cx = x.cx;
                        w.cy = x.cy;
                        w.width = x.width;
                        w.height = x.height;
                        break;
                    }
                }
            }
        };
        scene.root.foldLeft((), f);
        if (s.windowHeight <> 0 and s.windowWidth <> 0) {
            stage.resizeWindow(s.windowWidth, s.windowHeight);
        }
        trax.setFrameRate(s.frameRate);
        player.setPlayhead((1s / s.frameRate) * s.playheadFrame);
    }
}

class CachedScene is Scene {
    public var scene is Scene[];
    override var camera = Camera2D {tx: bind -width/2, ty: bind -height/2}
    var stageNode is StageNode = StageNode {
	content: bind scene;
    }
    override function update {
	if (stageNode.width <> width or stageNode.height <> height) {
	    stageNode.resize(width, height);
	}
	super.update();
    }
    override var content = bind stageNode;
}

class ResizableStageNode is ResizableNode, Focuser {
    const stage is StageNode = StageNode {
        background: Color.GRAY;
	content: Scene {
            background: Color.color(.3, .3, .3);
	    camera: Camera2D { tx: bind Math.round(-width / 2.0), ty: bind Math.round(-height / 2.0) }
	    content: bind content;
	}
    }
    override function resize from (w0 is Number, h0 is Number) to ()
    {
	const w = Math.ceil(w0);
	const h = Math.ceil(h0);
	super.resize(w, h);
	content.resize(w, h);
	stage.resize(w as Integer, h as Integer);
    }
    override var internalContent = Group { content: bind stage };
    public var content is ResizableNode;
    override public function getTargetOfFocus to Focusable 
    {
	return stage;
    }
}

function readTextFile from (url is String) to (String, Integer)
{
    const u = new java.net.URL(url);
    const reader = new java.io.BufferedReader(new java.io.InputStreamReader(u.openStream()));
    var line is Object; // sic!
    var buf = new java.lang.StringBuffer;
    var lineCount = 0;
    while ((line = reader.readLine()) <> null) {
	buf.append(line);
	buf.append("\n");
	lineCount++;
    }
    return (buf.toString(), lineCount);

}

public class MainContext is Context.MemberContext {
    override var member = Expression.Member {
        name: "Start";
        t: Reflect.UNIT_TYPE;
        rt: Reflect.UNIT_TYPE;
        isObservable: yes;
        override function toEnglish to String { "Start" }
        override function toApply to String { "expr.ExprNode.Start" }
    }
}

var canUndo is Boolean;
var canRedo is Boolean;
var currentScenes is ResourceScene[] = [];
var doUpdate is Observer of (());

const IMAGE_LOADER = f3.jogl.awt.JoglStage.ImageLoader_INSTANCE;


public function run from (args is String[]) to ()
{
    var mainContext is MainContext = MainContext {
        name: "Start";
    }

    var contextTree is Treeview;

    var contextModel is Context.ContextTreemodel = Context.ContextTreemodel {
        rootContext: bind mainContext;
    } 

    var lastContext is Context;

    function handleContextVisibility from (ctx is Context, v is Boolean) to ()
    {
        var c = ctx;
        while (c <> null) {
            //println("c={c.name} parent={c.parent.name} v={v}");
            for (c1 in [c, c.getContent()]) {
                if (c1 is Context.ResourceNodeContext) {
                    const rc = c1 as Context.ResourceNodeContext;
                    println("visible = {v} => {rc.resource}");
                    rc.resource.visible = v;
                }
            }
            c = c.parent;
        }
    }

    var selectionHandler = contextModel.selectionObserver.subscribe(function from (tn is Treeview.Treenode) to () 
                                                                    {
                                                                        mainContext.updateParent();
                                                                        const ctx = (tn as Context.ContextTreenode).context;
                                                                        handleContextVisibility(lastContext, false);
                                                                        lastContext = ctx;
                                                                        handleContextVisibility(ctx, true);
                                                                    });

    var currentScene is ResourceScene = bind transformHierarchy.selectedScene;

    var currentResource is ResourceGroup = bind currentScene.currentResource;

    const currentAnimResource is ResourceTimeGroup = ResourceTimeGroup {
	id: "Temporal Hierarchy";
    }

    const transformHierarchy is TransformHierarchy = TransformHierarchy {
	scenes: bind currentScenes;
    }

    const temporalHierarchy = TemporalHierarchy { root: bind currentAnimResource }
    const otherHierarchy = VariableHierarchy { root: bind mainContext }
    var currentCamera is Camera;
    var TheMovieLoader is MovieLoader;
    try {
	const clazz = 
	    java.lang.Class.forName("org.f3.media.video.macos.MovieLoaderImpl") as java.lang.Class of MovieLoader;
	TheMovieLoader = clazz.newInstance();
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't create corevideo movie loader");
    }
    
    var TheWebBrowserFactory is AbstractWebBrowserFactory;
    try {
	const clazz = 
	    java.lang.Class.forName("f3.media.web.awesomium.AwesomiumWebBrowserFactory") as java.lang.Class of AbstractWebBrowserFactory;
	TheWebBrowserFactory = clazz.newInstance();
	    
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load awesomium web browser factory");
    }

    var TheSoundLoader is SoundLoader;
    try {
	const clazz = 
	    java.lang.Class.forName("org.f3.media.audio.impl.fmod.SoundLoaderImpl") as java.lang.Class of SoundLoader;
	TheSoundLoader = clazz.newInstance();
	    
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load fmod sound factory");
    }

    println("args={args}");

    var playerUrl is String;

    const mainTimeLayer = TimeGroup {
	id: "Hierarchy";
	content: bind currentAnimResource;
	playRange: bind if (nonInteractiveLoop) then null else Interval { start: 0s, end: Duration.INDEFINITE };
	playCount:  bind if (nonInteractiveLoop) then -1 else 1;
    }

    const player = Timeline {
	paused: true;
	content: mainTimeLayer;
    }

    const camera = PerspectiveCamera {
        id: "free";
	ty: 3.0;
	tz: 13;
	near: 1;
	far: 10000;
        content: PointLight {}
    }

    const viewer = DefaultExaminerViewer {
	camera: camera;
    }

    const browser = if TheWebBrowserFactory == null then null else WebBrowser {
	//factory: TheWebBrowserFactory;
	//effectLoader: CGEffectLoader_INSTANCE;
	//pathFactory: ThePath2DFactory;
    }

    
    function addResource from (rn is ResourceNode, pt is Point3) to ()
    {
        println("ADDING {rn} to {currentResource} th.scenes={transformHierarchy.scenes}, th.selectedScene={transformHierarchy.selectedScene}");
	insert rn into currentResource.resources;
	transformHierarchy.selectNode(rn);
        if (currentScene == mainScene) {
            viewer.focusCamera(rn);
        }
        insert Context.ResourceNodeContext { 
            parent: contextModel.selectedGroupContext; 
            resource: rn;
        } 
        into contextModel.selectedGroupContext.content;
        println("added asset to context { contextModel.selectedContext }");
        if (currentScene.camera is Camera2D) {
            rn.tx = pt.x;
            rn.ty = pt.y;
        }
    }

    function addTimeResource from (rn is ResourceTimeNode) to ()
    {
        println("ADDING TIME RESOURCE { rn }");
        rn.updateParent();
	insert rn into currentAnimResource.resources;
        insert Context.ResourceTimeNodeContext { 
            parent: contextModel.selectedGroupContext; 
            resource: rn;
        } 
        into contextModel.selectedGroupContext.content;
    }

    function doDrop from (url is String, pt is Point3) to () 
    {
	playerUrl = url;
	if (url.endsWith(".expr")) {
	    const model = ExprNode {
                webBrowserFactory: TheWebBrowserFactory
		url: url;
                isInteractive: bind interactive;
                standalone: true;
	    }
	    const rn = ResourceNode {
                url: url;
                content: bind model;
	    }
	    addResource(rn, pt);
            if (not model.standalone) {
                const rtn = ResourceTimeNode {
                    url: url;
                    content: bind model.temporalRoot;
                    spatial: rn;
                }
                if (rtn.bounds.duration() > 0s) {
                    rn.temporal = rtn;
                    addTimeResource(rtn);
                }
            }
	} else if (url.endsWith(".mp4") or url.endsWith(".mov")) {
            const movie = Movie {
                url: url;
                paused: true;
            }
	    const rn = ResourceNode {
                url: url;
	        content: movie;
	    }
	    addResource(rn, pt);
            const clip = Movie.Clip { movie: movie };
	    const rtn = ResourceTimeNode {
		url: url;
		content: clip
		spatial: rn;
                override function playFromStart to ()
                {
                    super.playFromStart();
                    clip.playMovieFromStart();
                }
	    }
            addTimeResource(rtn);
	} else if (url.endsWith(".aif") or 
                   url.endsWith(".aiff") or 
                   url.endsWith(".asf") or 
                   url.endsWith(".asx") or
                   url.endsWith(".dls") or
                   url.endsWith(".flac") or
                   url.endsWith(".fsb") or
                   url.endsWith(".it") or
                   url.endsWith(".m3u") or
                   url.endsWith(".mid") or
                   url.endsWith(".midi") or
                   url.endsWith(".mod") or
                   url.endsWith(".mp2") or
                   url.endsWith(".mp3") or
                   url.endsWith(".pls") or
                   url.endsWith(".pls") or
                   url.endsWith(".s3m") or
                   url.endsWith(".vag") or
                   url.endsWith(".wav") or
                   url.endsWith(".wax") or
                   url.endsWith(".wma") or
                   url.endsWith(".xm") or
                   url.endsWith(".xma")){
            const sound = Sound.Sample {
                url: url;
                paused: true
            }
	    const rn = ResourceNode {
                url: url;
	        content: sound;
	    }
	    const rtn = ResourceTimeNode {
		url: url;
		content: Sound.Clip { sound: sound };
		spatial: rn;
	    }
            rn.temporal = rtn;
	    addResource(rn, pt);
            addTimeResource(rtn);
	} else if (url.endsWith(".ma")) {
	    const model = Ma.Model {
		url: url;
	    }
	    const rn = MaResourceNode {
	        model: model;
	    }
	    addResource(rn, pt);
	    const rtn = MaResourceTimeNode {
                model: model;
		spatial: rn;
	    }
	    if (true or rtn.bounds.duration() > 0s) {
		rn.temporal = rtn;
		addTimeResource(rtn);
	    }
	} else if (url.endsWith(".xhtmli")) {
	    const xhtml = XHTML.Text {
		content: readTextFile(url).first;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind xhtml;
	    }	
	    addResource(rn, pt);
	} else if (url.endsWith(".xhtml")) {
	    const xhtml = XHTML.Document {
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind xhtml;
	    }	
	    addResource(rn, pt);
	} else if (url.endsWith(".svg")) {
	    const svg = SVG {
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind svg.root;
	    }	
	    addResource(rn, pt);
	} else if (url.endsWith(".png") or url.endsWith(".jpg") or url.endsWith(".tif") or url.endsWith(".tiff") or url.endsWith(".tga")) {
	    const image= Image { 
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: image;
	    }	
	    addResource(rn, pt);
	} else {
	    const browser = WebBrowser {
		url: url
	    }
	    const rn = ResourceNode {
		url: url;
		content: browser;
	    }
	    addResource(rn, pt);
	}
	MasterUndoable.commit();
    }

    var trax is expr.timeline.Trax;
    var inspector1 is Inspector;
    var inspector2 is Inspector;
    var inspector3 is Inspector;
    var currentTransform = bind transformHierarchy.selectedTransform;
    currentCamera = camera;

    var savePoint is Integer;

    var editorScene is Scene;
    var internalWindowsLayer is Group;
    var popupLayerCallback is function from () to ();
    var popupLayer is PopupLayer = PopupLayer {
        height: bind editorScene.height;
        width: bind editorScene.width;
        //transform: bind translate(editorScene.width/2, editorScene.height/2);
    };

    function getUnderMouseInEditor to Pick[] 
    {
	var result is Pick[];
	foreach (x in editorScene.underMouse) {
	    insert x into result;
	    if (x.node is StageNode) {
		for (y in (x.node as StageNode).content) {
		    insert y.underMouse into result;
		}
	    }
	}
	return result;
    }

    const mainScene = ResourceScene {
        id: "Main Scene";
	background: Color.GRAY;
        camera: camera;
    }

/*
    const cachedScene = CachedScene {
        background: null;
	scene: mainScene;
    }
*/
    bound function getCamerasFromModel from (m is Ma.Model) to Camera[] {
        foreach (c in m.getCameras()) {
            if (c.id == "topShape" or c.id == "perspShape" or c.id == "frontShape" or c.id == "sideShape") then null else c;
        }
    }

    var stepping is Boolean = false;
    var loop is Boolean = false;
    var nonInteractiveLoop = bind not interactive and loop;
    var full is Boolean = false;

    var interactive is Boolean;
    
    const toolMenu is expr.toolmenu.ToolMenu = expr.toolmenu.ToolMenu {
    	transform: bind translate(stage.width /2, stage.height - 10);
	height: 20;
	width: bind stage.width;
	pause: &player.paused;
	onRewind: function to () { 
            var paused = player.paused;
            player.paused = true;
            player.setPlayhead(0.5s);
            player.setPlayhead(0s);
            player.paused = paused;
        }
	onHideFloating: function from (b is Boolean) to ()
	{
	    internalWindowsLayer.visible = b;
	}
	toggleLoop: function { loop = not loop; () }
        toggleStepping: function { stepping = not stepping; () } 
	toggleFullscreen: function { full = not full; stage.setFullscreen(full) }
        onSetSelecting: function from () to () {
            interactive = false;
        }
        onSetScripting: function from () to () {
            interactive = true;
        }
    };

    readonly var toolCursor is Cursor = bind if (interactive) then toolMenu.scriptingCursor else toolMenu.selectingCursor;

    const sceneMenu = Tabview {
          height: 20; width: bind stage.width;
          transform: bind translate(stage.width/2, stage.height-30);
          tabs: bind foreach (scene in transformHierarchy.scenes) Tabview.Tab {
                title: bind scene.id;
                onSelect: function from () to () 
                {
                    transformHierarchy.selectScene(scene);                        
                }
          }
    }
    
    const MENU_HEIGHT = 40;

    const disp = transformHierarchy.observeSceneSelection().subscribe(function from (n is ResourceScene) to () {        
            sceneMenu.selectedIndex = Sequences.indexOf(transformHierarchy.scenes, n);
	});
    
    var manip is expr.manipulator.Manipulator;

    function save to Boolean {
        if (mainScene.currentResource.url == "") {
            var result = fileSave.open();
            if (result <> null) {
                if (not result.endsWith(".expr")) {
                    result = "{result}.expr";
                }
                mainScene.currentResource.url = "file:{result}";
            } else {
                return false;
            }
        }
        doSave();
    }

    function doSave to Boolean {
        if (mainScene.currentResource.url <> "") {
            savePoint = MasterUndoable.now;
            Resources.save(mainScene.currentResource.url,
                           mainScene,
                           mainScene.currentResource,
                           currentAnimResource,
                           currentScenes[x | x <> mainScene]);
            return true;
        }
        return false;
    }

    function doExport to () {
        save();
        const u = new java.net.URL(mainScene.currentResource.url);
        fileSave.fileName = "{new java.io.File(u.getFile()).getName()}.zip";
        fileSave.title = "Export";
        var result = fileSave.open();
        if (result <> null) {
            Resources.export(result,
                             mainScene.currentResource.url,
                             mainScene,
                             mainScene.currentResource,
                             currentAnimResource,
                             currentScenes[x | x <> mainScene]);
        }
        return true;
    }

    
    function close from () to () {
	savePoint = 0;
        mainScene.currentResource.url = "";
        currentScenes = [mainScene];
	mainScene.currentResource.resources = [];
	currentAnimResource.resources = [];
        contextModel.reset();
	transformHierarchy.clearSelection();
        playerUrl = "";
	MasterUndoable.reset();
    }

    const undoList = expr.undo.UndoList {} on replace {
	undoList.addTarget("timenodes", &currentAnimResource.resources);
    }

    function open from (url is String) to ()
    {
	close();
	const sceneRes = Resources.open(url);
        var allPrograms is Program[];
        var baseURL = new java.net.URL(url);
        function rebaseURL from (u is String) to String {
            if (u.startsWith("timenode://") or u.contains("#")) then u else new java.net.URL(baseURL, u).toString();
        }
	for (i in sceneRes.spatialResources) {
	    doDrop(rebaseURL(i.url), new Point3(i.tx, i.ty, i.tz));
	    currentTransform.tx = i.tx;
	    currentTransform.ty = i.ty;
	    currentTransform.tz = i.tz;

	    currentTransform.sx = i.sx;
	    currentTransform.sy = i.sy;
	    currentTransform.sz = i.sz;

	    currentTransform.rx = i.rx;
	    currentTransform.ry = i.ry;
	    currentTransform.rz = i.rz;

	    currentTransform.px = i.px;
	    currentTransform.py = i.py;
	    currentTransform.pz = i.pz;
            (currentTransform as ResourceNode).programs = foreach (prog in i.programs) {
                const p = Program {
                    event: prog.event.deserialize();
                    code: prog.code;
                    sourceCode: prog.compiled;
                    evalContext: Program.EvalContext {
                        interactive: function from () to Boolean { interactive } 
                        targetNode: currentTransform;
                        instanceSpace: currentScene.instanceSpace;
                        lookupSpatial: currentScene.root.lookup;
                        targetTimeline: player;
                        lookupTemporal: mainTimeLayer.lookup;
                    }
                }
                println("CREATING PROGRAM**** {prog} => {p.sourceCode}");
                insert p into allPrograms;
                p;
            }
	}
        var tempResources = currentAnimResource.resources;
        currentAnimResource.resources = [];
	for (i in sceneRes.temporalResources) {
            var q is TimeNode;
            if (i.url.contains("#")) { // clip from library
                for (x in currentResource.resources) {
                    if (x is MaResourceNode) {
                        const j = (x as MaResourceNode).temporal;
                        q = j.lookup(i.url);
                    }
                }
            } else {
                for (j in tempResources) {
                    if (i.url == j.url) {
                        q = j;
                        break;
                    } 
                }
            }
            if (q <> null) {
                q.playTime = i.playTime;
                q.playRate = i.playRate;
                q.playCount = i.playCount;
                const qt = q as ResourceTimeNode;
                insert qt into currentAnimResource.resources;
                qt.programs = foreach (prog in i.programs) {
                    const p = Program {
                        event: prog.event.deserialize();
                        code: prog.code;
                        sourceCode: prog.compiled;
                        evalContext: Program.EvalContext {
                            interactive: function from () to Boolean { interactive } 
                            targetNode: qt;
                            instanceSpace: currentScene.instanceSpace;
                            lookupSpatial: currentScene.root.lookup;
                            targetTimeline: player;
                            lookupTemporal: mainTimeLayer.lookup;
                        }
                    }
                    println("CREATING PROGRAM**** {prog} => {p.sourceCode}");
                    insert p into allPrograms;
                    p;
                }
            } else {
                println("Couldn't resolve temporal resource: {i.url}");
                null;
            }
	}
        for (j in sceneRes.layers) {
            var scene = ResourceScene {
                background: null;
                id: j.name;
                camera: Camera2D { near: -1000, far: 1000, tz: 900 };
            }
            insert scene into currentScenes;
            transformHierarchy.selectScene(scene);
            foreach (i in j.spatialResources) {
                doDrop(rebaseURL(i.url), new Point3(i.tx, i.ty, i.tz));
                currentTransform.tx = i.tx;
                currentTransform.ty = i.ty;
                currentTransform.tz = i.tz;
                
                currentTransform.sx = i.sx;
                currentTransform.sy = i.sy;
                currentTransform.sz = i.sz;
                
                currentTransform.rx = i.rx;
                currentTransform.ry = i.ry;
                currentTransform.rz = i.rz;
                
                currentTransform.px = i.px;
                currentTransform.py = i.py;
                currentTransform.pz = i.pz;
                (currentTransform as ResourceNode).programs = foreach (prog in i.programs) {
                    const p = Program {
                        event: prog.event.deserialize();
                        code: prog.code;
                        sourceCode: prog.compiled;
                        evalContext: Program.EvalContext {
                            interactive: function from () to Boolean { interactive } 
                            targetNode: currentTransform;
                            instanceSpace: currentScene.instanceSpace;
                            lookupSpatial: currentScene.root.lookup;
                            targetTimeline: player;
                            lookupTemporal: mainTimeLayer.lookup;
                        }
                    }
                    println("CREATING PROGRAM**** {prog} => {p.sourceCode}");
                    insert p into allPrograms;
                    p;
                }
            }
        }
        function convertTimeResource from (i is Resources.TemporalResource) to TimeNode {
            var t is TimeNode;
            if (i.url.startsWith("timenode://TransitionLayer")) {
                t = TransitionLayer {
                    id: i.url;
                    content: foreach (j in i.content) {
                        convertTimeResource(j)
                    }
                }
                const rtn = ResourceTimeNodeWrapper {
                    url: i.url;
                    wrapped: t as TimeGroup;
                    blendWeight: i.blendWeight;
                    playTime: i.playTime;
                    playRate: i.playRate;
                    playCount: i.playCount;
                };
                t = rtn;
                addTimeResource(rtn);
            } else if (i.url.startsWith("timenode://BlendLayer")) {
                t = BlendLayer {
                    id: i.url;
                    content: foreach (j in i.content) {
                        convertTimeResource(j)
                    }
               }
                const rtn = ResourceTimeNodeWrapper {
                    blendWeight: i.blendWeight;
                    playTime: i.playTime;
                    playRate: i.playRate;
                    playCount: i.playCount;
                    url: i.url;
                    wrapped: t as TimeGroup;
                };
                t = rtn;
                addTimeResource(rtn);
            } else {
                const u = rebaseURL(i.url);
                t = mainTimeLayer.lookup(u);
                if (t == null) {
                    for (x in currentResource.resources) {
                        if (x is MaResourceNode) {
                            const j = (x as MaResourceNode).temporal;
                            t = j.lookup(u);
                            if (t <> null) {
                                const rtn = ResourceTimeNodeWrapper {
                                    url: i.url;
                                    wrapped: t as TimeGroup;
                                    blendWeight: i.blendWeight;
                                    playTime: i.playTime;
                                    playRate: i.playRate;
                                    playCount: i.playCount;
                                };
                                t = rtn;
                                break;
                            }
                        }
                    }
                }
            }
            println("CONVERT TIME RESOURCE : {i.url} => {t}");
            t;
        }
        for (i in sceneRes.temporalResources) {
            convertTimeResource(i);
        }
        transformHierarchy.selectScene(mainScene);
	//trax.setClips(currentAnimResource.resources);
        for (p in allPrograms) p.evaluate();
	MasterUndoable.reset();
	MasterUndoable.commit();
	savePoint = MasterUndoable.now;
	mainScene.currentResource.url = url;
    }

    const yesNo = Dialog.YesNoCancel {
    }

    const fileSave = FileDialog.FileSave {
    }

    const fileOpen = FileDialog.FileOpen {
	filterExtensions: [".expr"]
    }

    function fileDirty to Boolean {
	MasterUndoable.canUndo();
    }

    var manipLayer = Scene {
                //visible: bind internalWindowsLayer.visible;
                      background: null;
                      camera: bind currentScene.camera;
		      override var content = [manip = expr.manipulator.Manipulator 
		      {
			  visible: bind currentTransform <> null;
                          viewer: viewer;
			  target: bind currentTransform;
			  scene: this;
		      }, 
                      Group {
                          var viewScale = bind uniformScale(manip.viewScale*.5);
                          content: bind foreach  (cam in currentScene.currentCameras) {
                              var cameraModel = Ma.Model {
                                  url: "{__DIR__}camera.ma";
                              }
                              Group {
                                  transform: bind cam.toSceneTransform;
                                  content: Group {
                                      transform: bind viewScale;
                                      content: bind cameraModel.getSpatialRoot();
                                  }
                              }
                          }
                      }]
        };
        
        var _ = editorScene = Scene {
                    var lastTime is Long;
                    override function update {
                        const now = java.lang.System.currentTimeMillis();
                        if (lastTime == 0) {
                            loadEditorState(joglStage(), this, player, trax);
                            lastTime = now;
                        } else if (now - lastTime > 2000) {
                            saveEditorState(this, player, trax);
                            if (savePoint <> MasterUndoable.now) {
                                doSave();
                            }
                            lastTime = now;
                        }
                        super.update();
                    }
                    background: null;
                    camera: Camera2D {}; 
		    override var content =
		    [internalWindowsLayer = Group { 

                       content: 
                       [InternalWindow {
                                    id: "Editor3";
			containerBounds: bind Bounds.boundsFromRect(0, 
                                                                    0, 
                                                                    width,
                                                                    height-MENU_HEIGHT)
		    	height: 400, width: 300;
                                    content: ResizableStageNode {
                                        content: Tabview {
                                            tabs: 
                                            [Tabview.Tab {
                                                title: "Events";
                                                content: Scrollpane {
                                                    canZoomVertical: false;
                                                    content: contextTree = Treeview {
                                                        model: bind contextModel;
                                                        override function onKeyDown from (e is KeyboardEvent) to ()
                                                        {
                                                            if (e.keyCode == Keys.Delete or
                                                                e.keyCode == Keys.Backspace) {
                                                                const toDelete = contextModel.selectedContext;
                                                                delete toDelete from contextModel.selectedGroupContext.content;
                                                            } else super.onKeyDown(e);
                                                        }                                       
                                                    }
                                                }
                                            },
                                            Tabview.Tab {
                                                title: "Cameras";
                                                content: Tabview {
                                                    var sn = Scene {
                                                        content: bind currentScene.root;
                                                    }
                                                    var st = StageNode {
                                                        content: sn;
                                                    }
                                                tabs:
                                                    bind foreach (m in currentScene.currentModels) {
                                                        var cams = bind foreach (cam in getCamerasFromModel(m.model)) cam;
                                                        if (cams.size() == 0) then null else
                                                        Tabview.Tab {
                                                        title: m.id;

                                                        content: Tabview {
                                                            tabs:
                                                             bind foreach ( cam in cams) 
                                                                Tabview.Tab {
                                                                title: cam.id;
                                                                var g is Group = Group {};
                                                                onSelect: function to () {
                                                                    g.content = st;
                                                                    sn.camera = cam;
                                                                }
                                                                content: ResizableNode {
                                                                    override function resize from (w is Number, h is Number) to () 
                                                                    {
                                                                        st.resize(w as Integer, h as Integer);
                                                                    }
                                                                    override var internalContent = bind g;
                                                                }
                                                            }
                                                        }
                                                        }
                                                    }
                                                }
                                            }]
                                        }
                                    }
                       },
                       InternalWindow {
                        id: "Editor1";            
			containerBounds: bind Bounds.boundsFromRect(0, 
                                                                    0, 
                                                                    width,
                                                                    height-MENU_HEIGHT)
		    	height: 400, width: 300;
			cx: 160, cy: 800-300;	   
			    content: ResizableStageNode {
			    
			      content: Tabview {
				tabs: 
				[Tabview.Tab {
				     title: "Assets";
				     content:
                                     Scrollpane { 
                                         canZoomVertical: false;
                                         content: Treeview {
					 model: AssetTree.AssetModel {
					     resources: bind mainScene.currentResource;
					 }

					 var dragger is TransformNode;
                                         var tn is AssetTree.AssetTreenode;

					 override function onMouseDrag from (e is MouseEvent) to () {
					     if (dragger == null) {
						 dragger = TransformNode {
						     pickable: false;
						     content: Group {
							 transform: translate(-e.location.x, 0);
							 content: getDragCell();
						     }
						 }
						 insert dragger into popupLayer.content;
					     }
					     dragger.tx = editorScene.mousePosition.x;
					     dragger.ty = editorScene.mousePosition.y;
                                             tn = (selectedTreenode as AssetTreenode);
					 }

					 override function onMouseUp from (e is MouseEvent) to () 
					 {
					     var asset = tn.asset;
					     if (asset is AssetTree.MaAsset) {
						 const t = (asset as AssetTree.MaAsset).model.getTemporalRoot();
						 if (t.bounds.duration() > 0s) {
						     asset = AssetTree.ClipAsset {
							 override function getClip to TimeNode { t }
							 url: asset.url;
							 name: asset.name;
						     }
						 }
					     }
					     if (asset is AssetTree.ClipAsset) {
						 const clip = (asset as AssetTree.ClipAsset).getClip();
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
						     println("j={j.node}");
						     if (j.node is Trax) { 
                                                         const rtn = 
                                                             if (clip is ResourceTimeNode) 
                                                                 then clip as ResourceTimeNode 
                                                                 else ResourceTimeNodeWrapper {
                                                                         playCount: if clip is BlendLayer then -1 else 1; // hack...
                                                                         url: asset.url;
                                                                         wrapped: clip as TimeGroup;
                                                                     };
							 (j.node as Trax).onDrop(j, rtn, 
                                                                                 function from (t is TimeNode) to ()
                                                                                 {
                                                                                     const rtn = t as ResourceTimeNode;
                                                                                     addTimeResource(rtn);
                                                                                 });
							 break;
						     }
						 }
					     }
                                             if (asset is AssetTree.ResourceNodeAsset) {
						 const clip = (asset as AssetTree.ResourceNodeAsset).rn.temporal;
                                                 if (clip <> null) {
                                                     const picked = getUnderMouseInEditor();
                                                     for (j in picked) {
                                                         println("j={j.node}");
                                                         if (j.node is Trax) { 
                                                             const rtn = clip;
                                                             (j.node as Trax).onDrop(j, rtn, 
                                                                                     function from (t is TimeNode) to ()
                                                                                     {
                                                                                         const rtn = t as ResourceTimeNode;
                                                                                         addTimeResource(rtn);
                                                                                     });
                                                             break;
                                                         }
                                                     }
                                                 }
                                             }
                                             if (asset is AssetTree.SceneAsset) {
                                                 const picked = getUnderMouseInEditor();
                                                 if (picked == []) {
                                                     const scene = (asset as AssetTree.SceneAsset).getScene();
                                                     insert scene into currentScenes;
                                                     transformHierarchy.selectScene(scene);
                                                     MasterUndoable.commit();
                                                 }
                                             }
                                             if (asset is AssetTree.TypeAsset) {
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
                                                     if (j.node == contextTree) {
                                                         contextModel.rootContext.updateParent();
                                                         const pt = j.node.toSceneTransform.inverse() * j.scenePoint;
                                                         var target = (contextTree.pick(pt.y) as Context.ContextTreenode).context;
                                                         var ctx = target;
                                                         var insertionPoint = 0;
                                                         if (not (ctx is Context.GroupContext)) {
                                                             ctx = ctx.parent;
                                                             insertionPoint = 0;
                                                             for (x in (ctx as Context.GroupContext).content) {
                                                                 if (x == target) {
                                                                     insertionPoint = indexof x;
                                                                     break;
                                                                 }
                                                             }
                                                         } 
                                                         if (ctx is Context.GroupContext) {
                                                             var g = ctx as Context.GroupContext;
                                                             insert (Context.ClosureVarContext { varType: asset as TypeAsset, parent: g })
                                                                 before g.content[insertionPoint];
                                                         }
                                                         println("TN ={tn.label} y={pt.y}");
                                                         break;
                                                     } 
                                                 }
                                             }
                                             if (asset is AssetTree.MemberAsset) {
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
                                                     if (j.node is Expression.Canvas) {
                                                         const ma = asset as AssetTree.MemberAsset;
                                                         (j.node as Expression.Canvas).onDrop(j, ma.member);
                                                         break;
                                                     } 
                                                 }
                                             }
					     delete dragger from popupLayer.content;
					     dragger = null;
					 }
				       }
                                     }
				 },
				 Tabview.Tab {
				     title: "Spatial";
				     content:
				     Tabview {
					 tabs:
					 [Tabview.Tab {
					     title: "Inspector";
                                                 content: Scrollpane {
                                                     canZoomVertical: false;
                                                     content: inspector1 = Inspector {
                                                         inspecting: bind Inspector.inspect(if (currentTransform == null) then currentScene else currentTransform);
                                                     }
                                                 }
					  },
					  Tabview.Tab {
					     title: "Hierarchy"
                                             content: Scrollpane {
                                                  canZoomVertical: false;
                                                  content:
                                                  Treeview {
                                                      model: TransformHierarchy.Model {
                                                          h: bind transformHierarchy;
                                                      }
                                                      override function onKeyDown from (e is KeyboardEvent) to ()
                                                      {
                                                          if (e.keyCode == Keys.Delete or
                                                              e.keyCode == Keys.Backspace) {
                                                              if (currentTransform <> null) {
                                                                  const toDelete = currentTransform;
                                                                  transformHierarchy.deleteSelection();
                                                                  deleteResource(toDelete);
                                                              } else {
                                                                  if (transformHierarchy.selectedScene <> mainScene) {
                                                                      delete transformHierarchy.selectedScene from
                                                                          currentScenes;
                                                                  }
                                                              }
                                                          } else super.onKeyDown(e);
                                                      }
                                                      var dragger is TransformNode;
                                                      var clip is Node;
                                                      override function onMouseDrag from (e is MouseEvent) to () {
                                                          if (dragger == null) {
                                                              clip = (selectedTreenode as TransformHierarchy.Treenode).n;
                                                              dragger = TransformNode {
                                                                  pickable: false;
                                                                  content: Group {
                                                                      transform: translate(-e.sceneLocation.x, 0);
                                                                      content: getDragCell();
                                                                  }
                                                              }
                                                              insert dragger into popupLayer.content;
                                                          }
                                                          dragger.tx = editorScene.mousePosition.x;
                                                          dragger.ty = editorScene.mousePosition.y;
                                                      }
                                                      
                                                      override function onMouseUp from (e is MouseEvent) to () 
                                                      {
                                                          for (j in getUnderMouseInEditor()) {
                                                              if (j.node is Expression.Canvas) {
                                                                  (j.node as Expression.Canvas).onDrop(j, clip);
                                                                  break;
                                                              }
                                                          }
                                                          delete dragger from popupLayer.content;
                                                          clip = null;
                                                          dragger = null;
                                                      }
                                                  }
                                              }
					 }]
				     }
				 },
				 Tabview.Tab {
				     title: "Temporal";
				     content:
                                         Tabview {
                                             tabs:
                                             [Tabview.Tab {
                                                     title: "Inspector";
                                                     content: Scrollpane {
                                                         canZoomVertical: false;
                                                         content: inspector2 = Inspector {
                                                             inspecting: bind Inspector.inspect(temporalHierarchy.selectedTransform);
                                                         }
                                                     }
                                                 },
                                                 Tabview.Tab {
                                                     title: "Hierarchy";
                                                     content:
                                                     Scrollpane {
                                                         canZoomVertical: false;
                                                         content:
                                                         Treeview {
                                                             model: TemporalHierarchy.Model {
                                                                 h: bind temporalHierarchy
                                                             }
                                                             override function onKeyDown from (e is KeyboardEvent) to ()
                                                             {
                                                                 if (e.keyCode == Keys.Delete or
                                                                     e.keyCode == Keys.Backspace) {
                                                                     const toDelete = temporalHierarchy.selectedTransform;
                                                                     temporalHierarchy.deleteSelection();
                                                                     deleteAnimResource(toDelete);
                                                                 } else super.onKeyDown(e);
                                                             }
                                                             var dragger is TransformNode;
                                                             var clip is TimeNode;
                                                             override function onMouseDrag from (e is MouseEvent) to () {
                                                                 if (dragger == null) {
                                                                     clip = (selectedTreenode as TemporalHierarchy.Treenode).n;
                                                                     dragger = TransformNode {
                                                                         pickable: false;
                                                                         content: Group {
                                                                             transform: translate(-e.sceneLocation.x, 0);
                                                                             content: getDragCell();
                                                                         }
                                                                     }
                                                                     insert dragger into popupLayer.content;
                                                                 }
                                                                 dragger.tx = editorScene.mousePosition.x;
                                                                 dragger.ty = editorScene.mousePosition.y;
                                                             }
                                                             
                                                             override function onMouseUp from (e is MouseEvent) to () 
                                                             {
                                                                 for (j in getUnderMouseInEditor()) {
                                                                     if (j.node is Expression.Canvas) {
                                                                         (j.node as Expression.Canvas).onDrop(j, clip);
                                                                         break;
                                                                     }
                                                                 }
                                                                 delete dragger from popupLayer.content;
                                                                 clip = null;
                                                                 dragger = null;
                                                             }
                                                         }
                                                     }
					     }]; 
                                           }
                                         },
                                         Tabview.Tab {
				            title: "Eventual";
                                             content:
                                             Tabview {
                                                 tabs:
                                                 [Tabview.Tab {
                                                     title: "Inspector";
                                                     content: Scrollpane {
                                                        canZoomVertical: false;
                                                             content: inspector3 = Inspector {
                                                                 inspecting: bind [Inspector.inspect(otherHierarchy.selectedVariable)];
                                                             }
                                                     }
                                                  },
                                                  Tabview.Tab {
                                                      title: "Hierarchy";
                                                      content:
                                                      Scrollpane {
                                                          canZoomVertical: false;
                                                         content:
                                                         Treeview {
                                                             model: VariableHierarchy.Model {
                                                                 h: bind otherHierarchy
                                                             }
                                                             override function onKeyDown from (e is KeyboardEvent) to ()
                                                             {
                                                                 if (e.keyCode == Keys.Delete or
                                                                     e.keyCode == Keys.Backspace) {
                                                                     const toDelete = otherHierarchy.selectedVariable;
                                                                     otherHierarchy.deleteSelection();
                                                                     //deleteAnimResource(toDelete);
                                                                 } else super.onKeyDown(e);
                                                             }
                                                             var dragger is TransformNode;
                                                             var clip is Context;
                                                             override function onMouseDrag from (e is MouseEvent) to () {
                                                                 if (dragger == null) {
                                                                     clip = (selectedTreenode as VariableHierarchy.Treenode).n;
                                                                     dragger = TransformNode {
                                                                         pickable: false;
                                                                         content: Group {
                                                                             transform: translate(-e.sceneLocation.x, 0);
                                                                             content: getDragCell();
                                                                         }
                                                                     }
                                                                     insert dragger into popupLayer.content;
                                                                 }
                                                                 dragger.tx = editorScene.mousePosition.x;
                                                                 dragger.ty = editorScene.mousePosition.y;
                                                             }
                                                             
                                                             override function onMouseUp from (e is MouseEvent) to () 
                                                             {
                                                                 for (j in getUnderMouseInEditor()) {
                                                                     if (j.node is Expression.Canvas) {
                                                                         (j.node as Expression.Canvas).onDrop(j, clip);
                                                                         break;
                                                                     }
                                                                 }
                                                                 delete dragger from popupLayer.content;
                                                                 clip = null;
                                                                 dragger = null;
                                                             }
                                                         }
                                                     }
                                                  }];
                                             }
                                         }];
                             }
                         }
                     },
		     InternalWindow {
                        id: "Editor2";            
                        gadget: bind trax.combinedGadget;
			containerBounds: bind Bounds.boundsFromRect(0, 
								    0, 
								    width,
								    height-MENU_HEIGHT)
		    	height: 305, width: 820;
			cx: 520, cy: 160;	   
			      //imageLoader: null;
			      content: ResizableStageNode {
			    content: Tabview {
				tabs: 
				[Tabview.Tab {
				    title: "Timeline"
				    content: Scrollpane {
                                             canZoomVertical: false;
                                             content: trax = expr.timeline.Trax {
                                                 clips: bind currentAnimResource.resources;
                                                 loop: bind nonInteractiveLoop;
                                                 target: player;
                                                 targetNode: mainTimeLayer;
                                                 temporalHierarchy: temporalHierarchy;
                                                 removeClip: function from (clip is TimeNode) to ()
                                                 {
                                                     temporalHierarchy.deleteSelection();
                                                     deleteAnimResource(clip);
                                                 }
                                             }
                                         }
				 },
				 Tabview.Tab {
				    title: bind "Event Handler: {contextModel.selectedContext.name}"
				    content: expr.prog.Expression.Editor {
					 //event: bind inspector1.inspecting[inspector1.selectedIndex].member;
                                         stepping: bind stepping;
                                         eventContext: bind contextModel.selectedMemberContext;
                                         targetObject: bind contextModel.selectedObjectContext.getTarget();
					 targetSpace: bind currentScene.root;
                                         instanceSpace: bind currentScene.instanceSpace;
					 targetTime: bind mainTimeLayer;
                                         targetTimeline: bind player;
                                         popupLayer: bind popupLayer;
                                         popupScene: bind editorScene;
                                         interactive: function from () to Boolean { interactive } 
				    }
				 }]
			    }
                        }
		    }]
                   },
	    toolMenu, 
            sceneMenu,
            popupLayer]
        };

     function saveChangesIfNecessary to Boolean 
     {
         if (fileDirty()) {
             var doSave = true;
             if (mainScene.currentResource.url == "") {
                 yesNo.title = "Tool";
                 yesNo.message = "Save Changes?";
                 var cancel is Boolean = false;
                 yesNo.onCancel = function to () { cancel = true }
                 yesNo.onNo = function to () { doSave = false } 
                 yesNo.onYes = function to () { }
                 yesNo.open();
                 if (cancel) return false;
             }
             if (doSave) {
                 if (not save()) {
                     return false;
                 }
             }
         }
         return true;
     }
    
     function joglStage to JoglStage {
         stage
     }
     
     var stage is JoglStage = JoglStage {

        defaultCursor: bind toolCursor;
        /*
        content: CachedScene {
             scene: bind [currentScenes, manipLayer, editorScene];
        }
        */
        content: bind [currentScenes, manipLayer, editorScene];
	
        onClose: function from () to Boolean {
            if (not saveChangesIfNecessary()) {
                return false;
            }
            saveEditorState(editorScene, player, trax);
            return true;
        }
        title: bind "{mainScene.currentResource.url} {if (savePoint <> MasterUndoable.now) then " (Unsaved)" else ""}";
        menubar: Menu.Bar {
	    menus: 
	    [Menu 
             { 
		 label: "File";
		 shortcut: Menu.Shortcut { keyCode: Keys.F }
		 items:
		 [MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.O }
		     label: "Open...";
                     enabled: bind player.paused;
		     action: function {
                             if (saveChangesIfNecessary()) {
                                 const result = fileOpen.open();
                                 if (result <> null) {
                                     open("file:{result}");
                                 }
                             }
                     }
                 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.S }
		     label: "Save As...";
		     enabled: true;//bind mainScene.currentResource.url == ""
		     action: function {
                         if (mainScene.currentResource.url <> "") {
                             const u = new java.net.URL(mainScene.currentResource.url);
                             fileSave.fileName = new java.io.File(u.getFile()).getName();
                         } else {
                             fileSave.fileName = "";
                         }
                         fileSave.title = "Save As";
			 var result = fileSave.open();
			 if (result <> null) {
                             if (not result.endsWith(".expr")) {
                                 result = "{result}.expr";
                             }
			     mainScene.currentResource.url = "file:{result}";
			     save();
			 }
		     }
		 },
                 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.W }
		     label: "Close";
                     enabled: bind player.paused;
		     action: function {
                         if (saveChangesIfNecessary()) {
                             close();
                         }
                     }
                 },
                 MenuItem {
		     label: "Export...";
                     enabled: bind player.paused and mainScene.currentResource.url <> "";
		     action: doExport;
                 }]
             },
	     Menu 
             { 
		 shortcut: Menu.Shortcut { keyCode: Keys.E }
		 label: "Edit"
		 items:
		 [MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.X }
		     label: "Cut"
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.C }
		     label: "Copy"
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.V }
		     label: "Paste"
		 }
                 Menu.Separator {},
		 MenuItem {
		     label: "Undo";
		     enabled: bind canUndo;
		     shortcut: Menu.Shortcut { keyCode: Keys.Z }
		     action: MasterUndoable.undo
		 },
		 MenuItem {
		     label: "Redo";
		     enabled: bind canRedo;
		     shortcut: Menu.Shortcut { keyCode: Keys.Z, shiftKey: yes }
		     action: MasterUndoable.redo
		 }]
	     }]
	     
	}

	height: 800, width: 1020;
	
    }

    function setCamera from (i is Integer) to ()
    {
	/*
	if (i == 0) {
	    currentCamera = camera;
	} else if (i == 9) {
	    currentCamera = Camera2D {};
	} else {
	    const cam = model.getCameras()[i-1];
	    if (cam <> null) {
		currentCamera = cam;
	    }
	}
	println("camera={camera.tx}, {camera.ty}, {camera.tz}");
	*/
    }

    function deleteAnimResource from (n is TimeNode) to () 
    {
        var x = n;
        n.updateParent();
        while (x <> null) {
        println("DELETE {x.getClass()} => {x}");
            if (x is ResourceTimeNode) {
                const rn = x as ResourceTimeNode;
                rn.foldLeft((), function from (_ is (), n is TimeNode) to () {
                        n.pause();
                    });
                if (x.parent is ResourceTimeGroup) {
                    delete (x as ResourceTimeNode) from (x.parent as ResourceTimeGroup).resources;
                } else {
                    delete x from (x.parent as TimeGroup).content;
                }
                return;
            }
            x = x.parent;
        }
    }

    function deleteResource from (n is Node) to () {
	if (n is ResourceNode) {
	    const rn = n as ResourceNode;
	    delete n as ResourceNode from currentResource.resources;
	    if (rn.temporal <> null) {
		delete rn.temporal from currentAnimResource.resources;
		//trax.setClips(currentAnimResource.resources);
	    }
	}
    }

    function setClip from (i is Integer) to ()
    {
	//currentResource.setClip(i);
    }

    stage.addMouseInputHandler(MouseInputHandler.Delegate { 
            delegate: viewer;
            override function onMouseWheel from (event is MouseWheelEvent) to ()
            {
                if (editorScene.underMouse == []) {
                    delegate.onMouseWheel(event);
                }
            }
        });
    stage.addKeyboardInputHandler(KeyboardInputHandler {

	    override function onKeyInput from (event is KeyboardEvent) to () 
	    {
		if (event.keyChar == "-" or event.keyChar == "_") {
		    manip.shrink();
		} else if (event.keyChar == "+" or event.keyChar == "=") {
		    manip.expand();
		}
	    }
		
	    override function onKeyUp from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    if (event.keyCode == Keys.D) {
			manip.exitPivotMode();
		    }
		}
	    }

	    override function onKeyDown from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    println("event={event}");
		    if (event.keyCode == Keys.Delete or event.keyCode == Keys.Backspace) {
			//const toDelete = currentTransform;
			//transformHierarchy.deleteSelection();
			//deleteResource(toDelete);
		    } else if (event.keyCode == Keys.D) {
			manip.enterPivotMode();
			/* } else if (event.keyCode == Keys.Z and event.metaKey) {
			if (event.shiftKey) {
			    MasterUndoable.redo();
			} else {
			    MasterUndoable.undo();
			    }*/
		    } else if (event.keyCode == Keys.G) {
                        java.lang.System.gc();
                        println("{java.lang.Runtime.getRuntime().freeMemory()} / {java.lang.Runtime.getRuntime().totalMemory()}");
		    } else if (event.keyCode == Keys.F) {
                        if (currentScene == mainScene) {
                            viewer.focusCamera(currentTransform);
                        }
		    } else if (event.keyCode >= Keys._0 and event.keyCode <= Keys._9) {
			const index = event.keyCode - Keys._0;
			if (event.metaKey) {
			    setClip(index);
			} else {
			    setCamera(index);
			}
		    } else if (event.keyCode == Keys.G) {
			java.lang.System.gc();
			//showMemory = not showMemory;
		    }
		}
	    }
	});

    stage.addDnDInputHandler(DnDInputHandler {
	    override function onDrop from (event is DropEvent) to () 
	    {
		const url = event.url;
		event.accept();
		try {
		    const checkProtocol = new java.net.URL(url);
                    const pt = currentScene.camera.toScene(event.screenx, event.screeny);
                    println("DROP on SCENE {event.screenx}, {event.screeny} => {pt} ");
		    doDrop(url, pt);
		} catch (exception is java.lang.Exception) {
		    exception.printStackTrace();
		}
	    }
	});
    doUpdate = DefaultObserver of (()) {
        override function onNext from (_ is ()) to () {
            (the SoundLoader).update();
            canUndo = MasterUndoable.canUndo();
            canRedo = MasterUndoable.canRedo();
            for (z in currentScenes) {
                z.instanceSpace.content = z.instanceSpace.content[ x | { var y = x as EventLayer.EventNode; y.timestamp <= player.playhead }];
            }
        }
    };
    currentScenes = [mainScene];
    undoList.addTarget("currentScenes", &currentScenes);
    transformHierarchy.selectedScene = mainScene;
    println("SET MAIN SCENE {transformHierarchy.selectedScene}");
    stage.invoke(function {
	    //viewer.focusCamera(currentTransform);
	});
    stage.observeUpdate().subscribe(doUpdate);
    MasterUndoable.commit();
}




