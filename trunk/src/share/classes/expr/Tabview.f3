package expr;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import f3.math.LinearMath.*;
import java.lang.Math;
import f3.media.input.*;

const BG = Color.color(.48, .48, .48);
const FG = Color.color(.9, .9, .9);
const TEXT_COLOR = Color.color(.2, .2, .2);

const FG_PAINT is Paint = ColorPaint(FG);
const BG_PAINT is Paint = ColorPaint(BG);
const TEXT_PAINT is Paint = ColorPaint(TEXT_COLOR);
const BLACK_PAINT is Paint = ColorPaint(Color.BLACK);


const TAB_HEIGHT = 15;

public class Tab {
    public var title is String;
    protected var index is Integer;
    public var content is ResizableNode;
    public var onSelect is function from () to ();
    public var onLoseSelection is function from () to ();
}

class TabImpl is TransformNode, MouseInputHandler, Focuser {
    public var tab is Tab;
    public var tabview is Tabview;
    override function onMouseDown from (e is MouseEvent) to ()
    {
	tabview.selectedIndex = tab.index;
    }
    override public function getTargetOfFocus to Focusable {
	if (tab.content is Focuser) then (tab.content as Focuser).getTargetOfFocus() else null;
    }
}

public class Tabview is ResizableNode, Focuser {

    override public function getTargetOfFocus to Focusable 
    {
	if (selectedTab.content is Focuser) then (selectedTab.content as Focuser).getTargetOfFocus() else null;
    }

    override function resize from (w is Number, h is Number) to ()
    {
	super.resize(w, h);
	selectedTab.content.resize(contentWidth, contentHeight);
    }
    public var selectedIndex is Integer = 0;
    public var tabs is Tab[];
    public bound var selectedTab is Tab = tabs[selectedIndex];

    var contentWidth is Number = bind width;
    var contentHeight is Number = bind height - TAB_HEIGHT-2;

    bound var font is Text.Font = layoutEngine.createFont(Names.DEFAULT_FONT);

    var tabWidth is Number = bind Math.max(minTabWidth, width / Math.max(tabs.size(), 1));

    var minTabWidth is Number;

    bound var labels is Text.Label[] = foreach (t in tabs) Text.Label {
	font: bind font;
	blocksPointer: false;
	indent: 5;
	height: bind TAB_HEIGHT;
        width: bind tabWidth;
	background: null;
	foreground: bind TEXT_PAINT;
	text: bind t.title;
    };

    var lastSelected is Tab;

    override function update to ()
    {
	super.update();
	if (lastSelected <> selectedTab) {
            lastSelected.onLoseSelection();
	    lastSelected = selectedTab;
            selectedTab.onSelect();
	}
        for (t in tabs) {
            t.content.resize(contentWidth, contentHeight);
        }
        selectedTab.content.resize(contentWidth, contentHeight);
	var maxLabelWidth = 0.0;
	for (tab in tabs) { tab.index = indexof tab }
	for (label in labels) {
	    const w = label.font.width(label.text) + 6;
            maxLabelWidth = Math.max(maxLabelWidth, w);
	}
	minTabWidth = maxLabelWidth;
    }

    var tabLabels is TabImpl[] = bind foreach (t in tabs) {
	TabImpl {
	    tabview: this;
	    tab: t;
	    tx: bind tabWidth * t.index
	    content: 
	    [Rectangle {
		    height: TAB_HEIGHT+2;
		    width: bind tabWidth+0.5;
		    fillPaint: bind if (t == selectedTab) then FG_PAINT else BG_PAINT;
		    strokePaint: bind if (t == selectedTab) then FG_PAINT else BLACK_PAINT;
		},
		Group { content: bind labels[t.index] }]
	}
    }
	
    override var internalContent = TransformNode {
	content:
	[TransformNode {
            tx: bind -width / 2 + tabWidth/2;
	    //tx: bind -tabWidth/2;
	    ty: bind contentHeight / 2-1;
            content: bind tabLabels;
	},
	TransformNode {
	    ty: bind -TAB_HEIGHT/2-2;
	    content: Content {
               override var scissorBounds = bind Bounds.boundsFromRect(-contentWidth/2, -contentHeight/2, contentWidth, contentHeight);
               content: bind selectedTab.content
            }
	}];
    }
}

class Content is Group, Scissored {}