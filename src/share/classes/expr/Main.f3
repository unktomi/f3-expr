package expr;
import f3.jogl.awt.JoglStage;
import f3.jogl.awt.JoglStage.*;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.util.Bits;
import f3.media.scene.*;
import f3.media.input.*;
import f3.media.svg.SVG;
import java.lang.Math;
import expr.choices.SliderField;
import expr.undo.*;

public class ResourceGroup is TransformNode {
    public var url is String;
    public var resources is ResourceNode[];
    override var content = bind resources;
    public var currentClip is TimeNode;
    const undoList = UndoList {};
    postinit {
	undoList.addTarget("resourceNodes", &resources);
    }
}

public class ResourceTimeGroup is TimeGroup {
    public var url is String;
    public var resources is ResourceTimeNode[];
    override var content = bind resources;
    const undoList = UndoList {};
    postinit {
	undoList.addTarget("resourceTimeNodes", &resources);
    }
}

class ResizableStageNode is ResizableNode {
    const stage is StageNode = StageNode {
	depthBits: 0
	content: Scene {
	    camera: Camera2D { tx: bind -width / 2.0, ty: bind -height / 2.0}
	    content: bind content
	}
    }
    override function resize from (x is Number, y is Number) to ()
    {
	super.resize(x, y);
	stage.resize(x as Integer, y as Integer);
	content.resize(stage.width, stage.height);
    }
    override var internalContent = bind stage;
    public var content is ResizableNode;
}

function readTextFile from (url is String) to (String, Integer)
{
    const u = new java.net.URL(url);
    const reader = new java.io.BufferedReader(new java.io.InputStreamReader(u.openStream()));
    var line is Object;
    var buf = new java.lang.StringBuffer;
    var lineCount = 0;
    while ((line = reader.readLine()) <> null) {
	buf.append(line);
	buf.append("\n");
	lineCount++;
    }
    return (buf.toString(), lineCount);

}

public function run from (args is String[]) to ()
{

    const currentResource is ResourceGroup = ResourceGroup {
    }
    const currentAnimResource is ResourceTimeGroup = ResourceTimeGroup {
    }
    const transformHierarchy = TransformHierarchy {
	root: bind currentResource;
    }
    var currentCamera is Camera;
    var TheWebBrowserFactory is AbstractWebBrowserFactory;
    try {
	const clazz = 
	    java.lang.Class.forName("f3.media.web.awesomium.AwesomiumWebBrowserFactory") as java.lang.Class of AbstractWebBrowserFactory;
	TheWebBrowserFactory = clazz.newInstance();
	    
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load awesomium web browser factory");
    }

    println("args={args}");

    var playerUrl is String;

    const mainTimeLayer = TimeLayer {
	content: bind currentAnimResource;
	playCount: -1;
    }

    const player = Timeline {
	paused: true;
	content: mainTimeLayer;
    }

    const camera = PerspectiveCamera {
        id: "free";
	ty: 3.0;
	tz: 13;
	near: 1;
	far: 100;
	content: PointLight {}
    }

    const viewer = DefaultExaminerViewer {
	camera: camera;
    }

    const browser = if TheWebBrowserFactory == null then null else WebBrowser {
	//factory: TheWebBrowserFactory;
	//effectLoader: CGEffectLoader_INSTANCE;
	//pathFactory: ThePath2DFactory;
    }

    const disp = transformHierarchy.observeSelection().subscribe(function from (n is Node) to () {
	});
    
    function addResource from (rn is ResourceNode) to ()
    {
	insert rn into currentResource.resources;
	transformHierarchy.selectNode(rn);
	viewer.focusCamera(rn);
    }

    function addTimeResource from (rn is ResourceTimeNode) to ()
    {
	insert rn into currentAnimResource.resources;
	trax.setClips(currentAnimResource.resources);
	trax.selectClip(rn);
    }


    function doDrop from (url is String) to () 
    {
	stage.title = url;
	playerUrl = url;
	if (url.endsWith(".ma")) {
	    const model = Ma.Model {
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind model.getSpatialRoot();
	    }
	    addResource(rn);
	    const rtn = ResourceTimeNode {
		url: url;
		content: bind model.getTemporalRoot();
		spatial: rn;
	    }
	    rn.temporal = rtn;
	    addTimeResource(rtn);
	} else if (url.endsWith(".svg")) {
	    const svg = SVG {
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind svg.root;
	    }	
	    addResource(rn);
	} else if (url.endsWith(".png") or url.endsWith(".jpg") or url.endsWith(".tif") or url.endsWith(".tiff") or url.endsWith(".tga")) {
	    const image= Image { 
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: image;
	    }	
	    addResource(rn);
	} else {
	    const browser = WebBrowser {
		url: url
	    }
	    const rn = ResourceNode {
		url: url;
		content: browser;
	    }
	    addResource(rn);
	}
	MasterUndoable.commit();
    }

    var trax is expr.timeline.Trax;
    var currentTransform = bind transformHierarchy.selectedTransform;
    currentCamera = camera;

    const mainScene = Scene {
	background: Color.GRAY;
	override var camera = bind currentCamera on invalidate {
	    println("scene camera invalidated {currentCamera}");
	}
	content: bind transformHierarchy.root;
	override function injectMouseDown from (event is MouseEvent) to ()
	{
	    super.injectMouseDown(event);
	    for (i in underMouse) {
		println("{i.node}");
		if (i.node is MeshNode) {
		    var p = i.node.parent;
		    while (p <> null) {
			if (p is ResourceNode) {
			    transformHierarchy.selectNode(p);
			    return;
			}
			p = p.parent;
		    }
		}
	    }
	}
    }

    var toolMenu = expr.toolmenu.ToolMenu {
	transform: bind translate(stage.width /2, 
				  stage.height - 10);
	height: 20;
	width: bind stage.width;
	pause: &player.paused;
	onRewind: player.setPlayhead.apply(0s);
    };
    
    var manip is expr.manipulator.Manipulator;

    var stage is JoglStage = JoglStage {
        menubar: Menu.Bar {
	    menus: 
	    [Menu 
             { 
		 label: "File";
		 items:
		 [MenuItem {
		     label: "Open";
		 },
		 MenuItem {
		     label: "Save";
		 },
		 MenuItem {
		     label: "Save As";
		 },
		 Menu.Separator {},
		 MenuItem {
		     label: "Quit";
		 }]
	     },
	     Menu 
             { 
		 label: "Edit";
		 items:
		 [MenuItem {
		     label: "Cut"
		 },
		 MenuItem {
		     label: "Copy"
		 },
		 MenuItem {
		     label: "Paste"
		 }]
	     }]
	     
	}
	height: 800, width: 1020;
	title: new java.io.File(args[0]).getName();
	content: [mainScene,
		  Scene {
                      background: null;
                      camera: camera;
		      override var content = manip = expr.manipulator.Manipulator 
		      {
			  visible: bind currentTransform <> null;
                          viewer: viewer;
			  target: bind currentTransform;
			  scene: this;
		      }
                  },
		  Scene {
                    background: null;
                    camera: Camera2D {}; 
		    override var content =
		    [InternalWindow {
			    containerBounds: bind Bounds.boundsFromRect(0, 
									0, 
									width,
									height-toolMenu.bounds.height())
		    	height: 150, width: 820;
			cx: 520, cy: 100;	   
			      //imageLoader: null;
			      //content: ResizableStageNode {
			    
			    content: trax = expr.timeline.Trax {
				      target: player;
				      targetNode: mainTimeLayer;
				  };
			      // }
		    },
		    toolMenu]
                  }]
    }

    function setCamera from (i is Integer) to ()
    {
	/*
	if (i == 0) {
	    currentCamera = camera;
	} else if (i == 9) {
	    currentCamera = Camera2D {};
	} else {
	    const cam = model.getCameras()[i-1];
	    if (cam <> null) {
		currentCamera = cam;
	    }
	}
	println("camera={camera.tx}, {camera.ty}, {camera.tz}");
	*/
    }

    function deleteResource from (n is Node) to () {
	if (n is ResourceNode) {
	    const rn = n as ResourceNode;
	    delete n as ResourceNode from currentResource.resources;
	    if (rn.temporal <> null) {
		delete rn.temporal from currentAnimResource.resources;
		trax.setClips(currentAnimResource.resources);
	    }
	}
    }

    const setClip = function from (i is Integer) to ()
    {
	//currentResource.setClip(i);
    }

    stage.addMouseInputHandler(viewer);
    stage.addKeyboardInputHandler(KeyboardInputHandler {

	    override function onKeyInput from (event is KeyboardEvent) to () 
	    {
		if (event.keyChar == "-" or event.keyChar == "_") {
		    manip.shrink();
		} else if (event.keyChar == "+" or event.keyChar == "=") {
		    manip.expand();
		}
	    }
		
	    override function onKeyUp from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    if (event.keyCode == Keys.D) {
			manip.exitPivotMode();
		    }
		}
	    }

	    override function onKeyDown from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    println("event={event}");
		    if (event.keyCode == Keys.Delete or event.keyCode == Keys.Backspace) {
			const toDelete = currentTransform;
			transformHierarchy.deleteSelection();
			deleteResource(toDelete);
		    } else if (event.keyCode == Keys.D) {
			manip.enterPivotMode();
		    } else if (event.keyCode == Keys.Z and event.metaKey) {
			if (event.shiftKey) {
			    MasterUndoable.redo();
			} else {
			    MasterUndoable.undo();
			}
		    } else if (event.keyCode == Keys.F) {
			viewer.focusCamera(currentTransform);
		    } else if (event.keyCode >= Keys._0 and event.keyCode <= Keys._9) {
			const index = event.keyCode - Keys._0;
			if (event.metaKey) {
			    setClip(index);
			} else {
			    setCamera(index);
			}
		    } else if (event.keyCode == Keys.G) {
			java.lang.System.gc();
			//showMemory = not showMemory;
		    }
		}
	    }
	});
    stage.addDnDInputHandler(DnDInputHandler {
	    override function onDrop from (event is DropEvent) to () 
	    {
		const url = event.url;
		event.accept();
		try {
		    const checkProtocol = new java.net.URL(url);
		    doDrop(url);
		} catch (exception is java.lang.Exception) {
		    exception.printStackTrace();
		}
	    }
	});

    stage.invoke(function {
	    //viewer.focusCamera(currentTransform);
	});

}




