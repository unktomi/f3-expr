package expr;
import f3.jogl.awt.JoglStage;
import f3.jogl.awt.JoglStage.*;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.util.Bits;
import f3.media.scene.*;
import f3.media.input.*;
import f3.media.svg.SVG;
import java.lang.Math;
import expr.choices.SliderField;
import expr.undo.*;
import expr.inspector.*;
import expr.inspector.Inspector.*;
import expr.ResourceNode.*;
import expr.AssetTree.*;
import expr.timeline.*;
import expr.prog.*;

public class InternalWindowState {
    public var id is String;
    public var cx is Number;
    public var cy is Number;
    public var width is Number;
    public var height is Number;
}

public class EditorState {
    public var windowWidth is Integer;
    public var windowHeight is Integer;
    public var internalWindows: InternalWindowState[];
}


function saveEditorState from (scene is Scene) to () {
    var internalWindows is InternalWindowState[];
    const f is function from ((), Node) to () 
        = function from (_ is (), n is Node) to ()
        {
            if (n is InternalWindow) {
                const w = n as InternalWindow;
                insert InternalWindowState {
                    id: w.id;
                    cx: w.cx;
                    cy: w.cy;
                    width: w.width;
                    height: w.height;
                } into internalWindows;
            }
        };
    scene.root.foldLeft((), f);
    const w = new java.io.BufferedWriter(new java.io.FileWriter(".expr.editorstate"));
    IO.writeObject(w, EditorState {
            windowHeight: scene.stage.height+21;
            windowWidth: scene.stage.width;
            internalWindows: internalWindows;
        });
    w.flush();
    w.close();
}

function loadEditorState from (scene is Scene) to () {
    const file = new java.io.File(".expr.editorstate");
    if (file.exists()) {
        const s = IO.readObject(new java.io.BufferedReader(new java.io.FileReader(file))) as EditorState;
        const f is function from ((), Node) to () 
            = function from (_ is (), n is Node) to ()
        {
            if (n is InternalWindow) {
                const w = n as InternalWindow;
                for (x in s.internalWindows) {
                    if (x.id == w.id) {
                        w.cx = x.cx;
                        w.cy = x.cy;
                        w.width = x.width;
                        w.height = x.height;
                        break;
                    }
                }
            }
        };
        scene.root.foldLeft((), f);
        if (s.windowHeight <> 0 and s.windowWidth <> 0) {
            (scene.stage as JoglStage).resizeWindow(s.windowWidth, s.windowHeight);
        }
    }
}


class CachedScene is Scene {
    public var scene is Scene;
    override var camera = Camera2D {tx: bind -scene.width/2, ty: bind -scene.height/2}
    var stageNode is StageNode = StageNode {
	content: scene;
    }
    override function update {
	if (stageNode.width <> width or stageNode.height <> height) {
	    stageNode.resize(width, height);
	}
	super.update();
    }
    override var content = bind stageNode;
}

class ResizableStageNode is ResizableNode, Focuser {
    const stage is StageNode = StageNode {
        background: Color.GRAY;
	content: Scene {
            background: Color.GRAY;
	    camera: Camera2D {tx: bind Math.round(-width / 2.0), ty: bind Math.round(-height / 2.0) }
	    content: bind content;
	}
    }
    override function resize from (w0 is Number, h0 is Number) to ()
    {
	const w = Math.ceil(w0);
	const h = Math.ceil(h0);
	super.resize(w, h);
	content.resize(w, h);
	stage.resize(w as Integer, h as Integer);
    }
    override var internalContent = Group { content: bind stage };
    public var content is ResizableNode;
    override public function getTargetOfFocus to Focusable {
	return stage;
    }
}

function readTextFile from (url is String) to (String, Integer)
{
    const u = new java.net.URL(url);
    const reader = new java.io.BufferedReader(new java.io.InputStreamReader(u.openStream()));
    var line is Object;
    var buf = new java.lang.StringBuffer;
    var lineCount = 0;
    while ((line = reader.readLine()) <> null) {
	buf.append(line);
	buf.append("\n");
	lineCount++;
    }
    return (buf.toString(), lineCount);

}

public class MainContext is Context.GroupContext {
    public var currentEvent is Context;
    override bound function getContent to Context[] {
        [currentEvent, content]
    }
}

public function run from (args is String[]) to ()
{
    var currentEventContext = bind Context.MemberContext {
        member: inspector1.inspecting[inspector1.selectedIndex].member;
    };

    var mainContext is Context = MainContext {
        name: "main";
        currentEvent: bind currentEventContext;
    }

    var contextModel is Context.ContextTreemodel = Context.ContextTreemodel {
        rootContext: bind mainContext;
    } 

    const currentResource is ResourceGroup = ResourceGroup {
	id: "Spatial Hierarchy";
    }
    const currentAnimResource is ResourceTimeGroup = ResourceTimeGroup {
	id: "Temporal Hierarchy";
    }
    const transformHierarchy = TransformHierarchy {
	root: bind currentResource;
    }
    const temporalHierarchy = TemporalHierarchy { root: bind currentAnimResource }
    var currentCamera is Camera;
    var TheWebBrowserFactory is AbstractWebBrowserFactory;
    try {
	const clazz = 
	    java.lang.Class.forName("f3.media.web.awesomium.AwesomiumWebBrowserFactory") as java.lang.Class of AbstractWebBrowserFactory;
	TheWebBrowserFactory = clazz.newInstance();
	    
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load awesomium web browser factory");
    }

    println("args={args}");

    var playerUrl is String;

    const mainTimeLayer = TimeGroup {
	id: "Hierarchy";
	content: bind currentAnimResource;
	playRange: bind if (loop) then null else Interval { start: 0s, end: Duration.INDEFINITE };
	playCount:  bind if (loop) then -1 else 1;
    }

    const player = Timeline {
	paused: true;
	content: mainTimeLayer;
    }

    const camera = PerspectiveCamera {
        id: "free";
	ty: 3.0;
	tz: 13;
	near: 1;
	far: 100;
	content: PointLight {}
    }

    const viewer = DefaultExaminerViewer {
	camera: camera;
    }

    const browser = if TheWebBrowserFactory == null then null else WebBrowser {
	//factory: TheWebBrowserFactory;
	//effectLoader: CGEffectLoader_INSTANCE;
	//pathFactory: ThePath2DFactory;
    }

    const disp = transformHierarchy.observeSelection().subscribe(function from (n is Node) to () {
	});
    
    function addResource from (rn is ResourceNode) to ()
    {
	insert rn into currentResource.resources;
	transformHierarchy.selectNode(rn);
	viewer.focusCamera(rn);
        insert Context.AssetContext { asset: AssetTree.makeAsset(rn) } into contextModel.selectedGroupContext.content;
        println("added asset to context { contextModel.selectedContext }");
    }

    function addTimeResource from (rn is ResourceTimeNode) to ()
    {
	insert rn into currentAnimResource.resources;
    }


    function doDrop from (url is String) to () 
    {
	playerUrl = url;
	if (url.endsWith(".expr")) {
	    const model = ExprNode {
                webBrowserFactory: TheWebBrowserFactory
		url: url;
	    }
	    const rn = ResourceNode {
                url: url;
                content: bind model.spatialRoot;
	    }
	    addResource(rn);
	    const rtn = ResourceTimeNode {
		url: url;
		content: bind model.temporalRoot;
		spatial: rn;
	    }
	    if (rtn.bounds.duration() > 0s) {
		rn.temporal = rtn;
		addTimeResource(rtn);
	    }
	} else if (url.endsWith(".ma")) {
	    const model = Ma.Model {
		url: url;
	    }
	    const rn = MaResourceNode {
	        model: model;
	    }
	    addResource(rn);
	    const rtn = ResourceTimeNode {
		url: url;
		content: bind model.getTemporalRoot();
		spatial: rn;
	    }
	    if (rtn.bounds.duration() > 0s) {
		rn.temporal = rtn;
		addTimeResource(rtn);
	    }
	} else if (url.endsWith(".svg")) {
	    const svg = SVG {
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: bind svg.root;
	    }	
	    addResource(rn);
	} else if (url.endsWith(".png") or url.endsWith(".jpg") or url.endsWith(".tif") or url.endsWith(".tiff") or url.endsWith(".tga")) {
	    const image= Image { 
		url: url;
	    }
	    const rn = ResourceNode {
		url: url;
		content: image;
	    }	
	    addResource(rn);
	} else {
	    const browser = WebBrowser {
		url: url
	    }
	    const rn = ResourceNode {
		url: url;
		content: browser;
	    }
	    addResource(rn);
	}
	MasterUndoable.commit();
    }

    var trax is expr.timeline.Trax;
    var inspector1 is Inspector;
    var inspector2 is Inspector;
    var currentTransform = bind transformHierarchy.selectedTransform;
    currentCamera = camera;

    var canUndo is Boolean;
    var canRedo is Boolean;
    var savePoint is Integer;

    var editorScene is Scene;
    var internalWindowsLayer is Group;
    var popupLayer = Group {};

    function getUnderMouseInEditor to Pick[] 
    {
	var result is Pick[];
	foreach (x in editorScene.underMouse) {
	    insert x into result;
	    if (x.node is StageNode) {
		for (y in (x.node as StageNode).content) {
		    insert y.underMouse into result;
		}
	    }
	}
	return result;
    }

    const mainScene = Scene {
    	override function update { 
	    super.update();
	    canUndo = MasterUndoable.canUndo();
	    canRedo = MasterUndoable.canRedo();
	}
	background: Color.GRAY;
	override var camera = bind currentCamera on invalidate {
	    println("scene camera invalidated {currentCamera}");
	}
	content: bind transformHierarchy.root;
	override function injectMouseDown from (event is MouseEvent) to ()
	{
	    super.injectMouseDown(event);
	    for (i in underMouse) {
		println("{i.node}");
		if (i.node is MeshNode) {
		    var p = i.node.parent;
		    while (p <> null) {
			if (p is ResourceNode) {
			    transformHierarchy.selectNode(p);
			    return;
			}
			p = p.parent;
		    }
		}
	    }
	}
    }

    const cachedScene = CachedScene {
        background: null;
	scene: mainScene;
    }

    var loop is Boolean = true;
    var full is Boolean = false;

    const toolMenu is expr.toolmenu.ToolMenu = expr.toolmenu.ToolMenu {
    	transform: bind translate(stage.width /2, stage.height - 10);
	height: 20;
	width: bind stage.width;
	pause: &player.paused;
	onRewind: player.setPlayhead.apply(0s);
	onHideFloating: function from (b is Boolean) to ()
	{
	    internalWindowsLayer.visible = b;
	}
	toggleLoop: function { loop = not loop; () }
	toggleFullscreen: function { full = not full; stage.setFullscreen(full) }
    };
    
    var manip is expr.manipulator.Manipulator;

    function save {
	savePoint = MasterUndoable.now;
	Resources.save(currentResource.url,
		       mainScene,
		       currentResource,
		       currentAnimResource);
    }
    
    function close from () to () {
	savePoint = 0;
	currentResource.resources = [];
	currentAnimResource.resources = [];
	transformHierarchy.clearSelection();
	MasterUndoable.reset();
    }

    const undoList = expr.undo.UndoList {} on replace {
	undoList.addTarget("nodes", &currentResource.resources);
	undoList.addTarget("timenodes", &currentAnimResource.resources);
    }


    function open from (url is String) to ()
    {
	close();
	currentResource.url = url;
	const sceneRes = Resources.open(currentResource.url);
	for (i in sceneRes.spatialResources) {
	    doDrop(i.url);
	    currentTransform.tx = i.tx;
	    currentTransform.ty = i.ty;
	    currentTransform.tz = i.tz;

	    currentTransform.sx = i.sx;
	    currentTransform.sy = i.sy;
	    currentTransform.sz = i.sz;

	    currentTransform.rx = i.rx;
	    currentTransform.ry = i.ry;
	    currentTransform.rz = i.rz;

	    currentTransform.px = i.px;
	    currentTransform.py = i.py;
	    currentTransform.pz = i.pz;
	}
	for (i in sceneRes.temporalResources, j in currentAnimResource.resources) {
	    if (i.url == j.url) {
		j.playTime = i.playTime;
		j.playRate = i.playRate;
		j.playCount = i.playCount;
	    }
	}
	//trax.setClips(currentAnimResource.resources);
	MasterUndoable.reset();
	MasterUndoable.commit();
	savePoint = MasterUndoable.now;
    }

    const fileSave = FileDialog.FileSave {
    }

    const fileOpen = FileDialog.FileOpen {
	filterExtensions: [".expr"]
    }

    function fileDirty to Boolean {
	MasterUndoable.canUndo();
    }

    var stage is JoglStage = JoglStage {
        onClose: function from () to Boolean {
            if (fileDirty()) {
                save();
            }
            saveEditorState(editorScene);
            return true;
        }
        title: bind "{currentResource.url} {if (savePoint <> MasterUndoable.now) then " (Unsaved)" else ""}";
        menubar: Menu.Bar {
	    menus: 
	    [Menu 
             { 
		 label: "File";
		 shortcut: Menu.Shortcut { keyCode: Keys.F }
		 items:
		 [MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.O }
		     label: "Open";
		     action: function {
			 const result = fileOpen.open();
			 if (result <> null) {
			     if (fileDirty()) {
				 save();
			     }
			     open("file:{result}");
			 }
		     }
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.S }
		     label: "Save";
		     enabled: bind currentResource.url <> ""
		     action: save;
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.A }
		     label: "Save As";
		     enabled: bind currentResource.url == ""
		     action: function {
			 fileSave.fileName = currentResource.url;
			 const result = fileSave.open();
			 if (result <> null) {
			     currentResource.url = "file:{result}";
			     save();
			 }
		     }
		 }]
	     },
	     Menu 
             { 
		 shortcut: Menu.Shortcut { keyCode: Keys.E }
		 label: "Edit"
		 items:
		 [MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.X }
		     label: "Cut"
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.C }
		     label: "Copy"
		 },
		 MenuItem {
		     shortcut: Menu.Shortcut { keyCode: Keys.V }
		     label: "Paste"
		 }
                 Menu.Separator {},
		 MenuItem {
		     label: "Undo";
		     enabled: bind canUndo;
		     shortcut: Menu.Shortcut { keyCode: Keys.Z }
		     action: MasterUndoable.undo
		 },
		 MenuItem {
		     label: "Redo";
		     enabled: bind canRedo;
		     shortcut: Menu.Shortcut { keyCode: Keys.Z, shiftKey: true }
		     action: MasterUndoable.redo
		 }]
	     }]
	     
	}

	height: 800, width: 1020;
	
	content: [cachedScene,
		  Scene {
                      background: null;
                      camera: camera;
		      override var content = manip = expr.manipulator.Manipulator 
		      {
			  visible: bind currentTransform <> null;
                          viewer: viewer;
			  target: bind currentTransform;
			  scene: this;
		      }
                  },
		  editorScene = Scene {
                    var lastTime is Long;
                    override function update {
                        const now = java.lang.System.currentTimeMillis();
                        if (lastTime == 0) {
                            loadEditorState(this);
                            lastTime = now;
                        } else if (now - lastTime > 2000) {
                            saveEditorState(this);
                            lastTime = now;
                        }
                        super.update();
                    }
                    background: null;
                    camera: Camera2D {}; 
		    override var content =
		    [internalWindowsLayer = Group { content: 
                       [InternalWindow {
                                    id: "Editor3";
			containerBounds: bind Bounds.boundsFromRect(0, 
                                                                    0, 
                                                                    width,
                                                                    height-toolMenu.bounds.height())
		    	height: 400, width: 300;
                                    content: ResizableStageNode {
                                        content: Tabview {
                                            tabs: Tabview.Tab {
                                                title: "Context";
                                                content: Treeview {
                                                    model: bind contextModel                                                  
                                                }
                                            }
                                        }
                                    }
                       },
                       InternalWindow {
                        id: "Editor1";            
			containerBounds: bind Bounds.boundsFromRect(0, 
                                                                    0, 
                                                                    width,
                                                                    height-toolMenu.bounds.height())
		    	height: 400, width: 300;
			cx: 160, cy: 800-300;	   
			    content: ResizableStageNode {
			    
			      content: Tabview {
				tabs: 
				[Tabview.Tab {
				     title: "Assets";
				     content:
                                     Scrollpane { 
                                         canZoomVertical: false;
                                         content: Treeview {
					 model: AssetTree.AssetModel {
					     resources: bind currentResource;
					 }

					 var dragger is TransformNode;
                                         var tn is AssetTree.AssetTreenode;

					 override function onMouseDrag from (e is MouseEvent) to () {
					     if (dragger == null) {
						 dragger = TransformNode {
						     pickable: false;
						     content: Group {
							 //transform: translate(-e.sceneLocation.x, 0);
							 content: getDragCell();
						     }
						 }
						 insert dragger into popupLayer.content;
					     }
					     dragger.tx = editorScene.mousePosition.x;
					     dragger.ty = editorScene.mousePosition.y;
                                             tn = (selectedTreenode as AssetTreenode);
					 }

					 override function onMouseUp from (e is MouseEvent) to () 
					 {
					     var asset = tn.asset;
					     if (asset is AssetTree.MaAsset) {
						 const t = (asset as AssetTree.MaAsset).model.getTemporalRoot();
						 if (t.bounds.duration() > 0s) {
						     asset = AssetTree.ClipAsset {
							 override function getClip to TimeNode { t }
							 url: asset.url;
							 name: asset.name;
						     }
						 }
					     }
					     if (asset is AssetTree.ClipAsset) {
						 const clip = (asset as AssetTree.ClipAsset).getClip();
                                                 const picked = getUnderMouseInEditor();
						 for (j in picked) {
						     println("j={j.node}");
						     if (j.node is Trax) { 
							 (j.node as Trax).onDrop(j, clip, 
                                                                                 function from (t is TimeNode) to ()
                                                                                 {
                                                                                     const rtn = 
                                                                                         if (t is ResourceTimeNode) 
                                                                                             then t as ResourceTimeNode 
                                                                                             else ResourceTimeNode {
                                                                                                     url: asset.url;
                                                                                                     content: t;
                                                                                                 };
                                                                                     addTimeResource(rtn);
                                                                                 });
							 break;
						     }
						 }
					     }
					     delete dragger from popupLayer.content;
					     dragger = null;
					 }
				       }
                                     }
				 },
				 Tabview.Tab {
				     title: "Spatial";
				     content:
				     Tabview {
					 tabs:
					 [Tabview.Tab {
					     title: "Inspector";
                                                 content: Scrollpane {
                                                     canZoomVertical: false;
                                                     content: inspector1 = Inspector {
                                                         inspecting: bind Inspector.inspect(currentTransform);
                                                     }
                                                 }
					  },
					  Tabview.Tab {
					     title: "Hierarchy"
                                             content: Scrollpane {
                                                  canZoomVertical: false;
                                                  content:
                                                  Treeview {
                                                      model: TransformHierarchy.Model {
                                                          h: bind transformHierarchy;
                                                      }
                                                      override function onKeyDown from (e is KeyboardEvent) to ()
                                                      {
                                                          if (e.keyCode == Keys.Delete or
                                                              e.keyCode == Keys.Backspace) {
                                                              const toDelete = currentTransform;
                                                              transformHierarchy.deleteSelection();
                                                              deleteResource(toDelete);
                                                          } else super.onKeyDown(e);
                                                      }
                                                  }
                                              }
					 }]
				     }
				 },
				 Tabview.Tab {
				     title: "Temporal";
				     content:
                                         Tabview {
                                             tabs:
                                             [Tabview.Tab {
                                                     title: "Inspector";
                                                     content: Scrollpane {
                                                         canZoomVertical: false;
                                                         content: inspector2 = Inspector {
                                                             inspecting: bind Inspector.inspect(temporalHierarchy.selectedTransform);
                                                         }
                                                     }
                                                 },
                                                 Tabview.Tab {
                                                     title: "Hierarchy";
                                                     content:
                                                     Scrollpane {
                                                         canZoomVertical: false;
                                                         content:
                                                         Treeview {
                                                             model: TemporalHierarchy.Model {
                                                                 h: bind temporalHierarchy
                                                                     }
                                                             var dragger is TransformNode;
                                                             var clip is TimeNode;
                                                             override function onMouseDrag from (e is MouseEvent) to () {
                                                                 if (dragger == null) {
                                                                     clip = (selectedTreenode as TemporalHierarchy.Treenode).n;
                                                                     dragger = TransformNode {
                                                                         pickable: false;
                                                                         content: Group {
                                                                             transform: translate(-e.sceneLocation.x, 0);
                                                                             content: getDragCell();
                                                                         }
                                                                     }
                                                                     insert dragger into popupLayer.content;
                                                                 }
                                                                 dragger.tx = editorScene.mousePosition.x;
                                                                 dragger.ty = editorScene.mousePosition.y;
                                                             }
                                                             
                                                             override function onMouseUp from (e is MouseEvent) to () 
                                                             {
                                                                 for (j in getUnderMouseInEditor()) {
                                                                     if (j.node is Expression.Canvas) {
                                                                         (j.node as Expression.Canvas).onDrop(j, clip);
                                                                         break;
                                                                     }
                                                                 }
                                                                 delete dragger from popupLayer.content;
                                                                 clip = null;
                                                                 dragger = null;
                                                             }
                                                         }
                                                     }
					 }]; 
                                         }
                                 },
                                         Tabview.Tab {
				            title: "Other";
                                             content:
                                             Tabview {
                                                 tabs:
                                                 [Tabview.Tab {
                                                     title: "Inspector";
                                                     content: Scrollpane {
                                                        canZoomVertical: false;
                                                             //content: inspector3 = Inspector {
                                                             //      inspecting: bind Inspector.inspect(otherHierarchy.selectedObject);
                                                             //}
                                                     }
                                                  },
                                                  Tabview.Tab {
                                                      title: "Hierarchy";
                                                      content:
                                                      Scrollpane {
                                                          canZoomVertical: false;
                                                          //content:
                                                          //Treeview {
                                                          //}]
                                                      }
                                                  }];
                                             }
                                         }];
                             }
                         }
                     },
		     InternalWindow {
                        id: "Editor2";            
			containerBounds: bind Bounds.boundsFromRect(0, 
								    0, 
								    width,
								    height-toolMenu.bounds.height())
		    	height: 305, width: 820;
			cx: 520, cy: 160;	   
			      //imageLoader: null;
			      content: ResizableStageNode {
			    content: Tabview {
				tabs: 
				[Tabview.Tab {
				    title: "Timeline"
				    content: Scrollpane {
                                             content: trax = expr.timeline.Trax {
                                                 clips: bind currentAnimResource.resources;
                                                 loop: bind loop;
                                                 target: player;
                                                 targetNode: mainTimeLayer;
                                                 temporalHierarchy: temporalHierarchy;
                                                 removeClip: function from (clip is TimeNode) to ()
                                                 {
                                                     deleteAnimResource(clip);
                                                 }
                                             }
                                         }
				 },
				 Tabview.Tab {
				    title: "Events"
				    content: expr.prog.Expression.Editor {
					 event: bind inspector1.inspecting[inspector1.selectedIndex].member;
					 targetNode: bind currentTransform as ResourceNode;
					 targetSpace: bind mainScene.root;
					 targetTime: bind mainTimeLayer;
                                         visible: bind currentTransform <> null;
				    }
				 }]

			    }
			      }
		    }]
			},
		    toolMenu, 
                    popupLayer]
                  }]
    }

    function setCamera from (i is Integer) to ()
    {
	/*
	if (i == 0) {
	    currentCamera = camera;
	} else if (i == 9) {
	    currentCamera = Camera2D {};
	} else {
	    const cam = model.getCameras()[i-1];
	    if (cam <> null) {
		currentCamera = cam;
	    }
	}
	println("camera={camera.tx}, {camera.ty}, {camera.tz}");
	*/
    }
    function deleteAnimResource from (n is TimeNode) to () {
        var x = n;
        while (x <> null) {
            if (x is ResourceTimeNode) {
                const rn = x as ResourceTimeNode;
                delete x as ResourceTimeNode from currentAnimResource.resources;
                return;
            }
            x = x.parent;
        }
    }

    function deleteResource from (n is Node) to () {
	if (n is ResourceNode) {
	    const rn = n as ResourceNode;
	    delete n as ResourceNode from currentResource.resources;
	    if (rn.temporal <> null) {
		delete rn.temporal from currentAnimResource.resources;
		//trax.setClips(currentAnimResource.resources);
	    }
	}
    }

    const setClip = function from (i is Integer) to ()
    {
	//currentResource.setClip(i);
    }

    cachedScene.stageNode.addMouseInputHandler(viewer);
    stage.addKeyboardInputHandler(KeyboardInputHandler {

	    override function onKeyInput from (event is KeyboardEvent) to () 
	    {
		if (event.keyChar == "-" or event.keyChar == "_") {
		    manip.shrink();
		} else if (event.keyChar == "+" or event.keyChar == "=") {
		    manip.expand();
		}
	    }
		
	    override function onKeyUp from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    if (event.keyCode == Keys.D) {
			manip.exitPivotMode();
		    }
		}
	    }

	    override function onKeyDown from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    println("event={event}");
		    if (event.keyCode == Keys.Delete or event.keyCode == Keys.Backspace) {
			const toDelete = currentTransform;
			transformHierarchy.deleteSelection();
			deleteResource(toDelete);
		    } else if (event.keyCode == Keys.D) {
			manip.enterPivotMode();
			/* } else if (event.keyCode == Keys.Z and event.metaKey) {
			if (event.shiftKey) {
			    MasterUndoable.redo();
			} else {
			    MasterUndoable.undo();
			    }*/
		    } else if (event.keyCode == Keys.F) {
			viewer.focusCamera(currentTransform);
		    } else if (event.keyCode >= Keys._0 and event.keyCode <= Keys._9) {
			const index = event.keyCode - Keys._0;
			if (event.metaKey) {
			    setClip(index);
			} else {
			    setCamera(index);
			}
		    } else if (event.keyCode == Keys.G) {
			java.lang.System.gc();
			//showMemory = not showMemory;
		    }
		}
	    }
	});
    stage.addDnDInputHandler(DnDInputHandler {
	    override function onDrop from (event is DropEvent) to () 
	    {
		const url = event.url;
		event.accept();
		try {
		    const checkProtocol = new java.net.URL(url);
		    doDrop(url);
		} catch (exception is java.lang.Exception) {
		    exception.printStackTrace();
		}
	    }
	});

    stage.invoke(function {
	    //viewer.focusCamera(currentTransform);
            
	});

}




