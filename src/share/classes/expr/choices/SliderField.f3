package expr.choices;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import f3.media.input.*;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.util.*;
import f3.util.Observer.*;
import java.lang.Math;

function clamp from (n is Number, lo is Number, hi is Number) to Number
{
    Math.min(Math.max(n, lo), hi);
}

public class SliderField is AbstractNode
{
    public var height is Number = bind textArea.height;
    public var width is Number = 64;
    public var t is Number on replace {
	setText(getText(t));
    }

    postinit {
	setText(getText(t))
    }

    protected function getText from (t is Number) to String
    {
	"{t}"
    }

    public function setText from (text is String) to ()
    {
	textArea.setText(text);
    }

    const textArea is Text.Area = Text.Area {
        background: ColorPaint(Color.color(0, 0, 0, 0));
	width: bind width+4;
	transform: translate(0, 1);
	rightJustified: true;
        font: layoutEngine.createFont("font-size:11;font-family:Lucida;");
	pickable: false;
    };

    const dark = Color.color(0.77, 0.77, 0.77);
    const light = Color.color(0.85, 0.85, 0.85);
    const border = Color.color(.55, .55, .55);

    const lightRect is Rectangle = Rectangle {
	fillPaint: bind ColorPaint(light);
	height: bind height;
	width: bind width
    }

    const self = this;
    var w = bind self.width*self.t;

    const darkRect is Rectangle = Rectangle {
	fillPaint: bind ColorPaint(dark);
	override var transform = bind translate(-self.width/2 + self.w/2, 0);
	height: bind height;
	override var width = bind self.w;
    }

    const borderRect is Rectangle = Rectangle {
	fillPaint: bind ColorPaint(border);
	override var transform = bind translate(-self.width/2 + self.width * self.t - 0.5, 0, 0)
	height: bind height;
	width: 1
    }

    override var internalContent = Group {
        cursor: Cursor.Default;
	content: bind
	[lightRect,
        darkRect,
	textArea,
	borderRect]
    } on replace {
	createHandlers()
    }

    var disp is Disposable;

    function createHandlers {
        const onDrag = DefaultObserver of MouseEvent {
	      override function onNext from (event is MouseEvent) to ()
	      {     	       		
		  
		  t = clamp((event.location.x + width / 2) / width, 0.0, 1.0);
	      }
	}
    	disp = lightRect.observeMouseDrag().subscribe(onDrag);
    }
	
}