package expr.prog;
import f3.media.xhtml.XHTML;
import java.lang.Math;
import f3.math.*;
import f3.math.LinearMath.*;
import expr.*;
import expr.Treeview.*;
import expr.Listview.*;
import f3.reflect.*;
import expr.Reflect.*;
import expr.Reflect.getTypeArguments;
import f3.util.*;
import f3.util.Observer.*;
import f3.util.Observable.*;
import f3.lang.*;
import f3.media.input.*;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import expr.Names.*;
import expr.choices.*;
import expr.undo.*;
import expr.inspector.*;
import expr.Context.ClosureVarContext;
import expr.AssetTree.TypeAsset;
import expr.AssetTree.sort;

bound function getDisplayName from (n is Node) to String {
    if (n is ResourceTarget) then (n as ResourceTarget).displayName else n.id;
}

bound function getDisplayName from (n is TimeNode) to String {
    if (n is ResourceTarget) then (n as ResourceTarget).displayName else n.id;
}

function getTypeVars from (t is F3Type) to F3Type[] 
{
    const list = new java.util.ArrayList of F3Type;
    getTypeVars(t, list);
    foreach (x in list) x;
}

function getTypeVars from (t is F3Type, result is java.util.List of F3Type) to ()
{
    getTypeVars0(t, result);
    println("get type vars {t} => {result}");
}

function getTypeVars0 from (t is F3Type, result is java.util.List of F3Type) to ()
{
    if (t.isTypeVariable()) {
        if (not result.contains(t)) {
            result.add(t);
        }
    } else {
        if (t is F3ClassType) {
            const ct = t as F3ClassType;
            for (x in ct.getTypeArguments()) {
                getTypeVars(x, result);
            }
        }
    }
}

public class NumberField is SliderField {

    public var min is Number = 0.0;
    public var max is Number = 1.0;

    protected function onChange from (n is Number) to () 
    {
        if (n < min) {
            min = n;
        }
        if (n > max) {
            max = n;
        }
	t = (n-min) / (max-min);
    }

    override function onCommit from (text is String) to () {
        try {
            onChange(java.lang.Float.parseFloat(text));
        } catch (e is java.lang.Exception) {
        }
    }

    override function onCommit to () 
    {
        onChange(min + (max - min)*t);
    }

    override function getText from (t is Number) to String
    {
	"{%.04f (min + (max - min)*t)}"
    }
}

public class IntegerField is SliderField {

    public var min is Integer = 0;
    public var max is Integer = 100;

    protected function onChange from (n is Integer) to () 
    {
        if (n < min) {
            min = n;
        }
        if (n > max) {
            max = n;
        }
	t = (n-min as Number) / (max-min as Number);
    }

    override function onCommit from (text is String) to () {
        try {
            onChange(Integer.parseInt(text));
        } catch (e is java.lang.Exception) {
        }
    }

    override function onCommit to () 
    {
        const n = java.lang.Math.round(min + (max - min)*t);
        onChange(n as Integer);
    }

    override function getText from (t is Number) to String
    {
	"{Math.round(min + (max - min)*t) as Integer}"
    }
}


function staticify from (fun is F3FunctionMember) to F3FunctionType {
    if (fun.isStatic()) then fun.getType() else {
            const f = fun.getType();
            ctx.makeFunctionType([fun.getDeclaringClass(), foreach (i in [0..<f.minArgs()]) f.getArgumentType(i)], f.getReturnType());
        }
}

function formStaticMethodCall from (fun is F3FunctionMember) to String 
{
    if (fun is F3Local.CtorMember) {
        "new {fun.getDeclaringClass().getName()}";
    } else {
        "{fun.getDeclaringClass().getName()}.{fun.getName()}";
    }
}

function observeType from (t is F3Type) to F3Type {
    if (Reflect.OBSERVABLE_TYPE.isAssignableFrom(t)) { 
        const classType = t as F3ClassType;
        const targs = classType.getTypeArguments();
        if (targs.length > 0) {
            return targs[0];
        }
    }
    return t;
}

const exprMap1 = new java.util.HashMap of (F3ClassType, Member[]);
const exprMap2 = new java.util.HashMap of (F3ClassType, Member[]);

const SelectionPaint = ColorPaint(Color.ORANGE);

const SHORTCUT is Member = Member {
    override function equals from (obj is Object) to Boolean {
        return isSameObject(this, obj);
    }
    override var name = "Shortcut";
    override var members = [];
}

const FORK is Member = Member {
    override function equals from (obj is Object) to Boolean {
        return isSameObject(this, obj);
    }
    override var name = "Fork";
    override var members = [];
}

const BRANCH is Member = Member {
    override function equals from (obj is Object) to Boolean {
        return isSameObject(this, obj);
    }
    override var name = "Branch";
    override var members = [];
}

function thisMember from (typ is F3Type) to Member 
{
    if (typ is F3ClassType) {
        const clazz = typ as F3ClassType;
        const m = clazz.getThis();
        Member {
            rt: m.getType();
            t: m.getType();
            m: m;
            isObservable: true;
            isObserver: false;
        }
    } else null;
}


const operatorSet = {
    const set = new java.util.HashSet of (String);
    set.add("add");
    set.add("+");
    set.add("sub");
    set.add("-");
    set.add("mul");
    set.add("*");
    set.add("div");
    set.add("/");
    set;
}

const operatorMap = {
    const map = new java.util.HashMap of (String, String);
    map.put("Add", "+");
    map.put("Subtract", "-");
    map.put("Sub", "-");
    map.put("Mul", "\u00d7");
    map.put("Multiply", "\u00d7");
    map.put("*", "\u00d7");
    map.put("Div", "/");
    map.put("Divide", "/");
    map.put("Greater Or Equal", "\u2265");
    map.put("Less Or Equal", "\u2264");
    map.put("Greater Than", "&gt;");
    map.put("Less Than", "&lt;");
    map.put("Equal", "==");
    map.put("Not Equal", "\u2260");
    map;
}


const reverseOperatorMap = {
    const map = new java.util.HashMap of (String, String);
    map.put("+", "Add");
    map.put("-", "Subtract");
    map.put("sub", "Subtract");
    map.put("*", "Multiply");
    map.put("mul", "Multiply");
    map.put("/", "Divide");
    map.put("div", "Divide");
    map.put(">=", "Greater Or Equal");
    map.put("ge", "Greater Or Equal");
    map.put("<=", "Less Or Equal");
    map.put("le", "Less Or Equal");
    map.put(">", "Greater Than");
    map.put("gt", "Greater Than");
    map.put("<", "Less Than");
    map.put("lt", "Less Than");
    map.put("==", "Equal");
    map.put("eq", "Equal");
    map.put("<>", "Not Equal");
    map.put("neq", "Not Equal");
    map;
}

const MAT4_TYPE = Reflect.findClass("f3.math.Mat4");

function sourceFunName from (fun is F3FunctionMember) to String 
{
    if (fun.isStatic()) {
        if (fun.getName().startsWith("new")) {
            fun.getName();
        } else {
            "{fun.getDeclaringClass().getName()}.{fun.getName()}";
        }
    } else {
        fun.getName();
    }
}

function formatEnglishName from (name is String) to String 
{
    formatEnglishName(name, "", false);
    
}

function formatEnglishName from (name is String, id is String, html is Boolean) to String 
{
    const n = Names.formatName(name);
    const isOp = operatorMap.containsKey(n);
    const m = if isOp then operatorMap.get(n) else n;
    if (html) {
        if (m.startsWith("Get ") and not m.endsWith(" of")) {
            if (id == "") {
                "<i>{m}</i> of";
            } else {
                "<a href='expr:{id}'><i>{m}</i></a> of";
            }
        } else {
            if (id == "") {
                "<i>{m}</i>";
            } else {
                "<a href='expr:{id}'><i>{m}</i></a>";
            }
        }
    } else {
        m
    }
}

function isSameType from (x is F3Type, y is F3Type) to Boolean {
    if (x is F3Local.ClassType and y is F3Local.ClassType) {
        const x1 = x as F3Local.ClassType;
        const y1 = y as F3Local.ClassType;
        return x1.getType().equals(y1.getType());
    }
    return x == y;
}

public function isSameTypeVariable (x is F3Type, y is F3Type) to Boolean 
{
    if (x.isTypeVariable() and y.isTypeVariable()) {
        if (x is F3Local.ClassType and y is F3Local.ClassType) {
            const x1 = x as F3Local.ClassType;
            const y1 = y as F3Local.ClassType;
            return x1.getType().equals(y1.getType());
        }
    }
    return false;
}

function typeApply from (target is F3Type, 
                         srcType is F3Type,
                         subst is F3Type,
                         substs is java.util.Map of (F3Type, F3Type)) 
    to F3Type 
{
    var p is F3Type;
    for (ent in substs.entrySet()) {
        println("{ent.getKey()} == {target} => {ent.getKey() == target}, hash={ent.getKey().hashCode()}, {target.hashCode()}");
        if (srcType == null) { // major hack
            const x = ent.getKey();
            const y = target;
            if (x.isTypeVariable() and y.isTypeVariable() and x.getTypeVariable() == y.getTypeVariable()) {
                p = ent.getValue();
            }
        } else {
            if (ent.getKey() == target) {
                p = ent.getValue();
            }
        }
    }
    if (p <> null) return p;
    if (srcType <> null and target.isTypeVariable() and srcType.isTypeVariable()) {
        if (isSameTypeVariable(target, srcType) and not subst.isTypeVariable()) {
            substs.put(target, subst);
            return subst;
        }
        return target;
    } 
    if (target is F3FunctionType) {
        const funType = target as F3FunctionType;
        const retType = typeApply(funType.getReturnType(), srcType, subst, substs);
        var matches = retType <> funType.getReturnType();
        const typeParams = 
        {
            foreach (i in [0..<funType.getTypeParameters().length]) 
            {
                const pt = typeApply(funType.getTypeParameters()[i], srcType, subst, substs);
                if (not matches) matches = pt <> funType.getTypeParameters()[i];
                pt
            }
        }
        const parms = 
            foreach (i in [0..<funType.minArgs()]) 
            {
                const pt = typeApply(funType.getArgumentType(i), srcType, subst, substs);
                if (not matches) matches = pt <> funType.getArgumentType(i);
                pt
            };
        if (matches) {
            return ctx.makeFunctionType(typeParams, parms, retType);
        }
    } else if (target is F3ClassType) {
        const clsType = target as F3ClassType;
        const targs is F3Type[] = clsType.getTypeArguments();
        var matches = false;
        const parms = 
            foreach (x in targs) 
            {
                const pt = typeApply(x, srcType, subst, substs);
                //println("target={clsType}: checking type arg {srcType} against {x}, {subst} => {pt}");
                if (not matches) matches = pt <> x;
                pt;
            };
        if (matches) {
            //println("instantiating {clsType} with {parms}");
            const rt = ctx.instantiateType(clsType, parms);
            //println("result={formatClassName(rt)}");
            return rt;
        }
    }
    return target;
}

function makeFunMember from (name is String, params is F3Type[], ret is F3Type) to FunctionMember 
{
    const ft = ctx.makeFunctionType(params, ret);
    println("Make fun member {name} => {ft}");
    FunctionMember {
        m: F3FunctionMember {
            override function getName to String {
                name;
            }
            override function getDeclaringClass to F3ClassType {
               null;
            }
            override function isStatic to Boolean { false }
            override function isPublic to Boolean { true }
            override function isPackage to Boolean { false }
            override function isProtected to Boolean { false }
            override function getType to F3FunctionType { return ft }
            override function invoke from (owner is F3ObjectValue, args is nativearray of F3Value) to F3Value
            {
                null;
            }
        }
    }
    /*
	ft: ft;
	name: name;
	t: ret;
        override function equals from (obj is Object) to Boolean {
            (obj is FunctionMember) and {
                const fun = obj as FunctionMember;
                fun.ft == ft;
            }
        }
    }
    */
}

public const OBSVB_MEMBERS = {
    const clazz = Reflect.findClass("f3.util.Observable");
    const funs = Reflect.getFunctions(clazz, false);
    const names = ["And", "Or", "Zip", "Drop", "Take", "Map"];
    foreach (op in ["concat", "merge", "zip", "drop", "take", "map"]) {
        foreach (fun in funs where fun.getName() == op) FunctionMember { m : fun }
    };
}

public const UNIT_MEMBER = FunctionMember {
    m: Reflect.getFunction("f3.lang.Builtins", "nothing", []);
}

public const NUM_MEMBERS = 
    [FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$NumberOperators", "Number", ["Number"]);
    },
    foreach (op in ["add", "subtract", "multiply", "divide", "remainder", "lessThan", "lessOrEqual", "greaterThan", "greaterOrEqual", "equal", "notEqual"]) {
        FunctionMember {
            isInfix: true;
            m: Reflect.getFunction("f3.lang.Builtins$NumberOperators", op, ["Number", "Number"]);
        }
    },
    FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$NumberOperators", "negate", ["Number"]);
    }];

public const INT_MEMBERS = 
    [FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$IntegerOperators", "Integer", ["Integer"]);
    },
    foreach (op in ["add", "subtract", "multiply", "divide", "remainder","lessThan", "lessOrEqual", "greaterThan", "greaterOrEqual", "equal", "notEqual"]) {
        FunctionMember {
            isInfix: true;
            m: Reflect.getFunction("f3.lang.Builtins$IntegerOperators", op, ["Integer", "Integer"]);
        }
    },
    FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$IntegerOperators", "negate", ["Integer"]);
    }];

const IF_EXPR = Reflect.getFunction("f3.lang.Builtins$BooleanOperators", "If", ["Boolean", "Object", "Object"]);
const NUM_NEGATE = Reflect.getFunction("f3.lang.Builtins$NumberOperators", "negate", ["Number"]);
const INT_NEGATE = Reflect.getFunction("f3.lang.Builtins$IntegerOperators", "negate", ["Integer"]);

public const BOOL_MEMBERS is Member[] = 
    [foreach (op in ["Yes", "No"]) {
        FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$BooleanOperators", op, []);
        }
    }
    foreach (op in ["and", "or", "equal", "notEqual"]) {
        FunctionMember {
            isInfix: true;
            m: Reflect.getFunction("f3.lang.Builtins$BooleanOperators", op, ["Boolean", "Boolean"]);
        }
    },
    FunctionMember {
         m: Reflect.getFunction("f3.lang.Builtins$BooleanOperators", "not", ["Boolean"]);
    },
        //    BRANCH,
    FunctionMember {
        m: Reflect.getFunction("f3.util.Observables", "If", ["f3.util.Observable"]);
    }
    FunctionMember {
        m: IF_EXPR;
    }];


public const UNIT_MEMBERS = 
    [FunctionMember { m: Reflect.getFunction("f3.util.Observable", "count", []) }];

public function introspectMembers from (v is Context.ClosureVarContext) to Member[] 
{
    const t = v.varType.t;
    typeToMember(t);
}

function typeToMember from (t is F3Type) to Member 
{
    const name = t.getName();
    const newMember = if (t is F3ClassType) then {
        Member {
            name: name;
            rt: t;
            t: t;
            m: t as F3ClassType;
            isObservable: true;
            isObserver: true;
        }
     } else {
        Member {
            name: name;
            rt: t;
            t: t;
            m: F3Member {
                override function getName to String {
                    name;
                }
                override function getDeclaringClass to F3ClassType {
                    null
                }
                override function isStatic to Boolean { false }
                override function isPublic to Boolean { true }
                override function isPackage to Boolean { false }
                override function isProtected to Boolean { false }
            }
            isObservable: true;
            isObserver: true;
        }
    };
    return newMember
}

public function introspect from (t is F3Type) to Member[]
{
    introspect(t, false);
}

public function introspect from (t is F3Type, all is Boolean) to Member[]
{
    if (t.getName() == "org.f3.runtime.F3Object" or
	t.getName() == "org.f3.runtime.F3Base" or
	t.getName() == "java.lang.Object") {
	return []
    }
    if (t is F3ClassType) then introspect(t as F3ClassType, all) else if (not all) [] else {
	    if (t == NUMBER_TYPE) 
		then NUM_MEMBERS
		else if (t == INTEGER_TYPE)
		    then INT_MEMBERS 
		    else if (t == BOOLEAN_TYPE)
			then BOOL_MEMBERS
                        else if (t == UNIT_TYPE)
                            then UNIT_MEMBERS
                            else []
    }
}

function getLoweredType from (t is F3Type) to F3Type 
{
    if (isMappable(t)) {
        return (t as F3ClassType).getTypeArguments()[0];
    }
    return null;
}

function isMappable from (t is F3Type) to Boolean {
    if (true) { return false; }
    if (t is F3ClassType) {
        const ct = t as F3ClassType;
        if (ct.getTypeArguments().length == 1) {
            const funs = Reflect.getFunctions(ct, true);
            println("CHECKING MAPPABLE {funs}");
            for (x in funs where x.getName() == "map") {
                // map(f is function from x to y)
                println("found map: {x}");
                const ft = x.getType();
                if (ft.minArgs() == 1) {
                    const arg = ft.getArgumentType(0);
                    println("arg={arg}");
                    if (arg is F3FunctionType) {
                        const ft1 = arg as F3FunctionType;
                        if (ft1.minArgs() == 1) {
                            return true;
                        }
                    }
                }
            }
        }
    }
    return false;
}

public function introspect from (clazz is F3ClassType) to Member[]
{
    introspect(clazz, false);
}

class Instantiator {

    public const clazz is F3ClassType;
    const substs = new java.util.HashMap of (F3Type, F3Type);

    public function G of (T is F3Type) from (t is T) to T 
    {
        if (clazz.isGenericInstance()) 
            then 
                {
                    const r = typeApply(t, clazz.getGenericBase(), clazz, substs) as T;
                    r;
                } 
        else t;
    }
}

public function introspect from (clazz is F3ClassType, all is Boolean) to Member[]
{
    if (clazz == null) return [];
    const exprMap = if all then exprMap2 else exprMap1;
    if (exprMap.containsKey(clazz)) {
	return exprMap.get(clazz);
    }
    const I = Instantiator {clazz: clazz};
    var result is Member[];
    const seen = new java.util.HashSet of F3FunctionMember;
    function checkSeen from (x is F3FunctionMember) to Boolean {
        for (y in seen) {
            if (y.getName().equals(x.getName()) and y.getType().isAssignableFrom(x.getType())) {
                return false;
            }
        }
        seen.add(x);
        return true;
    }
    const funs = (foreach (j in Reflect.getFunctions(clazz, true).reverse() where checkSeen(j)) j).reverse();
    if (all) {
        var r = 
            foreach (f in funs where f.isPublic() and not f.getName().contains("$") and 
                     OBJECT_TYPE <> f.getDeclaringClass() 
                     ) { 
            FunctionMember {
                m: f;
                t: I.G(f.getType().getReturnType());
                ft: I.G(f.getType());
                isInfix: ((f.isStatic() and f.getType().minArgs() == 2) or f.getType().minArgs() == 1) and operatorSet.contains(f.getName())
            }
        };
        const classVars = foreach (v in Reflect.getVars(clazz) where v.isStatic()) {
            Member {
                m: v;
                rt: I.G(v.getType());
                t: I.G(v.getType());
            }
        }
        exprMap.put(clazz, [r, classVars]);
        return [r, classVars];
    }
    for (f in funs where f.isPublic() and not f.getName().contains("$") and 
	     OBJECT_TYPE <> f.getDeclaringClass() 
	 ) { 
	const ft = I.G(f.getType());
	var rt = I.G(ft.getReturnType());
	var toInsert is Member;
	if (ft.minArgs() == 0) {
	    var rt_t = rt;
	    if (SUBJECT_TYPE.isAssignableFrom(rt) or OBSERVABLE_TYPE.isAssignableFrom(rt) or OBSERVER_TYPE.isAssignableFrom(rt)) {
		rt_t = getTypeArguments(rt)[0];
	    } else {
	    }	
            if (rt_t is F3SequenceType) {
                rt_t = (rt_t as F3SequenceType).getComponentType();
            }
	    if (SUBJECT_TYPE.isAssignableFrom(rt)) {
		toInsert = Member {
		    m: f;
		    t: rt_t
                    rt: rt;
		    isObservable: true, isObserver: true;
		}
		println("Subject of ({getTypeArguments(rt)})");
	    }  else if (OBSERVABLE_TYPE.isAssignableFrom(rt)) {
		toInsert = Member {
		    m: f;
		    t: rt_t
                    rt: rt;
		    isObservable: true;
		}
		println("Observable of ({getTypeArguments(rt)})");
	    } else if (OBSERVER_TYPE.isAssignableFrom(rt)) {
		toInsert = Member {
		    m: f;
		    t: rt_t
                    rt: rt;
		    isObserver: true;
		}
		println("Observer of ({getTypeArguments(rt)})");
	    } else {
		if (UNIT_TYPE == rt) {
		    toInsert = Member {
			m: f;
			t: UNIT_TYPE;
                        rt: rt;
			isObservable: false, isObserver: true;
		    }
		}
	    }
	} else {
	    if (UNIT_TYPE <> rt) {
		continue;
	    }
	    if (ft.minArgs() == 0) {
		// observer of ()
		rt = UNIT_TYPE;
		toInsert = Member {
		    m: f;
		    t: rt;
                    rt: rt;
		    isObserver: true;
		}
	    } else if (ft.minArgs() == 1) {
		// observer of ft.getArgumentType(0)
		//println("{f.getName()} => Observer of ({ft.getArgumentType(0)})");
		toInsert = Member {
		    m: f;
		    t: I.G(ft.getArgumentType(0));
                    rt: rt;
		    isObserver: true;
                    isObservable: false;
		}
	    } else {
		// observer of (ft.getArgumentType(0), ft.getArgumentType(1))
		continue;
	    }
	}
	if (toInsert <> null) {
	    insert toInsert into result;
	}
    }
    const vars = Reflect.getVars(clazz);
    for (v in vars where not v.getName().contains("$") and not v.getName().startsWith("bnds") and not v.isStatic()) {
        println("v={v}");
	var toInsert is Member;
	if (true or not v.isPublicInit() and not v.isDef()) {
	    var rt = I.G(v.getType());
	    var isObs = SUBJECT_TYPE.isAssignableFrom(rt) or OBSERVABLE_TYPE.isAssignableFrom(rt);
	    if (isObs or OBSERVER_TYPE.isAssignableFrom(rt)) {
		rt = getTypeArguments(rt)[0];
	    }	
            if (rt is F3SequenceType) {
                rt = (rt as F3SequenceType).getComponentType();
            }
	    if ((not v.isPublicRead() and not v.isPublicInit() and not v.isDef()) and v.isPublic()) {
		println("{v.getName()} => Subject of ({rt})");
		toInsert = Member {
		    m: v;
		    t: rt
		    isObserver: true;
		    isObservable: true;
		}
	    } else if (v.isPublic() or v.isPublicRead() or v.isPublicInit()) {
		println("{v.getName()} => Observable of ({rt})");
		toInsert = Member {
		    m: v;
		    t: rt
		    isObservable: isObs or v.isPublic();
		}
	    }
	}
	if (toInsert <> null) {
	    insert toInsert into result;
	}
    }
    //result = foreach (x in result where not x.t.isAssignableFrom(MAT4_TYPE)) x;
    exprMap.put(clazz, result);
    return result;
}

public class TypeMember is Member {
    public const classType is F3ClassType;
    override var rt = bind classType;
    override var m = bind classType;
    override var t = bind classType;
    public override var name is String = bind formatType(classType);
    override var members is Member[] = bind getTypeMembers(classType);
}

function getTypeMembers from (classType is F3ClassType) to Member[] 
{
    const xs is F3Type[] = classType.getTypeParameters();
    foreach (x in xs) {
        TypeMember {
            classType: x as F3ClassType;
        }
    }
}

public class Member {
    protected var substs is java.util.Map of (F3Type, F3Type);
    override function equals from (obj is Object) to Boolean {
        (obj is Member)  and {
            const objm = obj as Member;
            if (m == null) then {
                    objm == null and objm.t == t and objm.name == name;
            } else objm.m == m 
        }
    }
    public function serialize to MemberNode {
        MemberNode {
            declaringClass: m.getDeclaringClass().getName();
            name: m.getName();
            outputType: t.getName();
            isStatic: m.isStatic();
        }
    }
    public const rt is F3Type;
    public const m is F3Member; 
    public const t is F3Type;
    public const name is String = m.getName();
    public var isObservable is Boolean;
    public var isObserver is Boolean;
    protected var members is Member[] = bind Expression.introspect(t);
    public bound function getMembers to Member[]
    {
        applySubsts(members, substs);
    }

    function applySubsts from (xs is Member[], subst is java.util.Map of (F3Type, F3Type)) to Member[] 
    {
        if (subst == null) then xs else {
                foreach (x in xs) {
                    const t0 = subst.get(x.t);
                    const t1 = if (t0 <> null) then t0 else typeApply(x.t, null, x.t, substs); 
                    println("applying {subst} to {x.t} in {x.name} => {t1}");
                    if (t1 <> x.t) {
                        Member {
                            substs: subst;
                            t: t1;
                            rt: t1;
                            m: x.m;
                            name: x.name;
                        }
                    } else x
                }
            }
    }

    function toObservable to String 
    {
        const app = toApply();
        if (OBSERVABLE_TYPE.isAssignableFrom(t)) {
            return app;
        }
        return "f3.util.Observables.observe(&{app})";
    }

    function toEnglish to String 
    {
        toEnglish("");
    }

    function toEnglish from (arg is String) to String 
    {
	if (m is F3FunctionMember) then "{formatEnglishName(if (m.isStatic()) then m.getName() else name)} {arg}" else "{formatEnglishName(name)}";
    }

    function toApply to String 
    {
        toApply("");
    }

    function toApply from (arg is String) to String 
    {
	if (m is F3FunctionMember) then "{if (m.isStatic()) then "{m.getDeclaringClass()}.<<{m.getName()}>>" else "<<{name}>>"}({arg})" else if (m.isStatic()) then "{m.getDeclaringClass().getName()}.<<{m.getName()}>>" else "<<{name}>>";
    }

    override function toString to String
    {
	"m={m},t={t},name={name},isObserver={isObserver},isObservable={isObservable}";
    }
}

public class FunctionMember is Member {
    public var isInfix is Boolean;
    public var ft is F3FunctionType = bind (m as F3FunctionMember).getType();
    override public function serialize to MemberNode 
    {
        FunctionMemberNode {
            isInfix: isInfix;
            declaringClass: m.getDeclaringClass().getName();
            name: m.getName();
            outputType: ft.getReturnType().getName();
            inputTypes: foreach (i in [0..<ft.minArgs()]) ft.getArgumentType(i).getName();
        }
    }
    override var name = formatName(m as F3FunctionMember);
}

function formatTypeVar from (t is F3Type) to String
{
    "Any{sub(t.getTypeVariable())}";
}

function sub from (t is String) to String {
    "<sup>{t}</sup>";
    /*
    var chs = t.toCharArray();
    const delta = "\u2080".charAt(0) - "a".charAt(0) + 1;
    for (i in [0..<chs.length]) {
        chs[i] = delta + chs[i];
    }
    return new String(chs, 0, chs.length);
    */
}

function sub2 from (t is String) to String {
    var chs = t.toCharArray();
    const delta = "\u2080".charAt(0) - "0".charAt(0) + 1;
    for (i in [0..<chs.length]) {
        chs[i] = delta + chs[i];
    }
    return new String(chs, 0, chs.length);
}

function formatType from (t is F3Type) to String 
{
    if t.isTypeVariable() then formatTypeVar(t) else if (t is F3SequenceType) 
        then "{formatType((t as F3SequenceType).getComponentType())}[]" 
        else if (t is F3FunctionType) then formatFunctionType(null, t as F3FunctionType) 
            else if (t is F3ClassType) then { 
                    const ct = t as F3ClassType; 
                    //const dot = t.getName().lastIndexOf("."); 
                    //if (dot >= 0) then t.getName().substring(dot+1) else t.getName();
                    formatEnglishName(formatClassName(t))
                }
            else t.getName();
}

function formatFunctionType from (clazz is F3ClassType, ft is F3FunctionType) to String 
{
     
    var r = if clazz == null then "(" else "({formatType(clazz)}";
    var sep = if clazz == null then "" else ", ";
    for (i in [0..<ft.minArgs()]) {
        r = "{r}{sep}{formatType(ft.getArgumentType(i))}";
        sep = ", ";
    }
    "{r}) \u2192 {formatType(ft.getReturnType())}";
}

function argCount from (f is F3FunctionMember) to Integer 
{
    (if f.isStatic() then 0 else 1) + f.getType().minArgs();
}

function formatName from (f is F3FunctionMember) to String 
{
    const name = if argCount(f) == 1 and f.getName() == "-" then "Negate" else if argCount(f) == 2 and reverseOperatorMap.containsKey(f.getName()) then reverseOperatorMap.get(f.getName()) else f.getName();
    "{Names.formatName(name)} {formatFunctionType(if f.isStatic() then null else f.getDeclaringClass(), f.getType())}"
}

function formatClassName from (t is F3Type) to String 
{
    if (t == UNIT_TYPE) {
        return "()"
    }
    if (t == OBJECT_TYPE and not t.isTypeVariable()) {
        return "Any"
    }
    if (t is F3FunctionType) {
        return formatFunctionType(null, t as F3FunctionType)
    }
    if (not (t is F3ClassType)) {
        return t.getName();
    }
    if (Reflect.isObservableType(t)) {
        const targs = getTypeArguments(t as F3ClassType);
        const v = if targs == [] then (t as F3ClassType).getTypeParameters()[0] else targs[0];
        return formatClassName(v);
    }
    var baseType = t;
    var parms is F3Type[] = (t as F3ClassType).getTypeArguments();
    var typeCons = 0;
    for (i in [0..<TYPE_CONS.size()]) {
        if (baseType == TYPE_CONS[i]) {
            baseType = parms[0];
            parms = parms[1..];
            typeCons = i+1;
            break;
        }
    }
    const n = if (baseType.isTypeVariable()) then formatTypeVar(baseType) else baseType.getName();
    const dot = n.lastIndexOf(".");
    var base = formatEnglishName(n.substring(dot+1));
    if (false and typeCons > 0) {
        base = "Any<sup>{baseType.getTypeVariable()} of ";
        var sep = "(";
        for (i in [1..typeCons]) {
            base = "{base}{sep}Any{sub2("{i}")}";
            sep = ", ";
        }
        if (typeCons > 1) {
            base = "{base})";
        }
        base = "{base}</sup>";
    }
    if (parms.size() == 0) {
        return base;
    }  else if (parms.size() == 1) {
        return "{base} of {formatClassName(parms[0])}";
    } else {
        var result = "{base} of (";
        var sep = "";
        for (x in parms) {
            result = "{result}{sep}{formatClassName(x)}";
            sep = ", ";
        }
        return "{result})";
    }
}

function argName from (fun is FunctionMember,
                       ft is F3FunctionType, i is Integer) to String 
{
    if (fun.m == null or fun.m.getDeclaringClass() == null) {
        return argName(ft, i);
    }
    const names is String[] = Reflect.getParameterNames(fun.m as F3FunctionMember);
    if names == [] then "" else names[i];
}

function argName from (ft is F3FunctionType, i is Integer) to String 
{
    const t = ft.getArgumentType(i);
    if (t.isTypeVariable()) {
        return formatTypeVar(t);
    }
    const n = formatClassName(t);
    const dot = n.lastIndexOf(".");
    return n.substring(dot+1);
}

function resultName from (ft is F3FunctionType) to String 
{
    ft.getReturnType().getName();
}

var ID = 1;
function getNextId to String {
    return "{ID++}";
}

public interface Expression {
    protected const undoList = UndoList {};
    public var id is String = getNextId();
    public bound function getName to String;
    public function getType to F3Type;
    override function toString { "{getClass()}: {getName()} / {getType()}" }
    public function toSource from (context is IContext) to String { "" }
    public function isObservable to Boolean { false }
    public function toEnglish to String { formatEnglishName(getName(), id, false) }
    public function getTerminals to Expression[] { 
        [] 
    }
}

function nil from (t is F3Type) to String
{
    if (t == Reflect.STRING_TYPE) then "\"\"" else if (t == Reflect.INTEGER_TYPE) then "0" else if (t == Reflect.NUMBER_TYPE) then "0.0" else if (t == Reflect.BOOLEAN_TYPE) then "false" else "null";
}

class InputExpressionRef is InputMemberExpression {
    public var ref is Expression;
}

class OutputExpressionRef is OutputMemberExpression {
    public var ref is Expression;
}

class StaticInputMemberExpression is InputMemberExpression {};

public abstract class ObjectExpression is Expression {
    public var inputMembers is Member[];
    public var outputMembers is Member[];
    public var hasStaticAccess is Boolean = yes;
    public var inputs is InputMemberExpression[] = bind 
    [if (not hasStaticAccess) then null else StaticInputMemberExpression {                 
        member: typeToMember(UNIT_TYPE);
        target: this;
    },
    foreach (p in inputMembers) 
        InputMemberExpression {
        target: this;
        member: p;
    }];
    public var outputs is OutputMemberExpression[] = bind foreach (p in outputMembers) 
        OutputMemberExpression {
        source: this;
        member: p;
    };
    
    override public function getTerminals to Expression[]
    {
        const terms = foreach (x in outputs) x.getTerminals();
        if (terms == []) {
            foreach (x in inputs[1..] where x.observable <> null)  x;
        } else terms;
    }
        
}

class TypeVariableExpression is ObserverExpression {
    const typevar is F3Type;
    override function getType { typevar }
    override bound function getName to String { formatTypeVar(typevar) }
    public var infer is F3Type;
    public bound function getInputType to F3Type {
        if (infer <> null) then infer else if observable <> null then observable.getType() else typevar;
    }
}

class ClassTypeExpression is ObjectExpression {
    public const classType is F3ClassType;
    override var inputMembers = bind getTypeMembers(classType);
    override var outputMembers = TypeMember { classType: bind classType };
    override function getType { classType }
    override bound function getName to String { formatClassName(classType) }
}

class TypeExpression is Expression {
    public const typeref is F3Type;
    override function getType { typeref }
    override bound function getName to String { formatType(typeref) }
}

public class VarContextExpression is ObjectExpression {
    public var varContext is Context.ClosureVarContext;
    override bound function getName to String { varContext.variableName }
    override function toSource from (context is IContext) to String { "(getVar(\"{varContext.variableName}\") as f3.lang.Ref of {getType().getName()})" }
    override function toEnglish to String { formatEnglishName(varContext.variableName, id, false) }
    override function getType to F3Type {
        varContext.varType.t;
    }
    public var member is Member = FunctionMember {
        isObserver: true;
        m: Reflect.getFunction("f3.util.Observer", "onNext", ["java.lang.Object"]);
    }
}

class CollapsedExpression is ObjectExpression {
    public var synthType is F3Type;
    public var synthName is String;
    override bound function getName to String 
    {
        synthName;
    }
    override function getType to F3Type {
        return synthType;
    }
}

abstract class TimeNodeExpression is ObjectExpression {
    public var timeNode is TimeNode;
    function getId from (t is TimeNode) to String {
        var p = t.parent;
        var id = "{t.id}";
        if (false) while (p <> null) {
            p = p.parent;
            id = "{p.id}#{t.id}";
            if (p is ResourceTimeNode) {
                return id;
            }
        }
        return t.id;
    }
    override bound function getName to String { getDisplayName(timeNode) }
    override function toSource from (context is IContext) to String { "(getClip(\"{getId(timeNode)}\") as {getType().getName()})" }

    override function toEnglish to String {
        formatEnglishName(getName())
    }
}

function formatURL from (url is String) to String
{
    try {
        const u = new java.net.URL(url);
        const f = u.getFile();
        const slash = f.lastIndexOf("/");
        return f.substring(slash+1);
    } catch (e is java.lang.Exception) {
    }
    return url;
}

abstract class NodeExpression is ObjectExpression {
    public var node is Node;
    override bound function getName to String { getDisplayName(node) }
    override function toSource from (context is IContext) to String { "(getNode(\"{node.id}\") as {getType().getName()})" }
    override function toEnglish to String {
        //formatEnglishName(getName())
        "<code>\"{formatURL(getName())}\"</code>"
    }
}

function simplify from (s is String) to String {
    const paren = s.indexOf("(");
    if (paren > 0) then s.substring(0, paren) else s
}

public interface MemberExpression is Expression {
    public var member is Member;
    override bound function getName to String { simplify(member.name) }
    public override function isObservable to Boolean {
        if (member.isObservable) return true;
        if (this is ObserverExpression) {
            return (this as ObserverExpression).observable.isObservable();
        }
        return false;
    }
}

public interface ObservableExpression is Expression {
    public var observers is ObserverExpression[];
    override function getTerminals to Expression[] 
    {
        if (observers == []) then [] else foreach (ob in observers) ob.getTerminals();
    }

    postinit {
        undoList.addTarget("observers", AbstractRef of ObserverExpression[] {
                override function get to ObserverExpression[] { observers } 
                override function set from (xs is ObserverExpression[]) to () {
                    observers = xs;
                }
            });
    }

}

public interface ObserverExpression is Expression {
    public var observable is ObservableExpression;

    postinit {
        undoList.addTarget("observers", AbstractRef of ObservableExpression {
                override function get to ObservableExpression { observable } 
                override function set from (x is ObservableExpression) to () 
                {
                    observable = x;
                }
            });
    }

}

public interface VarExpression is MemberExpression {
    override function getType to F3Type { member.t }
}

public class IPath {
    public var id is Integer;
    public var parents is IPath[];
    public const html is Boolean;
    public const showHoles is Boolean;

    public function getRootExpression to Expression 
    {
        var e is Expression = observer;
        while (e is ObserverExpression and (e as ObserverExpression).observable <> null) {
            e = (e as ObserverExpression).observable;
        }
        return e;
    }

    public function getRootId to Integer 
    {
        var result = id;
        for (p in parents) {
            result = Math.max(id, p.getRootId());
        }
        return result;
    }

    public var observer is ObserverExpression;

    // a => Observable of a;
    function needsLift to Boolean {
        if (observer is Parameter) {
            const p = observer as Parameter;
            if (OBSERVABLE_TYPE.isAssignableFrom(p.getType())) return true;
        }
        return false;
    }

    // Observable of a => a
    function needsLower to Boolean {
        if (observer is GetVar) {
            const g = observer as GetVar;
            if (g.member.rt is F3SequenceType) return true;
        }
        if (observer is Parameter) {
            const p = observer as Parameter;
            const observable = observer.observable;
            if (observable is GetVarResult) {
                var exp is Expression = observable;
                while (not (exp is Result)) {
                    exp = (exp as GetVarResult).observable;
                }
                var result = exp as Result;
                if (OBSERVABLE_TYPE.isAssignableFrom(result.t)) return true;
                if (result.t is F3SequenceType) return true;
            }
        }
        return false;
    }

    function needsMappableLower to Boolean {
        if (observer is GetVar) {
            const g = observer as GetVar;
            if (g.member.rt is F3SequenceType) return true;
        }
        if (observer is Parameter) {
            const p = observer as Parameter;
            const observable = observer.observable;
            if (observable is GetVarResult) {
                var exp is Expression = observable;
                while (exp is GetVarResult) {
                    exp = (exp as GetVarResult).observable;
                }
                if (exp is Result) {
                    var result = exp as Result;
                    if (result.t is F3SequenceType) return true;
                    if (OBSERVABLE_TYPE.isAssignableFrom(result.t)) return false;
                    if (isMappable(result.t)) {
                        return true;
                    }
                } else {
                    println("Needs lower EXP=>{exp}");
                }
            }
        }
        return false;
    }

    function getContainingObservableDepth to Integer 
    {
        var count = 0;
        for (p in parents) {
            count = Math.max(count, p.getContainingObservableDepth());
        }
        if (needsLift() and parents <> []) {
            count++;
        }
        var result = count;//
        //println("result {observer} id={id} => {result}");
        return result;
    }

    function getDepth to Integer {
        var p = parents[0];
        var count = 0;
        while (p <> null) {
            count++;
            p = p.parents[0];
        }
        count;
    }

    function getWorldAccess to String 
    {
        return getLocalAccess();
    }

    function getEnglishAccess to String 
    {
        var observer is ObserverExpression = this.observer;
        if (parents.size() == 0) {
            if (observer is Parameter) {
                const p = observer as Parameter;
                if (showHoles) {
                    return p.toEnglishParameter();
                }
                return p.toEnglish();
            }
            if (observer.observable is OutputMemberExpression) {
                const n = observer.observable as OutputMemberExpression;
                return n.toEnglish();
            }
            if (observer is TreeGetVar) {
                return (observer as TreeGetVar).toEnglish();
            }
            println("PARENTS SIZE is ZERO {observer.getClass()} {observer}, observable={observer.observable.getClass()} {observer.observable}");
            if (observer is GetVar) {
                return formatEnglishName((observer as GetVar).toEnglish(), observer.id, html);
            }
            return "the event";
        }
        if (observer is GetVarResult) {
            var exp is Expression = observer;
            while (not (exp is Result)) {
                exp = (exp as GetVarResult).observable;
            }
            const func = (exp as Result).source;
            const infix = func.funMember.isInfix;
            const fun = func.fun;
            if (fun == IF_EXPR) {
                return "{formatEnglishName("if", func.id, html)} ({parents[1].getEnglishAccess()}) then {parents[2].getEnglishAccess()} else {parents[3].getEnglishAccess()}";
            } else if (fun == NUM_NEGATE or fun == INT_NEGATE) {
                return "{formatEnglishName("-", func.id, html)}{parents[1].getEnglishAccess()}";
            } else if (infix) {
                if (fun.isStatic()) {
                    return "({parents[1].getEnglishAccess()} {formatEnglishName(fun.getName(), func.id, html)} {parents[2].getEnglishAccess()})";
                }
                return "({parents[0].getEnglishAccess()} {formatEnglishName(fun.getName(), func.id, html)} {parents[1].getEnglishAccess()})";
            } else {
                if (fun.isStatic()) {
                    var args = "";
                    var sep = "";
                    var lowered = -1;
                    var prefix = "";
                    for (p in parents[1..]) {
                        var j = p.getEnglishAccess();
                        if (p.needsMappableLower()) {
                            prefix = j;
                            lowered = p.getDepth()-1;
                            j = "each<sub>{lowered}</sub>";
                            println("TO ENG: lowered {lowered} prefix={prefix}, j={j}");
                        }
                        args = "{args}{sep}{j}";
                        sep = ", ";
                    }
                    if (parents.size() > 2) {
                        args = "({args})";
                    }
                    if (lowered >= 0) {
                        return "For each<sub>{lowered}</sub> in {"{prefix}".trim()}, {formatEnglishName(sourceFunName(fun), func.id, html)} {args}";
                    }
                    return "{formatEnglishName(sourceFunName(fun), func.id, html)} {args}";
                } else {
                    var args = "";
                    var sep = "";
                    for (p in parents[0..]) {
                        args = "{args}{sep}{p.getEnglishAccess()}";
                        sep = ", ";
                    }
                    if (parents.size() > 1) {
                        args = "({args})";
                    }
                    return "{formatEnglishName(sourceFunName(fun), func.id, html)} {args}";
                }
            }
        }
        if (observer is GetVar) {
            const g = observer as GetVar;
            return "the {formatEnglishName(g.member.name, g.id, html)} of {parents[0].getEnglishAccess()}";
        }
        if (observer is Parameter) {
            return parents[0].getEnglishAccess();
        }
        if (observer is InputMemberExpression) {
            const i = observer as InputMemberExpression;
            if (i is StaticInputMemberExpression) {
                return i.target.toEnglish();
            }
            if (i.member.m is F3VarMember and i.member.isObserver) {
                return "Assign {parents[0].getEnglishAccess()} to the {formatEnglishName(i.member.name)} of {i.target.toEnglish()}"
            } 
            if (i.member.isObserver and is1ArgFunction(i.member)) {
                const sep = if (i.member.name.startsWith("set")) then " to " else " " ;
                return "{formatEnglishName(i.member.name)} of {i.target.toEnglish()}{sep}{parents[0].getEnglishAccess()}";
            } else if (i.target is VarContextExpression) {
                return "Assign {parents[0].getEnglishAccess()} to {i.target.toEnglish()} ";
            } else {
                const sep = if (i.member.m is F3VarMember) then " of " else " ";
                return "{parents[0].getEnglishAccess()}, {formatEnglishName(i.member.name)}{sep}{i.target.toEnglish()}";
            }
        }
        return "";
    }


    function getLocalAccess to String 
    {
        var observer is ObserverExpression = this.observer;
        if (parents.size() == 0) {
            if (observer is Parameter) {
                const p = observer as Parameter;
                return "{p.constantValue}";
            }
            if (observer.observable is OutputMemberExpression) {
                const n = observer.observable as OutputMemberExpression;
                const src = n.source;
                //println("n={n}");
                //println("src={src}");
                if (src is VarContextExpression) {
                    const v = (src as VarContextExpression).varContext;
                    return if (v.isShortcut) then "<<{src.getName()}>>" else "(getVar(\"{v.variableName}\") as f3.lang.Ref of {v.varType.t.getName()}).get()";
                } else if (src is NodeExpression) {
                    return "(getNode(\"{(src as NodeExpression).node.id}\") as expr.NodeAPI)";
                } else if (src is TimeNodeExpression) {
                    return "(getTimeNode(\"{(src as TimeNodeExpression).timeNode.id}\") as f3.media.scene.TimeNode)";
                }
                return "i0";
            }
            if (observer is TreeGetVar) {
                return (observer as TreeGetVar).getLocalAccess();
            }
            if (observer is GetVar) {
                return (observer as GetVar).getLocalAccess();
            }
            println("returning \"i\" for {observer.getClass()}, {observer}");
            return "i";
        }
        if (observer is GetVarResult) {
            var exp is Expression = observer;
            while (not (exp is Result)) {
                exp = (exp as GetVarResult).observable;
            }
            const func = (exp as Result).source;
            const fun = func.fun;
            var obDepth = -1;
            var prefix = "";
            var lowered = -1;
            if (fun.isStatic()) {
                var args = "";
                var sep = "";
                for (p in parents[1..]) {
                    var j = p.getWorldAccess();
                    if (p.needsLift()) {
                        println("NON STATIC LIFT: {p}");
                        obDepth = p.getContainingObservableDepth();
                        prefix = j;
                        j = "obs{p.getContainingObservableDepth()-1}";
                    } else if (p.needsLower()) {
                        println("NON STATIC LOWER: {p}");
                        println("NON STATIC LOWER j: {j}");
                        prefix = j;
                        j = "i{p.getDepth()-1}";
                    } else if (p.needsMappableLower()) {
                        prefix = j;
                        lowered = p.getDepth()-1;
                        j = "i{p.getDepth()-1}";
                    }
                    args = "{args}{sep}{j}";
                    sep = ", ";
                }
                var app = formStaticMethodCall(fun);
                var targs = foreach (x in func.typeInputs) {
                    x.getInputType();
                }
                if (targs.size() > 0) {
                    app = "{app} of (";
                    var sep1 = "";
                    for (x in targs) {
                        app = "{app}{sep1}{x.getName()}";
                        sep1 = ", ";
                    }
                    app = "{app})";
                }
                if (obDepth >= 0) {
                    return "{prefix} \}; const obs{obDepth} = foreach (i{getDepth()} in {app}({args})) \{";
                } else if (lowered >= 0) {
                    return "foreach (i{lowered} in {prefix}) {app}({args})";
                }
                return "{prefix} {app}({args})";
            } else {
                var args = "";
                var sep = "";
                var j0 = parents[0].getWorldAccess();
                if (parents[0].needsLift()) {
                    obDepth = parents[0].getContainingObservableDepth();
                    prefix = j0;
                    j0 = "obs{obDepth-1}";
                    println("NON STATIC LIFT: prefix={prefix}, j0={j0}");
                }
                for (p in parents[1..]) {
                    var j = p.getWorldAccess();
                    if (obDepth < 0 and p.needsLift()) {
                        obDepth = p.getContainingObservableDepth();
                        prefix = j;
                        j = "obs{p.getContainingObservableDepth()-1}";
                    }
                    args = "{args}{sep}{j}";
                    sep = ", ";
                }
                var app = fun.getName();
                var targs = foreach (x in func.typeInputs) {
                    x.getInputType();
                }
                if (targs.size() > 0) {
                    app = "{app} of (";
                    var sep1 = "";
                    for (x in targs) {
                        app = "{app}{sep1}{x.getName()}";
                        sep1 = ", ";
                    }
                    app = "{app})";
                }
                if (obDepth >= 0) {
                    return "{prefix} \}; const obs{obDepth} = foreach (i{getDepth()} in {j0}.{app}({args})) \{";
                }
                return "{parents[0].getWorldAccess()}.{app}({args})";                
            }
        }
        if (observer is GetVar) {
            const g = observer as GetVar;
            if (needsLower()) {
                return "foreach (i{getDepth()} in {parents[0].getWorldAccess()}.{g.member.toApply()})";
            }
            return "{parents[0].getWorldAccess()}.{g.member.toApply()}";
        }
        if (observer is Parameter) {
            return parents[0].getWorldAccess();
        }
        if (observer is TypeVariableExpression) {
            return parents[0].getWorldAccess();
        }
        if (observer is InputMemberExpression) {
            const i = observer as InputMemberExpression;
            if (i is StaticInputMemberExpression) {
                return i.target.toSource(null);
            }
            if (i.member.m is F3VarMember and i.member.isObserver) {
                return "\{ {i.target.toSource(null)}.{i.member.toApply()} = {parents[0].getWorldAccess()}; \}";
            } else if (i.target is VarContextExpression) {
                return "{i.target.toSource(null)}.set({parents[0].getWorldAccess()})";
                //return parents[0].getWorldAccess();
            } else { 
                if (i.member.isObserver and is1ArgFunction(i.member)) {
                    return "{i.target.toSource(null)}.{i.member.toApply("{parents[0].getWorldAccess()}")}";
                } else {
                    return "{parents[0].getWorldAccess()}; {i.target.toSource(null)}.{i.member.toApply()}";
                }
            }
        }
        if (true) throw new java.lang.RuntimeException("unhandled case: {observer}");
        return "";
    }
    
    function is1ArgFunction from (m is Member) to Boolean 
    {
        m.m is F3FunctionMember and {
            const f = m.m as F3FunctionMember;
            f.getType().minArgs() == 1
        }
    }

    function getI to String {
        var count = 0;
        var p = parents[0];
        while (p <> null) {
            count++;
            p = p.parents[0];
        }
        if (count == 0) then "i" else "i{count}";
    }

    override function toString to String {
        "{observer} => {getWorldAccess()}";
    }
}

class IContext {
    const map = new java.util.HashMap of (ObserverExpression, IPath);
    function getPath from (ob is ObserverExpression) to IPath 
    {
        map.get(ob)
    }

    function dump to () 
    {
        for (ent in map.entrySet()) {
            println("{ent.getKey()} ---> {ent.getValue()}");
            println("parents={ent.getValue().parents.size()}");
            foreach (p in ent.getValue().parents) {
                println("parent: {p.observer} {p}");
            }
        }
    }

    function getIVar from (ob is ObserverExpression) to String {
        const path = getIPath(ob);
        path.getI();
    }

    var pathCount = 0;

    public const html is Boolean = true;
    public const showHoles is Boolean = false;

    function getIPath from (ob is ObserverExpression) to IPath {
        var result = map.get(ob);
        //if (result <> null) return result;
        result = IPath {
            html: html;
            showHoles: showHoles;
            observer: ob;
        }
        map.put(ob, result);
        var b = ob.observable;
        if (ob is GetVarResult) {
            while (b <> null and not (b is Result)) {
                b = (b as ObserverExpression).observable;
            }
            if (b <> null) {
                const br = b as Result;
                for (p in br.source.inputs) {
                    insert getIPath(p) into result.parents;
                }
            }
        } else if (ob is OutputMemberExpression) {
            const j = ob as OutputMemberExpression;
            for (p in j.source.inputs) {
                insert getIPath(p) into result.parents;
            }
        } else if (b is ObserverExpression) {
            const obs = b as ObserverExpression;
            insert getIPath(obs) into result.parents;
        }
        if (result.parents == []) {
            var id = pathCount++;
            pathCount += result.getContainingObservableDepth();
            result.id = id;
        }
        return result;
    }
}

/*
function getIVar from (ob is ObserverExpression) to String {
    var depth = 0;
    var obs = ob;
    while (true) {
	var b = obs.observable;
	if (b is Result) {
            const br = b as Result;
	    b = if br.source.inputs == null then null else {
                    var j is ObservableExpression;
                    for (p in br.source.inputs) {
                        if (descendsFromObservableRoot(p.observable)) {
                            j = p.observable;
                            break;
                        }
                    }
                    j;
                }
	} 
	if (b is ObserverExpression) {
	    obs = b as ObserverExpression;
	    depth++;
	} else {
	    break;
	}
    }
    if (depth == 0) then "i" else "i{depth}";
}
*/

public class GetVar is VarExpression, ObservableExpression, ObserverExpression {

    override public function getTerminals to Expression[] 
    {
        if (observers == []) then [] else foreach (ob in observers) ob.getTerminals();
    }

    public function getLocalAccess to String 
    {
        member.toApply();
    }

    override public function toSource from (context is IContext) to String 
    {
        println ("get var to source {this} observable={observable}");
        if (observable is Result) {
            return observable.toSource(context);
	} 
	if (observers == []) {
	    return "";
	}
	const i = context.getIVar(this);
	if (false and (observable is MemberExpression and { const mexp = observable as MemberExpression; mexp.isObservable() })) {

	    "(foreach ({i} in debugger.debug({observable.toSource(context)}, \"{id}\")) {i}.{member.toApply()})";
        } else {
	    if (true or observable == null) {
		if (true or OBSERVABLE_TYPE.isAssignableFrom(member.rt)) 
		    then "{i}.{member.toApply()}"
		    else "debugger.debug(f3.util.Observables.observe(&{i}.{member.toApply()}), \"{id}\")";
	    } else {
		"(foreach ({i} in debugger.debug({observable.toSource(context)}, \"{id}\")) {i}.{member.toApply()})";
	    }
	}
    }

    override public function toEnglish to String {
        member.name;
    }

    override bound function getName to String { member.name }
}

public class SetVar is VarExpression, ObserverExpression {
}

function descendsFromObservableRoot from (p is Expression) to Boolean {
    if (p is ObserverExpression) {
        const ob = p as ObserverExpression;
        if (ob.observable <> null) {
            return descendsFromObservableRoot(ob.observable);
        }
    }
    if (p is MemberExpression) {
        const m = p as MemberExpression;
        if (m.isObservable()) {
            return true;
        }
    }
    return false;
}

public class Function is MemberExpression {
    public var funMember is FunctionMember;
    override var member = bind funMember;
    public var ft is F3FunctionType = bind funMember.ft;
    public var fun is F3FunctionMember = bind member.m as F3FunctionMember;
    override function getType { ft }
    var isStatic = bind fun.isStatic();
    var clazz = bind fun.getDeclaringClass();
    var isNull = bind clazz == null;
    var argCount1 = bind ft.minArgs();
    public var typeParams is F3Type[] = bind ft.getTypeParameters();
    public var typeInputs is TypeVariableExpression[] = bind foreach (t in typeParams) TypeVariableExpression {typevar: t};
    public var inputs is Parameter[] = 
	bind 
        [if (isNull) then null else 
         Parameter {
             name: "";
             target: this;
             t: bind if (isStatic) then UNIT_TYPE else clazz;
         },           
         foreach (i in [0..<argCount1]) {
             Parameter {
                 name: bind argName(funMember, ft, i);
                 target: this;
                 t: bind ft.getArgumentType(i);
             }
         }];
    public var output is Result = Result {
        source: this;
	t: bind ft.getReturnType()
    }

    override public function toEnglish to String {
	var observable is Expression;
        var j is Integer = -1;
        for (i in inputs) {
            if (descendsFromObservableRoot(i.observable)) {
                if (observable == null) {
                    observable = i.observable;
                    j = indexof i;
                } else {
                    println("multiple roots: {observable}, {i.observable}");
                }
            }
        }
        if (funMember.m == IF_EXPR) {
            return "if {inputs[1].toEnglish()} then {inputs[2].toEnglish()} else {inputs[3].toEnglish()}";
        }
        const infix = funMember.isInfix;
        println("Function to source observable={observable}");
	const result = if (not isObservableType(inputs[j].t) and observable is MemberExpression and { const mexp = observable as MemberExpression; mexp.isObservable() } ) {
	    const m = observable as MemberExpression;
            if (inputs.size() == 1) {
                if (inputs[0].observable <> null) {
                    const i = "";//context.getIVar(inputs[0]);
                    if (fun.isStatic()) {
                        println("static case 1");
                        "when {formatEnglishName(sourceFunName(fun))} of {observable.toEnglish()}";
                    } else {
                        println("non static case 1");
                        "when {formatEnglishName(fun.getName())} of {observable.toEnglish()}";
                    }
                } else {
                    if (fun.isStatic()) {
                        println("static case 2");
                        "{fun.getName()} {observable.toEnglish()}";
                    } else {
                        println("non static case 2");
                        "{fun.getName()} {observable.toEnglish()}";
                    }
                }
            } else if (infix) {
                if (not fun.isStatic()) {
                    "({inputs[0].toEnglish()} {formatEnglishName(fun.getName())} {inputs[1].toEnglish()})";
                } else {
                    "({inputs[1].toEnglish()} {formatEnglishName(fun.getName())} {inputs[2].toEnglish()})";
                }
            } else {
                if (not fun.isStatic()) {
                    const i = "event"; //getIVar(inputs[j]);
                    var sep = "";
                    var args is String;
                    var targ is String = if (j == 0) then i else inputs[0].toEnglish();
                    for (k in [0..<ft.minArgs()]) {
                        const p = inputs[k].toEnglish();
                        args = "{args}{sep}{p}";
                        sep = " and ";
                    }
                    println("non static case 3");
                    "({formatEnglishName(fun.getName())} {args}{sep}{targ})";
                } else {
                    const i = "event"; //getIVar(inputs[j]);
                    var args is String = "";
                    var sep = "";
                    for (k in [0..<ft.minArgs()]) {
                        const p = inputs[k+1].toEnglish();
                        args = "{args}{sep}{p}";
                        sep = " and ";
                    }
                    println("static case 3");
                    "({formatEnglishName(sourceFunName(fun))} {args})";
                }
            }
        } else if (infix) {
            if (not fun.isStatic()) {
                "({inputs[0].toEnglish()} {formatEnglishName(fun.getName())} {inputs[1].toEnglish()})";
            } else {
                "({inputs[1].toEnglish()} {formatEnglishName(fun.getName())} {inputs[2].toEnglish()})";
            }
        } else {
            if (not fun.isStatic()) {
                var targ is String = inputs[0].toEnglish();
                var args is String = targ;
                var sep = " and ";
                for (k in [0..<ft.minArgs()]) {
                    const p = inputs[k+1].toEnglish();
                    args = "{args}{sep}{p}";
                    sep = " and ";
                }
                println("non static case 4");
                "({formatEnglishName(fun.getName())} {args})";
            } else {
                var args is String = "";
                var sep = "";
                for (k in [0..<ft.minArgs()]) {
                    const p = inputs[k+1];
                    args = "{args}{sep}{p.toEnglish()}";
                    sep = " and ";
                }
                println("static case 4");
                "({formatEnglishName(fun.getName())} {args})";
            }
        }
        println("gen english {this} => {result}");
        return result;
    }

    override public function toSource from (context is IContext) to String {
	var observable is Expression;
        var observables is Expression[];
        var j is Integer = -1;
        for (i in inputs) {
            if (descendsFromObservableRoot(i.observable)) {
                if (observable == null) {
                    observable = i.observable;
                    j = indexof i;
                } else {
                    println("multiple roots: {observable}, {i.observable}");
                }
                insert i.observable into observables;
            }
        }
        println("Function to source observable={observable}");
	const result = if (observables.size() == 1 and (not isObservableType(inputs[j].t) and observable is MemberExpression and { const mexp = observable as MemberExpression; mexp.isObservable() } )) {
	    const m = observable as MemberExpression;
            if (inputs.size() == 1) {
                if (inputs[0].observable <> null) {
                    const i = context.getIVar(inputs[0]);
                    if (fun.isStatic()) {
                        println("static case 1");
                        "(foreach ({i} in debugger.debug({observable.toSource(context)}, \"{id}\")) {sourceFunName(fun)}())";
                    } else {
                        println("non static case 1");
                        "(foreach ({i} in debugger.debug({observable.toSource(context)}, \"{id}\")) {i}.{fun.getName()}())";

                    }
                } else {
                    if (fun.isStatic()) {
                        println("static case 2");
                        "{fun.getName()}({observable.toSource(context)})";
                    } else {
                        println("non static case 2");
                        "{observable.toSource(context)}.{fun.getName()}()";
                    }
                }
            } else {
                if (not fun.isStatic()) {
                    const i = context.getIVar(inputs[j]);
                    var sep = "";
                    var args is String;
                    var targ is String = if (j == 0) then i else inputs[0].toSource(context);
                    for (k in [0..<ft.minArgs()]) {
                        const p = if (k+1 == j) then i else inputs[k+1].toSource(context);
                        args = "{args}{sep}{p}";
                        sep = ", ";
                    }
                    println("non static case 3");
                    "(foreach ({i} in debugger.debug({observable.toSource(context)}, \"{id}\")) {targ}.{fun.getName()}({args}))";
                } else {
                    const i = context.getIVar(inputs[j]);
                    var args is String = "";
                    var sep = "";
                    for (k in [0..<ft.minArgs()]) {
                        const p = if (k+1 == j) then i else inputs[k+1].toSource(context);
                        args = "{args}{sep}{p}";
                        sep = ", ";
                    }
                    println("static case 3");
                    "(foreach ({i} in debugger.debug({observable.toSource(context)}, \"{id}\")) {sourceFunName(fun)}({args}))";
                }
            }
	} else {
            if (not fun.isStatic()) {
                const i = inputs[j].toSource(context);
                var sep = "";
                var args is String;
                var targ is String = if (j == 0) then i else inputs[0].toSource(context);
                for (k in [0..<ft.minArgs()]) {
                    const p = if (k+1 == j) then i else inputs[k+1].toSource(context);
                    args = "{args}{sep}{p}";
                    sep = ", ";
                }
                println("non static case 4");
                "{targ}.{fun.getName()}({args})";
            } else {
                var args is String = "";
                var sep = "";
                for (k in [0..<ft.minArgs()]) {
                    const p = inputs[k+1];
                    args = "{args}{sep}{p.toSource(context)}";
                    sep = ", ";
                }
                println("static case 4");
                if (observables.size() > 1) {
                    "{observable.toSource(context)}) {fun.getDeclaringClass().getName()}.{fun.getName()}({args})";
                } else {
                    "{fun.getDeclaringClass().getName()}.{fun.getName()}({args})";
                }
            }
        }
        println("gen source {this} => {result}");
        return result;
    }
}

public class Parameter is ObserverExpression {
    public var name is String;
    public var t is F3Type on replace {
        if (Reflect.INTEGER_TYPE.isConvertibleFrom(t)) {
            constantValue = 0;
        } else if (Reflect.NUMBER_TYPE.isConvertibleFrom(t)) {
            constantValue = 0.0;
        } else if (Reflect.BOOLEAN_TYPE.isConvertibleFrom(t)) {
            constantValue = false;
        } else if (Reflect.STRING_TYPE.isConvertibleFrom(t)) {
            constantValue = ""
        } else {
        }
    }
    public var target is Function;
    override bound function getName to String { name }
    override function getType to F3Type { t }
    public function isTypeVariable to Boolean {
        t.isTypeVariable();
    }

    public var constantValue is Object;

    public function toEnglishParameter to String
    {
        return "_";
    }

    override public function toEnglish to String 
    {
        if (observable == null) then { 
                const v = "{constantValue}";  
                if (Reflect.STRING_TYPE.isConvertibleFrom(t)) then (if v == "" then "\"\"" else v) else if (v.startsWith("(null as")) then "_" else { if (v == "true") then "Yes" else if v == "false" then "No" else v } 
            } else observable.toEnglish();
    }
    override public function toSource from (context is IContext) to String 
    {
        if (observable == null) then "{constantValue}" else observable.toSource(context);
    }
    override function toString to String {
        var i = 0;
        for (p in target.inputs) {
            if (p == this) {
                break;
            }
            i++;
        }
        "Parameter {i} {getName()} of {target} with observable: {observable}"
    }
    override function getTerminals to Expression[] {
        target.output.getTerminals();
    }
}

public class Result is ObservableExpression {
    override bound function getName to String { formatType(t) }
    public var t is F3Type;
    public var source is Function;
    override function getType to F3Type { if isObservableType(t) then getTypeArguments(t)[0] else t }
    public override function toEnglish to String 
    {
        source.toEnglish();
    }
    public override function toSource from (context is IContext) to String 
    {
        const result = source.toSource(context);
        println("source={source}");
        println("gen source {this} => {result}");
        return result;
    }
}

class DataArrow is MeshNode.Instance {
}

class ControlArrow is MeshNode.Instance {
}

public abstract class ExpressionView is AbstractNode {
    const undoList = UndoList {}
    public function setDebugValue from (x is Object) to () 
    {
    }
    override var id = bind expression.id;
    public function unlink from () to () {}
    override function toString { "{super.toString()}: {expression}" }
    public const canvas is Canvas;
    public var expression is Expression;
    public bound function getPos to Point3 { getWorldPos() }
    bound function getWorldPos to Point3 { (toSceneTransform * canvas.toLocal).getTranslation() }
    public var pos is Point3;
    public var cellWidth is Number = bind canvas.cellWidth;;
    public var cellHeight is Number = bind canvas.cellHeight;
    public var font is Text.Font = bind canvas.font;
    public var selected is Boolean;
    public var selectable is Boolean = false;
    public function deselect to ()
    {
        selected = false;
    }
    public function select to ()
    {
        if (selectable) {
            canvas.setSelectedExpr(this);
        }
    }
    public bound function getLabel to String {
        Names.formatName(expression.getName());
    }
    var exprName = bind expression.getName() on replace {
        canvas.dumpSrc();
    }
    public readonly var label is Text.Label = bind constructLabel();
    protected var labelVisible is Boolean = true;
    protected var isLinkable is Boolean;
    protected var isLink is Boolean;
    protected var linkFont is Text.Font = bind font.derive("text-decoration:underline;");
    bound function constructLabel to Text.Label {
        Text.Label {
            text: bind getLabel();
            height: bind cellHeight;
            width: bind cellWidth;
            font: bind if (isLink) then linkFont else font;
            foreground: bind if labelVisible then canvas.textFg else canvas.disabledTextFg;
            background: null;
            pickable: false;
            indent: 4;
        };
    }

    const titleRect = Rectangle {
        height: bind cellHeight;
        width: bind cellWidth;
        fillPaint: bind canvas.cellBg;
        cursor: bind if isLink then Cursor.Hand else null;
    }

    public var defaultTitle is Node = Group {
           content: bind
           [titleRect,
           label];
    };

    protected var titleSeparatorRow is Integer = 0;

    function titleSeparator to Node {
        Rectangle {
            height: 1;
            width: bind cellWidth;
            fillPaint: bind canvas.textFg;
            pickable: false;
            transform: bind translate(0, -titleSeparatorRow * cellHeight + Math.round(-cellHeight/2.0));
        }
    }

    function borderedTitle to Node {
        Group {
            content:
            bind [defaultTitle, titleSeparator()]; 
        }
    } 
    public var title is Node = bind defaultTitle;
    var dragging = false;
    protected var dragFilter is Tuple3 = Tuple3.<<1>>;
    function onDown from (e is MouseEvent) to () 
    {
        if (selectable) {
            if (e.shiftKey) {
                selected = true;
            } else if (e.ctrlKey) {
                selected = not selected;
            } else {
                canvas.setSelection([this]);
            }
            const menuFactory = canvas.menuFactory;
            if (e.isMouseButton3Down()) {
                if (this <> canvas.terminalExprView) {
                    const menu = Menu {
                        items: 
                        [MenuItem {
                                label: "Shortcut";
                                action: function to () 
                                {
                                    canvas.shortcutPrompt(this, canvas.factorAs);
                                }
                                enabled: this is FunctionView and (this as FunctionView).output.getTree.getLinks().size() == 1
                            },
                            MenuItem {
                                label: "Delete";
                                action: canvas.deleteSelection;
                            }]
                    }
                    println("menu factory => {menuFactory}");
                    e.stage.showPopupMenu(e.screenx, e.screeny, menu);
                }
            } else {
                dragging = not e.metaKey;
            }
        }
    }
    function onDrag from (e is MouseEvent) to () 
    {
        if (dragging) {
            canvas.moveSelection(dragFilter * (canvas.toLocal * e.picked.dragPoint1 - canvas.toLocal * e.picked.dragPoint0));
        }
    }
    function onUp from (e is MouseEvent) to () 
    {
        if (dragging) {
            canvas.saveCode();
            MasterUndoable.commit();
        } else {
            if (e.metaKey) {
                onLinkClicked();
            }
        }
        dragging = false;
    }
    var d1;
    var d2;
    var d3;
    var d4;
    var d5;
    postinit {
	d1 = titleRect.observeMouseDown().subscribe(onDown);
	d2 = titleRect.observeMouseUp().subscribe(onUp);
	d3 = titleRect.observeMouseDrag().subscribe(onDrag);
	d4 = titleRect.observeMouseMove().subscribe(onEnter);
	d5 = titleRect.observeMouseLeave().subscribe(onLeave);
        undoList.addTarget("pos", &pos);
        undoList.addTarget("selected", &selected);
    }

    protected function onLinkClicked to () 
    {
    }

    function onEnter from (e is MouseEvent) to ()
    {
        isLink = titleRect.containsPointer and e.metaKey and isLinkable;
    }

    function onLeave from (e is MouseEvent) to ()
    {
        isLink = false;
    }

    public function serialize to ExprNode {
        //throw new java.lang.RuntimeException("not implemented {getClass()}");
        println("serialize not implemented: {this}");
        return null;
    }

    public function getInputLinks to LinkView[] { [] }
    public function getOutputLinks to LinkView[] { [] }
    public function getOpenInputs to InputView[] { [] }
    public function getOpenOutputs to OutputView[] { [] }
}

function unifyInputs 
    from (l is LinkView, 
          visited is java.util.Set of ExpressionView, 
          result is java.util.List of FunctionView) 
    to () 
{
    println("unify inputs {l}");
    for (link in l.source.getInputLinks()) {
        unifyInputs(link, visited, result);
    }
    if (l.target is ParameterView) {
        const f = (l.target as ParameterView).targetView;
        if (visited.add(f)) {
            result.add(f);
        }
    }
}

class FunctionView is ExpressionView {

    override var title = bind borderedTitle();

    override public function unlink from () to () 
    {
        funOutput.unlink();
        for (x in typeInputs) {
            x.unlink();
        }
        for (x in inputs) {
            x.unlink();
        }
        for (link in output.getTree.getLinks()) {
            link.unlink();
        }
    }

    override var selectable = true;

    public override function serialize to ExprNode 
    {
        serializeFunction();
    }


    public function serializeFunction to FunNode 
    {
        const n = FunNode {
            id: "{id}";
            x: pos.x;
            y: pos.y;
            member: fun.member.serialize();
        }
        canvas.serializationMap.put(this, n);
        n.typeInputs = foreach (i in typeInputs) {
            TargetNode {
                targetId: "{i.id}", links: foreach (link in i.links) "{link.id}";
            }
        }
        n.inputs = foreach (i in inputs) TargetNode {
            targetId: "{i.id}", links: foreach (link in i.links) "{link.id}";
            intValue: if (i.parameter.constantValue is Integer) then i.parameter.constantValue as Integer else 0;
            numberValue: if (i.parameter.constantValue is Number) then i.parameter.constantValue as Number else 0.0;
            booleanValue: if (i.parameter.constantValue is Boolean) then i.parameter.constantValue as Boolean else false;
            stringValue: if (i.parameter.constantValue is String) then i.parameter.constantValue as String else "\"\"";
        };
        n.outputs = 
            foreach (link in output.getTree.getLinks() /*where not (link.target is TreecellGetVarView)*/) 
            {
                var p = getPath(link);
                SourceNode {
                    sourceId: p;
                    links: ["{link.id}"];
                }
            };
        return n;
    } 

    override public function getOutputLinks to LinkView[] 
    {
        output.getTree.getLinks()
    }

    public var fun is Function;

    override var transform = bind translate(pos);

    override var expression = bind fun;

    public function assignLinkIds to () {
        var j = 0;
        for (x in typeInputs) {
            for (y in x.links) {
                y.targetLinkId = j++;
            }
        }
        for (x in inputs.reverse()) {
            for (y in x.links) {
                y.targetLinkId = j++;
            }
        }
    }

    function ununify to () 
    {
        for (x in inputs) {
            x.inputType = null;
            x.inferred = [];
        }
        output.unifiedType = null;
        output.inferred = [];
    }

    const substs = new java.util.HashMap of (F3Type, F3Type);

    function unify2 to () 
    {
        substs.clear();
        unify(substs);
        println("unify1: {this} => {substs}");
        unify(substs);
        println("unify2: {this} => {substs}");
    }

    function unify to () 
    {
        unify(substs);
    }

    function unify from (substs is java.util.Map of (F3Type, F3Type)) to () 
    {
        for (x in typeInputs) {
            if (x.links.size() > 0){
                var infer is F3Type = null;
                for (link in x.links) {
                    infer = (link.source as LinkedOutputView).getResultType();
                }
                x.infer = null;
                x.parameter.infer = null;
                substs.put(x.parameter.typevar, infer);
            } else {
                var infer is F3Type = null;
                for (ent in substs.entrySet()) {
                    if (x.parameter.typevar == ent.getKey()) {
                        infer = ent.getValue();
                        break;
                    }
                }
                x.infer = infer;
                x.parameter.infer = infer;
                println("inferred {x.infer} for {x.parameter.typevar} in {x}");
                println("substs={substs}");
            }
        }
        for (x in inputs) {
            var t = x.parameter.t;
            var infer is F3Type = null;
            if (x.links.size() > 0) {
                for (link in x.links) {
                    infer = (link.source as LinkedOutputView).getResultType();
                }
            }  else {
                infer = substs.get(t);
            }
            const canAssign = observeType(t).isConvertibleFrom(infer);
            println("INFERRED {infer} for {t} => {canAssign}");
            if (canAssign) {
                x.inputType = infer;
                var targs is F3Type[];
                var tparms is F3Type[];
                if (infer is F3ClassType) {
                    const ct = infer as F3ClassType;
                    targs = ct.getTypeArguments();
                    tparms = ct.getTypeParameters();
                }
                for (j in inputs) {
                    if (j <> x and j.links.size() == 0) {
                        var t1 = typeApply(j.parameter.t, x.parameter.t, x.inputType, substs);
                        for (q in targs) {
                            const r = tparms[indexof q];
                            t1 = typeApply(t1, r, q, substs);
                        }
                        println("t1={t1} for {j.parameter.t}");
                        if (t1 <> j.parameter.t and j.inputType == null) {
                            println("SETTING type of {j} to {t1}");
                            j.inputType = t1;
                            insert x into j.inferred;
                            println("label={j.getLabel()}");
                        }
                    }
                }
                const t0 = typeApply(output.result.getType(), x.parameter.t, x.inputType, substs);
                if (t0 <> output.result.getType()) {
                    println("t0={formatClassName(t0)} for {formatClassName(output.result.getType())}");
                    output.unifiedType = t0;
                    insert x into output.inferred;
                    println("output resultType={output.resultType}");
                    println("output member={output.getter.member}");
                } 
            } 
        }
    }

    const funOutput is OutputView = OutputView {
        canvas: bind canvas;
        cellWidth: 16;
        expression: bind fun;
        resultType: bind staticify(fun.member.m as F3FunctionMember);
        transform: bind translate(cellWidth/2-8, 0);
        override bound function getLabel to String { "" }
        override var outputName = "";
        override function assignLinkIds to () {
        }
    };

        
    override var titleSeparatorRow is Integer = bind typeInputs.size();

    bound var typeInputs is TypeParameterView[] = foreach (t in fun.typeInputs) TypeParameterView {
        targetView: this;
        parameter: t;
        canvas: canvas;
    };


    bound var inputs is ParameterView[] = foreach (p in fun.inputs) ParameterView {
        targetView: this;
	canvas: bind canvas;
	parameter: bind p;
	cellWidth: bind cellWidth;
    };

    const output is ResultView = ResultView {
        sourceView: this;
	canvas: bind canvas;
	result: bind fun.output;
    };

    const io = Group {
	transform: bind translate(0, -cellHeight);
	content: 
	[	 
	 Group {
	     content: bind inputs
	 }
	 Group {
	     transform: bind translate(0, -(typeInputs.size() + inputs.size()) * cellHeight);
	     content: bind output;
	 }]
    };

    const innerContent = Group { content: bind [Group {
	transform: bind translate(0, -cellHeight);
	     content: bind typeInputs
	 } title, funOutput, io] };
    bound var h = output.bounds.height() + cellHeight+(typeInputs.size()+inputs.size())*cellHeight;
    override var internalContent = Group {
	content: bind [innerContent, 
        Rectangle {
                transform: bind translate(0, -h/2+cellHeight/2);
                visible: bind selected
                pickable: false;
                width: bind cellWidth;
                height: bind h;
                stroke: Stroke {
                    width: 2;
                }
                strokePaint: SelectionPaint;
        }]
    }

    override function update to ()
    {
	super.update();
        var j = 0;
	for (i in typeInputs) {
	    i.index = j++;
	}
	for (i in inputs) {
	    i.index = j++;
	}
    }

    public override function getInputLinks to LinkView[] 
    {
        [foreach (i in typeInputs) i.links, foreach (i in inputs) i.links]
    }

    override public function getOpenInputs to InputView[] 
    { 
        inputs[(if fun.isStatic then 1 else 0)..][i | i.links == []];
    }

    override public function getOpenOutputs to OutputView[] 
    { 
        if (getOutputLinks() == []) then output else []
    }
}

/*
public class SetterView is FunctionView {
    override var selectable = true;
    public var variable is Context.ClosureVarContext;
    //override var output = null;
    override var fun = bind Function { 
        funMember: makeFunMember(variable.variableName, [variable.varType.t, Reflect.STRING_TYPE], UNIT_TYPE) 
    };
    override var dragFilter = new Tuple3(1.0, 0.0, 0.0);
    public override function serialize to ExprNode 
    {
        const c = variable;
        VarContextObjNode {
            varId: c.fullName();
            varType: c.varType.t.getName();
        }
    }
}
*/

class SetterView is ObjectView {
    public var variable is Context.ClosureVarContext;
    override var objectExpr = bind VarContextExpression { 
        varContext: variable, override function getType to F3Type { variable.varType.t }
        inputMembers: bind introspectMembers(variable);
        hasStaticAccess: no;
        //outputMembers: foreach (x1 in members where x1.isObservable) x1;
        override function toSource from (context is IContext) to String { variable.variableName }
    }
}


public class InputMemberExpression is MemberExpression, ObserverExpression {
    override function getType to F3Type { member.t }
    public var target is ObjectExpression;

    override function getTerminals to Expression[] 
    {
        const terms = target.getTerminals();
        return if (terms == []) then [this] else terms;
    }

    override public function toSource from (context is IContext) to String {
	const i = context.getIVar(this);
        var res = 
        if (member.m is F3FunctionMember and (member.m as F3FunctionMember).getType().minArgs() > 0) {
            "(foreach ({i} in debugger.debug({observable.toSource(context)}, \"{id}\")) {target.toSource(context)}.{member.toApply(i)})";
	} else if (observable is MemberExpression and (observable as MemberExpression).member.isObservable) {
	    
	    "(foreach ({i} in debugger.debug({observable.toSource(context)}, \"{id}\")) {target.toSource(context)}.{member.toApply()})";
	} else {
	    if (observable == null) {
		if (true or member.isObservable) 
		    then "{target.toSource(context)}.{member.toApply()}"
		    else "debugger.debug(f3.util.Observables.observe(&{target.toSource(context)}.{member.toApply()}, \"{id}\"))";
	    } else {
		"(foreach ({i} in debugger.debug({observable.toSource(context)}, \"{id}\")) {target.toSource(context)}.{member.toApply()})";
		//"{observable.toSource(}.{member.toApply()}";
	    }
	}
        return res;
    }

    override public function toEnglish to String {
	const i = "";//getIVar(this);
        var res = 
        if (member.m is F3FunctionMember and (member.m as F3FunctionMember).getType().minArgs() > 0) {
	    "{member.toEnglish()} {target.toEnglish()} when you {observable.toEnglish()}";
            //            "for each event in {observable.toEnglish()}, {target.toEnglish()}.{member.toEnglish("event")})";
	} else if (observable is MemberExpression and (observable as MemberExpression).member.isObservable) {
	    
	    "{member.toEnglish()} {target.toEnglish()} after {observable.toEnglish()}";
	} else {
	    if (observable == null) {
		if (true or member.isObservable) 
		    then "the {member.toEnglish()} of {target.toEnglish()}"
		    else "the {member.toEnglish()} of {target.toEnglish()}"
	    } else {
		"{member.toEnglish()} {target.toEnglish()} after {observable.toEnglish()}";
		//"{observable.toSource()}.{member.toApply()}";
	    }
	}
        return res;
    }}

public class OutputMemberExpression is MemberExpression, ObservableExpression {
    override function getType to F3Type { member.t }
    public var source is ObjectExpression;
    override public function toSource from (context is IContext) to String {
	""
    }
    override public function toEnglish to String {
	source.toEnglish();
    }
}

class ObjectOutputView is OutputView {
    public var sourceView is ObjectView;
}

class ClassView is ObjectView {
}

public class ObjectView is ExpressionView {

    override var title = bind borderedTitle();

    override function onLinkClicked to ()
    {
        if (objectExpr is VarContextExpression) {
            const vx = objectExpr as VarContextExpression;
            const v = vx.varContext;
            canvas.go(v);
        }
    }

    override var transform = bind translate(pos);
    override var selectable = true;
    public var objectExpr is ObjectExpression;
    override var expression = bind objectExpr;

    override function unlink from () to () {
        for (i in inputViews) i.unlink();
        for (i in outputViews) i.unlink();
    }

    public override function serialize to ExprNode 
    {
        var n is ObjNode;
        if (objectExpr is NodeExpression) {
            n = NodeObjNode {nodeId: (objectExpr as NodeExpression).node.id};
        } else if (objectExpr is TimeNodeExpression) {
            n = TimeNodeObjNode {timeNodeId: (objectExpr as TimeNodeExpression).timeNode.id};
        } else if (objectExpr is VarContextExpression) {
            const v = (objectExpr as VarContextExpression).varContext;
            n = VarContextObjNode { varId: v.fullName(), varType: v.varType.t.getName(), isShortcut: v.isShortcut };
        } else {
            // @Todo
        }
        n.id = "{id}";
        n.x = pos.x;
        n.y = pos.y;
        canvas.serializationMap.put(this, n);
        n.inputs = foreach (i in inputViews) TargetNode { targetId: "{i.id}", links: foreach (link in i.links) "{link.id}" };
        const tv = outputViews[0].getTree;
        n.outputs = 
            foreach (link in tv.getLinks() /*where not (link.target is TreecellGetVarView)*/) 
            {
                var p = getPath(link);
                //println("GET VAR VIEW {get.member.name} => {getPath(link)}");
                SourceNode {
                    sourceId: p;
                    links: ["{link.id}"];
                }
            }
        println("inputViews={inputViews}");
        println("n.inputs={n.inputs}");
        println("SERIALIZED {this} => {IO.dumpOutput(n)}");
        return n;
    }

    function assignLinkIds to () {
        var j = 0;
        for (x in inputViews) {
            for (y in x.links) {
                y.targetLinkId = j++;
            }
        }
        j = 0;
        for (x in outputViews) {
            for (y in x.links) {
                y.sourceLinkId = j++;
            }
        }
    }

    const self = this;
    protected var inputViews is InputView[] = bind foreach (p in objectExpr.inputs) InputView {
	canvas: bind canvas;
	cellWidth: bind cellWidth;
	expression: p;
	//override bound function getInputType to F3Type { p.getType() }
        override function assignLinkIds to () {
            self.assignLinkIds();
        }
    };

    protected var outputViews is OutputView[] = bind foreach (p in objectExpr.outputs) ObjectOutputView {
	canvas: bind canvas;
	cellWidth: bind cellWidth;
	expression: p;
	override var resultType = bind this.expression.getType();
        override function assignLinkIds to () 
        {
            self.assignLinkIds();
        }
        override function getInputLinks to LinkView[] 
        {
            self.getInputLinks()
        }
        sourceView: this;
    };

    override function getInputLinks to LinkView[] 
    {
        foreach (i in inputViews) i.getInputLinks();
    }

    override function getOutputLinks to LinkView[] 
    {
        foreach (i in outputViews) i.getOutputLinks();
    }
    //    var outputViews = bind foreach (r in outputs) OutputView {
    //	canvas: bind canvas;
    //    };
    const io = Group {
	transform: bind translate(0, -cellHeight);
	content: 
	[
	 Group {
	     content: bind inputViews
	 }
	 Group {
	     transform: bind translate(0, -objectExpr.inputs.size() * cellHeight);
	     content: bind outputViews
	 }]
    };

    const innerContent = Group { content: bind [title, io] };
    override var internalContent = Group {
	content: bind [innerContent, 
        Rectangle {
                cy: bind innerContent.bounds.center.y;
                visible: bind selected
                pickable: false;
                width: bind cellWidth;
                height: bind innerContent.bounds.height();
                stroke: Stroke {
                    width: 2;
                }
                strokePaint: SelectionPaint;
        }]
    }

    override function update {
	super.update();
	for (i in inputViews) {
	    i.index = indexof i;
	}
	for (i in outputViews) {
	    i.index = indexof i;
	}
    }
}

function getPath from (v is LinkView) to String {
    const result = 
        if (v.source instanceof TreecellGetVarView) {
            var g = v.source as TreecellGetVarView;
            var p = getPath(g.parentLink);
            "{p}{g.get.member.name}/";
        } else "/";
    println("get path {v} => {result}");
    return result;
}

public class GetVarView is OutputView {

    public override function serialize to ExprNode {
        if (get.member == null) {
            println("Get node member is null: {this}");
        }
        const n = GetNode {
            id: "{id}";
            x: pos.x;
            y: pos.y;
            visibleRowCount: visibleRowCount;
            member: get.member.serialize();
        }
        canvas.serializationMap.put(this, n);
        n.outputs = 
            foreach (link in tv.getLinks() /*where not (link.target is TreecellGetVarView)*/) 
            {
                var p = getPath(link);
                println("GET VAR VIEW {get.member.name} => {getPath(link)}");
                SourceNode {
                    sourceId: p;
                    links: ["{link.id}"];
                }
            }
        return n;
    }
    override function setDebugValue from (obj is Object) to ()
    {
        tv.setDebugValue(obj);
    }
    override var resultType = bind get.getType();
    public var get is GetVar;
    public var visibleRowCount is Number = 10;
    bound var tv is GetTreeview = GetTreeview {
        canvas: bind canvas;
        width: bind cellWidth;
        visibleRowCount: bind visibleRowCount;
        get: bind get;
        exprView: bind this;
    }

    override var transform = bind translate(pos);
    override var expression = bind get;
    public var isLabeled is Boolean = false;
    var isResizing is Boolean;
    function startResize from (e is MouseEvent) to ()
    {
        isResizing = true;
    }
    function resize from (e is MouseEvent) to ()
    {
        const d = (e.picked.dragPoint1-e.picked.dragPoint0);
        treeHeight -= e.drag.y;
        //tv.resize(tv.width, treeHeight);
        visibleRowCount = treeHeight / cellHeight;
    }
    function finishResize from (e is MouseEvent) to ()
    {
        isResizing = false;
        visibleRowCount = Math.round(treeHeight / cellHeight) as Integer;
        canvas.saveCode();
    }
    function resizer to Node {
        Rectangle {
            fillPaint: ColorPaint(Color.color(.4, .4, .4, 1));
            height: 2;
            width: bind cellWidth;
            cursor: Cursor.SouthResize;
            onMouseDown: startResize;
            onMouseDrag: resize;
            onMouseUp: finishResize;
        }
    }
    var treeHeight is Number;
    override function update to () {
        super.update();
        if (not isResizing) {
            treeHeight = tv.treeHeight;
        }
    }
    const innerContent = Group {
	content: 
        bind 
        if (isLabeled) then {
                [TransformNode {
                   content: bind title;
                },
                TransformNode {
                    ty: bind -cellHeight;
                    content: bind tv;
                },
                TransformNode {
                    ty: bind -cellHeight - treeHeight + cellHeight/2;
                    content: resizer();
                }]
        } else {
            [tv, 
            TransformNode {
                ty: bind -cellHeight - treeHeight + cellHeight/2;
                content: resizer();
            }]
        }
    };
    bound var h = innerContent.bounds.height();
    override var internalContent = bind Group {
        content: bind 
        [innerContent,
         Rectangle {
                transform: bind translate(0, -h/2+cellHeight/2);
                visible: bind selected
                pickable: false;
                width: bind cellWidth;
                height: bind h;
                stroke: Stroke {
                    width: 2;
                }
                strokePaint: SelectionPaint;
        }]
    }
    override bound function getLinkPos to Point3 { getWorldPos() }

}

class OutputPort is LinkedOutputView {
    public var width is Number;
    public function getOutputType to F3Type { resultType }
    public var target is ForkView;
    override var transform = bind translate(pos);
    override bound function getLinkPos to Point3 
    { 
        canvas.toLocal * (toSceneTransform * new Point3(width/2, 0, 0) );
    }
    var rect1 is Rectangle;
    var rect2 is Rectangle;
    override var internalContent = Group {
        content: 
        [rect1 = Rectangle {
           cx: 3;
           width: bind width+3;     
           height: bind cellHeight-3;
           fillPaint: ColorPaint(Color.color(.2, .2, .2, 0));
        },
        rect2 = Rectangle {
            cx: 2
            visible: bind rect1.containsPointer or rect2.containsPointer;
            width: bind width+2;
            height: 1.5;
            fillPaint: ColorPaint(Color.color(.2, .2, .2))
        }]
    }
    const _onDown = observeMouseDown().subscribe(function from (e is MouseEvent) to () {
            canvas.viewLinker.onDown(this, e);
	} );
    const _onDrag = observeMouseDrag().subscribe(function from (e is MouseEvent) to () {
            canvas.viewLinker.onDrag(e);
	});
    const _onUp = observeMouseUp().subscribe(function from (e is MouseEvent) to () {
            canvas.viewLinker.onUp(e);
	});
}

class SourcePort is LinkedInputView {
    public var target is ForkView;
    public var width is Number;
    bound var src is LinkedOutputView = links[0].source;
    bound var sourceExpression = src.expression;
    function getObservable to ObservableExpression {
        src.getObservable();
    }
    override bound function getInputType to F3Type { if src == null then UNIT_TYPE else src.resultType }
    override bound function getLinkPos to Point3 
    { 
        canvas.toLocal * (toSceneTransform * new Point3(-3, 0, 0) );
    }
    var rect1 is Rectangle;
    var rect2 is Rectangle;
    override var internalContent = Group {
        content:
        [rect1 = Rectangle {
           cx: -3;
           width: bind width+3;     
           height: bind cellHeight-2;
           fillPaint: ColorPaint(Color.color(.2, .2, .2, 0));
        },
        rect2 = Rectangle {
            cx: -2;
            visible: bind rect2.containsPointer or rect1.containsPointer or links.size() > 0;
            width: bind width+2;
            height: 1.5;
            fillPaint: ColorPaint(Color.color(.2, .2, .2));
        }]
    }
}


public class ForkView is ExpressionView {
    override var transform = bind translate(pos);
    const fork = this;
    override var selectable = true;
    const sourcePort is SourcePort = SourcePort {
        target: this;
        width: bind width;
        transform: translate(-4, 0, 0);
        canvas: bind canvas;
        override function setObservable from (ob is ObservableExpression) to ()
        {
            for (x in targetPorts) x.links[0].target.setObservable(ob);
        }
        override public function assignLinkIds to () {
            fork.assignLinkIds()
        }
    };

    public function assignLinkIds to () 
    {
        var n = 0;
        for (i in targetPorts.reverse()) {
            for (j in i.links) {
                j.sourceLinkId = n++;
            }
        }
    }

    override function unlink to ()
    {
        sourcePort.unlink();
        for (x in targetPorts) x.unlink();
    }

    bound var targetPorts is LinkedOutputView[] = foreach (i in [0..<targetCount]) OutputPort {

        override public function assignLinkIds to () {
            fork.assignLinkIds()
        }

        target: this;

        override function getObservable to ObservableExpression 
        {
            sourcePort.getObservable();
        }

        resultType: bind sourcePort.getInputType();
        canvas: bind canvas;
        width: bind width
        override function getInputLinks to LinkView[] 
        {
            sourcePort.links;
        }
    }

    var targetCount is Integer = 2;
    var width is Number = 3;
    var h = 0.0;
    bound var height is Number = h+(targetCount) * cellHeight;
    override function update to ()
   {
        super.update();
        var y = height/2 - cellHeight/2;
        const x = 4;
        for (j in targetPorts) {
            j.pos = new Point3(x, y, 0);
            y -= cellHeight;
        }
    }
    var isResizing is Boolean;
    var outputCount = 0;
    function startResize from (e is MouseEvent) to ()
    {
        isResizing = true;
    }
    function resize from (e is MouseEvent) to ()
    {
        const d = (e.picked.dragPoint1-e.picked.dragPoint0);
        h -= e.drag.y*2;
    }
    function finishResize from (e is MouseEvent) to ()
    {
        isResizing = false;
        targetCount = Math.max(Math.max(Math.round(height / cellHeight) as Integer, outputCount), 2);
        h = 0;
        canvas.saveCode();
    }
    function resizer to Node {
        Rectangle {
            fillPaint: ColorPaint(Color.color(.9, .9, .9, 1));
            height: 2;
            width: bind width+2;
            cursor: Cursor.SouthResize;
            onMouseDown: startResize;
            onMouseDrag: resize;
            onMouseUp: finishResize;
        }
    }
    override var internalContent = Group {
        content:
        [Rectangle 
        {
            width: bind width*2;
            height: bind height;
            fillPaint: ColorPaint(Color.color(.2, .2, .2));
            var dragging = false;
            override function onMouseMove from (e is MouseEvent) to ()
            {
            }
            override function onMouseDown from (e is MouseEvent) to ()
            {
                if (e.shiftKey) {
                    fork.selected = true;
                } else if (e.ctrlKey) {
                    fork.selected = not fork.selected;
                } else {
                    canvas.setSelection([fork]);
                }
                println("targetPorts={targetPorts}");
                dragging = true;//e.location.y >= height/2-2;
            }
            override function onMouseDrag from (e is MouseEvent) to ()
            {
                if (dragging) {
                    pos += (canvas.toLocal * e.picked.dragPoint1 - canvas.toLocal * e.picked.dragPoint0);
                }
            }
        },
        Group { content: bind sourcePort },
        Group {
            content: bind targetPorts;
        }
        Group {
            content: Rectangle 
           {
               visible: bind fork.selected
               pickable: false;
               width: bind width*2;
               height: bind height;
               stroke: Stroke {
                   width: 2;
               }
               strokePaint: SelectionPaint;
           }
        }/*,
        TransformNode {
           ty: bind -height/2;
           content: bind resizer();
        }*/]
    };


    override function serialize to ForkNode {
        const n = ForkNode {
            id: "{id}";
            x: pos.x;
            y: pos.y;
        }
        canvas.serializationMap.put(this, n);
        n.input = TargetNode {
            targetId: "{id}", links: foreach (link in sourcePort.links) "{link.id}";
        };
        n.outputs = 
            foreach (port in targetPorts) 
            {
                foreach (link in port.links) {
                    SourceNode {
                        sourceId: "{id}"
                        links: ["{link.id}"];
                    }
                }
            };
        return n;
    } 
}

public class BranchView is ExpressionView {
    override var transform = bind translate(pos);
    const branch = this;
    const sourcePort is SourcePort = SourcePort {
        width: bind width;
        transform: translate(-4, 0, 0);
        canvas: bind canvas;
        override function setObservable from (ob is ObservableExpression) to ()
        {
            for (x in targetPorts) x.links[0].target.setObservable(ob);
        }
        override public function assignLinkIds to () {
            branch.assignLinkIds()
        }
    };

    public function assignLinkIds to () 
    {
        var n = 0;
        for (i in targetPorts) {
            for (j in i.links) {
                j.sourceLinkId = n++;
            }
        }
    }

    override function unlink to ()
    {
        sourcePort.unlink();
        for (x in targetPorts) x.unlink();
    }

    bound var targetPorts is LinkedOutputView[] = foreach (i in [0..<targetCount]) OutputPort {

        override public function assignLinkIds to () {
            branch.assignLinkIds()
        }

        override function getObservable to ObservableExpression 
        {
            sourcePort.getObservable();
        }

        resultType: bind sourcePort.getInputType();
        canvas: bind canvas;
        width: bind width
        override function getInputLinks to LinkView[] 
        {
            sourcePort.links;
        }
    }

    var targetCount is Integer = 2;
    var width is Number = 3;
    var h = 0.0;
    bound var height is Number = h+(targetCount) * cellHeight;
    override function update to ()
   {
        super.update();
        var y = height/2 - cellHeight/2;
        const x = 4;
        for (j in targetPorts) {
            j.pos = new Point3(x, y, 0);
            y -= cellHeight;
        }
    }
    var isResizing is Boolean;
    var outputCount = 0;
    function startResize from (e is MouseEvent) to ()
    {
        isResizing = true;
    }
    function resize from (e is MouseEvent) to ()
    {
        const d = (e.picked.dragPoint1-e.picked.dragPoint0);
        h -= e.drag.y*2;
    }
    function finishResize from (e is MouseEvent) to ()
    {
        isResizing = false;
        targetCount = Math.max(Math.max(Math.round(height / cellHeight) as Integer, outputCount), 2);
        h = 0;
        canvas.saveCode();
    }
    function resizer to Node {
        Rectangle {
            fillPaint: ColorPaint(Color.color(.9, .9, .9, 1));
            height: 2;
            width: bind width+2;
            cursor: Cursor.SouthResize;
            onMouseDown: startResize;
            onMouseDrag: resize;
            onMouseUp: finishResize;
        }
    }
    override var internalContent = Group {
        content:
        [Rectangle 
        {
            override var transform = bind rotate(-45, new Vec3(0, 0, 1));
            width: bind cellHeight;
            height: bind cellHeight;
            fillPaint: ColorPaint(Color.color(.2, .2, .2));
            var dragging = false;
            override function onMouseMove from (e is MouseEvent) to ()
            {
            }
            override function onMouseDown from (e is MouseEvent) to ()
            {
                println("targetPorts={targetPorts}");
                dragging = true;//e.location.y >= height/2-2;
            }
            override function onMouseDrag from (e is MouseEvent) to ()
            {
                if (dragging) {
                    pos += (canvas.toLocal * e.picked.dragPoint1 - canvas.toLocal * e.picked.dragPoint0);
                }
            }
        },
        Group { content: bind sourcePort },
        Group {
            content: bind targetPorts;
        }/*,
        TransformNode {
            ty: bind -height/2;
            content: bind resizer();
            }*/]
    };


    override function serialize to BranchNode {
        const n = BranchNode {
            id: "{id}";
            x: pos.x;
            y: pos.y;
        }
        canvas.serializationMap.put(this, n);
        n.input = TargetNode {
            targetId: "{id}", links: foreach (link in sourcePort.links) "{link.id}";
        };
        n.outputs = 
            foreach (port in targetPorts) 
            {
                foreach (link in port.links) {
                    SourceNode {
                        sourceId: "{id}"
                        links: ["{link.id}"];
                    }
                }
            };
        return n;
    } 
}



public class LinkView is ExpressionView {
    override function toString to String {
        "LinkView {id} source {source.id} {source} target {target.id} {target}";
    }
    public var sourceLinkId is Integer;
    public var targetLinkId is Integer;
    override var id = getNextId();
    override public function serialize to LinkNode {
        const n = LinkNode {}
        canvas.serializationMap.put(this, n);
        n.source = source.id;
        n.target = target.id;
        return n;
    }
    public var target is LinkedInputView;
    public var source is LinkedOutputView;
    public function link from () to () {
	insert this into target.links;
	insert this into source.links;
	insert this into canvas.links;
        target.setObservable(source.getObservable());
	println("LINKING {source} to {target}");
        target.assignLinkIds();
        source.assignLinkIds();
    }

    override function unlink from () to () {
	delete this from target.links;
	delete this from source.links;
	delete this from canvas.links;
        target.setObservable(null);
	println("UNLINKING {source} from {target}");
        target.assignLinkIds();
        source.assignLinkIds();
    }


    override var internalContent = Group {
	override var transform = bind translate(target.getLinkPos())
	content: bind canvas.makeArrow(canvas.ARROW_COLOR);
    }

    postinit {
        undoList.addTarget("target", &target);
        undoList.addTarget("source", &source);
        undoList.addTarget("targetLinkId", &targetLinkId);
        undoList.addTarget("sourceLinkId", &sourceLinkId);
    }
}

class RootLinkView is LinkView {}

abstract class LinkedView is ExpressionView {
    var links is LinkView[] on replace { canvas.dumpSrc() }
    override function unlink from () to () {
        const links = this.links;
	for (link in links) {
	    link.unlink();
	}
    }
    function link from () to () {
	for (link in links) {
	    link.link();
	}
    }
    public bound function getLinkPos to Point3 { pos }
    public function assignLinkIds to () {
    }
    postinit {
        undoList.addTarget("links", &links);
    }
}

class ShortcutTarget is LinkedInputView {
}

abstract class LinkedInputView is LinkedView {
    public bound function getInputType to F3Type { expression.getType() };
    public function getObserver to ObserverExpression
    {
        expression as ObserverExpression
    }
    public function setObservable from (ob is ObservableExpression) to ()
    {
        const old = getObserver().observable;
        if (old <> null) {
            delete getObserver() from old.observers;
        }
        getObserver().observable = ob;
        insert getObserver() into ob.observers;
    }
    var tmpLink is LinkedInputView = null;
    var link0 is LinkView;
    var dx = 0.0;
    var dy = 0.0;
    const onDown1 = observeMouseDown().subscribe(function from (e is MouseEvent) to () {
            dx = 0; dy = 0;
            if (links.size() == 1) {
                link0 = links[0];
                tmpLink = LinkedInputView {
                    override function serialize to ExprNode { null }
                    override var toSceneTransform = bind translate(pos);
                };
                tmpLink.pos = canvas.toLocal * e.sceneLocation;
                insert tmpLink into canvas.views;
                const source = link0.source;
                link0.unlink();
                link0.source = source;
                link0.target = tmpLink;
                link0.link();
                canvas.dropType = observeType(getInputType());
            }
        });
    const onDrag1 = observeMouseDrag().subscribe(function from (e is MouseEvent) to () {
            tmpLink.pos = canvas.toLocal * (e.picked.dragPoint1 - new Vec3(5, 0, 0));
        });
    const onUp1 = observeMouseUp().subscribe(function from (e is MouseEvent) to () {
            if (link0 <> null) {
                canvas.pickInput(e, observeType(getInputType()), function from (found is LinkedInputView) to () {
                        delete tmpLink from canvas.views;
                        const source = link0.source;
                        link0.unlink();
                        if (found <> null) {
                            found.unlink();
                            link0.target = found;
                            link0.source = source;
                            link0.link();
                        }
                        canvas.dumpSrc();
                        MasterUndoable.commit();
                        tmpLink = null;
                        link0 = null;
                    });
                canvas.dropType = null;
            }
        });
}

public class InputView is LinkedInputView {
    var index is Integer;
    override bound function getInputType to F3Type { expression.getType() };
    override var transform = bind translate(0, index * -cellHeight);
    override var internalContent = bind title;

    override bound function getLinkPos to Point3 { canvas.toLocal * (toSceneTransform * new Point3(-cellWidth/2, 0, 0) ) }
    
    override function getInputLinks to LinkView[] { links }
}


abstract class Constant is ObservableExpression {
}

class NumberConstant is Constant {
    public var value is Number;
    override function getType to F3Type { Reflect.NUMBER_TYPE }
    override function toSource from (context is IContext) to String { "{value}" }
    override bound function getName to String { "{value}" }
}

class IntegerConstant is Constant {
    public var value is Integer;
    override function getType to F3Type { Reflect.INTEGER_TYPE }
    override function toSource from (context is IContext) to String { "{value}" }
    override bound function getName to String { "{value}" }
}

class BooleanConstant is Constant {
    public var value is Boolean;
    override function getType to F3Type { Reflect.BOOLEAN_TYPE }
    override function toSource from (context is IContext) to String { "{value}" }
    override bound function getName to String { "{value}" }
}

class TypeParameterView is InputView {
    public var targetView is FunctionView;

    override public function assignLinkIds to () 
    {
        targetView.assignLinkIds();
    }

    override var labelVisible = bind checkLabel(canvas.dropType, getInputType());
    function checkLabel from (dt is F3Type, t is F3Type) to Boolean
    {
        const result = infer == null and canvas.canAssignTo(t);
        return result;
    }
    public var parameter is TypeVariableExpression;
    override var expression = bind parameter;    
    override var internalContent = Group { content: bind title };
    public var infer is F3Type;
    override bound function getInputType to F3Type {
        if (infer <> null) then infer else if links[0].source <> null then links[0].source.expression.getType() else parameter.typevar;
    }
    public override bound function getLabel to String { 
        var src = links[0].source;
        if (infer <> null) then formatType(infer) else getName2(src.expression, expression);
    }
    function getName2 from (linked is Expression, mine is Expression) to String {
        if linked <> null then formatType(linked.getType()) else mine.getName();
    } 
}

class TypeRefView is OutputView {

    public var ref is TypeExpression;

    override public function serialize to ExprNode {
        const n = TypeRefNode { 
            typeName: ref.getType().getName();
            x: pos.x;
            y: pos.y;
            id: id 
        };
        n.outputs = 
            foreach (link in getTree.getLinks() /*where not (link.target is TreecellGetVarView)*/) 
            {
                var p = getPath(link);
                SourceNode {
                    sourceId: p;
                    links: ["{link.id}"];
                }
            };
        canvas.serializationMap.put(this, n);
        return n;
    }

    override var expression = bind ref;    
    override var treeWidth = 16;

    var innerContent = Group { content: bind [title, TransformNode { tx: bind cellWidth/2-8, content: bind getTree }] }

    override var internalContent = Group {
	content: bind [innerContent, 
        Rectangle {
                visible: bind selected
                pickable: false;
                width: bind cellWidth;
                height: bind cellHeight;
                stroke: Stroke {
                    width: 2;
                }
                strokePaint: SelectionPaint;
        }]
    }
    public override bound function getLabel to String { expression.getName() }
    override var outputName = "";
    override var resultType = bind ref.typeref;
    override var transform = bind translate(pos);
}

public class ParameterView is InputView {
    const parameter is Parameter;
    public var targetView is FunctionView;
    override var expression = bind parameter;    
    public var inputType is F3Type;
    public var inferred is ParameterView[];
    override var labelVisible = bind checkLabel(canvas.dropType, getInputType());
    function checkLabel from (dt is F3Type, t is F3Type) to Boolean
    {
        const result = canvas.canAssignTo(t);
        println("{parameter.name} of {targetView.fun.funMember.name} {dt} =>{result} => {t}");
        return result;
    }

    override bound function getLabel to String 
    {
        makeLabel(getInputType())
    }

    function makeLabel from (t is F3Type) to String
    {
        println("making label for type {t} pname={parameter.name} target={parameter.target}");
        //        java.lang.Thread.currentThread().dumpStack();
        "{formatClassName(t)}{if (parameter.name == "") then "" else ": {formatEnglishName(parameter.name)}"}";
    }

    override public bound function getInputType to F3Type 
    {
        if inputType <> null then inputType else parameter.t;
    }

    override public function assignLinkIds to () 
    {
        targetView.assignLinkIds();
    }

    override function update to ()
    {
        checkParameter();
        super.update();
    }

    function checkParameter to () 
    {
        if (Reflect.INTEGER_TYPE.isConvertibleFrom(getInputType())) {
            if (parameter.constantValue == null) parameter.constantValue = 0;
        } else if (Reflect.NUMBER_TYPE.isConvertibleFrom(getInputType())) {
            if (parameter.constantValue == null) parameter.constantValue = 0.0;
        } else if (Reflect.BOOLEAN_TYPE.isConvertibleFrom(getInputType())) {
            if (parameter.constantValue == null) parameter.constantValue = false;
        } else if (Reflect.STRING_TYPE.isConvertibleFrom(getInputType())) {
            if (parameter.constantValue == null) parameter.constantValue = "";
        }
    }

    function numSlider to SliderField 
    {
        var w = bind cellWidth-120;
        var f = NumberField {
            height: bind cellHeight;
            width: bind w;
            transform: bind translate(cellWidth/2-w/2, 0, 0);
            min: 0.0;
            max: 100.0;
            override function onChange from (n is Number) to () 
            {
                super.onChange(n);
                parameter.constantValue = n;
                canvas.dumpSrc();
                MasterUndoable.commit();
            }
        };
        return f;
    }
    
    function intSlider to SliderField 
    {
        var w = bind cellWidth-120;
        var f = IntegerField {
            height: bind cellHeight;
            width: bind w;
            transform: bind translate(cellWidth/2-w/2, 0, 0);
            min: 0;
            max: 100;
            override function onChange from (n is Integer) to () 
            {
                super.onChange(n);
                parameter.constantValue = n;
                MasterUndoable.commit();
                canvas.dumpSrc();
            }
        };
        return f;
    }

    function boolSlider to SliderField 
    {
        var w = bind cellWidth-130;
        var f = SliderField {     
            height: bind cellHeight;
            width: bind w;
            transform: bind translate(cellWidth/2-w/2, 0, 0);
            textInputEnabled: false;
            override function setT from (t is Number) to ()
            {       
                this.t = if (t > 0.5) then 1.0 else 0.5;
            }
            override function getText from (t is Number) to String
            {
                if (t <= 0.5) then "No" else "Yes";
            }
            override function onCommit from () to ()
            {
                MasterUndoable.commit();
            }
            override var t = 0.5 on replace {
                parameter.constantValue = (t > 0.5);
                canvas.dumpSrc();
            }
        };
        return f;
    } 

    function stringField to Text.Field {
        var w = bind cellWidth/2;
        var f = StringField {
            width: bind w
            transform: bind translate(cellWidth/2-w/2, 0);
            height: bind cellHeight;
            font: bind font;
            foreground: bind canvas.textFg;
            background: bind canvas.textBg;
            rightJustified: true;
            override function handleCommit from (text is String) to ()
            {
                parameter.constantValue = "\"{text}\"";
                canvas.dumpSrc();
            }
        }
        return f;
    }

    function removeQuotes from (str is String) to String 
    {
        if (str.startsWith("\"") and str.endsWith("\"")) then str.substring(1, str.length()-1) else str;
    }

    bound var constValue = parameter.constantValue on replace { noteConstantValue(constValue) };

    public function noteConstantValue from (constValue is Object) to () {
        if (textField <> null) {
            textField.setText(removeQuotes(constValue.toString()));
        } else if (sliderField <> null) {
            const f = sliderField;
            if (Reflect.INTEGER_TYPE.isConvertibleFrom(getInputType())) {
                const nf = f as IntegerField;
                nf.onChange(constValue as Integer);
            } else if (Reflect.NUMBER_TYPE.isConvertibleFrom(getInputType())) {
                const nf = f as NumberField;
                nf.onChange(constValue as Number);
            } else if (Reflect.BOOLEAN_TYPE.isConvertibleFrom(getInputType())) {
                f.setT(if constValue is Boolean and (constValue as Boolean) then 1.0 else 0.5);
            }
        }
    }

    readonly var textField is Text.Field = bind if Reflect.STRING_TYPE.isConvertibleFrom(getInputType()) then stringField() else null;

    readonly var sliderField is SliderField = bind getSliderField(parameter.t, inputType);

    function getSliderField from (x is F3Type, _ is F3Type) to SliderField { // hack: workaround for binding bugs
        const t = if (inputType == null) x else inputType;
        println("GET SLIDER FIELD {x}, {inputType}");
        const slider = 
            if (Reflect.INTEGER_TYPE.isConvertibleFrom(t))
                then intSlider()
                else if (Reflect.NUMBER_TYPE.isConvertibleFrom(t)) 
                    then numSlider()
                    else if (Reflect.BOOLEAN_TYPE.isConvertibleFrom(t)) 
                        then boolSlider() else null;
        return slider;
    }

    var controls = bind if (sliderField <> null) then sliderField else textField;
 
    override var internalContent = Group { content: bind [title, if links.size() == 0 then controls else null] };
    /*
    const titleText = XHTML.Text {
        width: bind cellWidth;
        height: bind cellHeight;
        override var transform = bind translate(-width/2, 0);
        style: "body \{ font-family:Lucida Grande; font-weight:bold; font-size: 11pt; color: #333333; \} a:link \{ text-decoration:none; \} a:hover \{text-decoration:underline;\}";
        content: bind "<span>{getLabel()}</span>";
    };
    const title1 = Group {
        content: bind [titleRect, titleText];
    }
    */

    postinit {
        undoList.addTarget("constValue", &parameter.constantValue);
    }
    
}

abstract class StringField is Text.Field {
    protected function handleCommit from (text is String) to ();
    const onCommit = observeCommit().subscribe(handleCommit);
}

public class GetVarResult is GetVar {
    override function getTerminals to Expression[] 
    {
        const terms = super.getTerminals();
        if (terms == []) then this else terms;
    }
}

public abstract class LinkedOutputView is LinkedView {
    public function getObservable to ObservableExpression 
    {
        (expression as ObservableExpression) 
    }
    public var resultType is F3Type;
    public function getResultType to F3Type 
    {
        resultType
    }
}

public class OutputView is LinkedOutputView {
    public var index is Integer;
    override readonly var transform = bind translate(0, index * -cellHeight);
    public readonly var outputName is String = bind formatType(resultType);
    override function unlink to () 
    {
        for (link in getTree.getLinks()) link.unlink();
        super.unlink();
    }

    protected var getter = GetVar {
        member: bind Member {
            m: null;
            t: resultType;
            rt: resultType,
            name: outputName;
        }
    };

    protected var treeWidth = bind cellWidth;
    protected var isStatic is Boolean = false;

    const getTree is GetTreeview = GetTreeview {
        isStatic: bind isStatic;
        canvas: bind canvas;
        width: bind treeWidth;
        get: bind getter;
        exprView: this;
    };

    override public function getOutputLinks to LinkView[] 
    {
        getTree.getLinks()
    }

    postinit {
        if (expression is ObservableExpression) {
            insert getter into (expression as ObservableExpression).observers;
            getter.observable = (expression as ObservableExpression);
        }
    }

    override var internalContent = Group 
    {
	content: bind getTree
    }
    /*
    override function onDrag from (e is MouseEvent) to () 
    {
	//targetPos = e.location;
	//const source = canvas.pickInput(e, result.getType());
    }
    override function onDown from (e is MouseEvent) to () 
    {
    }
    override function onUp from (e is MouseEvent) to () 
    {
    }
    */
    override bound function getLinkPos to Point3 {  canvas.toLocal * (toSceneTransform * new Point3(cellWidth/2, 0, 0) ) }
}

class ResultView is OutputView {
    public var result is Result;
    public var sourceView is FunctionView;
    override var expression = bind result;
    override var resultType = bind if (unifiedType <> null) then unifiedType else result.getType();
    public override function getResultType to F3Type 
    {
        println("GET RESULT TYPE {sourceView.fun.funMember.name} {unifiedType} {result.getType()}");
        if (unifiedType == null) then result.getType() else unifiedType;
    }
    override var getter = bind constructGetVarResult(unifiedType, result.getType(), outputName);
    bound function constructGetVarResult from (unifiedType is F3Type, resultType is F3Type, outputName is String) to GetVarResult 
    {
        GetVarResult {
            member: bind constructMember(if (unifiedType == null) then resultType else unifiedType, outputName);
       }
    }

    function constructMember from (t is F3Type, name is String) to Member 
    {
        println("CREATING GET VAR for {sourceView.fun.funMember.name} => {t}, {name}");
        const substs = if (sourceView.substs.size() > 0) {
            var m = new java.util.HashMap of (F3Type, F3Type);
            for (ent in sourceView.substs.entrySet())  {
                if (not ent.getValue().isTypeVariable()) {
                    println("adding {ent.getKey()} => {ent.getValue()}");
                    m.put(ent.getKey(), ent.getValue());
                }
            }
            m;
        } else null;
        Member {
            substs: substs;
            m: null;
            t: t;
            rt: t;
            name: name;
        }
    }
    public var unifiedType is F3Type;
    public var inferred is ParameterView[];
    public override function getInputLinks to LinkView[] { sourceView.getInputLinks() }
}

class TreeGetVar is GetVar {
    override public function getTerminals to Expression[] {
        if (observers == []) then [] else foreach (ob in observers) ob.getTerminals();
    }
}


class MemberTreenode is Treenode {
    public var m is Member;
    public const isStatic is Boolean;
    public var depth is Integer = bind (parent as MemberTreenode).depth + 1;
    public var get is GetVar = bind TreeGetVar { member: m }
    override var label = bind m.toEnglish();
    bound var members is Member[] = filterMembers(m.getMembers());
    function filterMembers from (xs is Member[]) to Member[] 
    {
        const set = new java.util.HashSet of String;
        foreach (x in xs where set.add(x.name)) {
            const r = if (x.m is F3FunctionMember and {
                    const f = x.m as F3FunctionMember;
                    const ft = f.getType();
                    ft.minArgs() > 0 or (ft.getReturnType() == UNIT_TYPE or OBSERVABLE_TYPE.isAssignableFrom(ft.getReturnType()));
                }) then null else x;
            if (r <> null) {
                println("member is {x.getClass()} {x}");
            }
            if x.m.isStatic() == isStatic then r else null;
        }
    }
    override var canOpen = bind { var n = members.size(); n > 0 };
    override var children = bind foreach (x in members) makeTreenode(x);
    readonly var parentValue = bind (parent as MemberTreenode).value;
    public readonly var value is F3Value = bind getValue(parentValue, m.m);

    public function setValue from (value is F3Value) to ()
    {
        (parent as MemberTreenode).setValue(m.m, value);
    }

    public function setValue from (m is F3Member, value is F3Value) to () {
        const myValue = this.value;
        if (m is F3VarMember) {
            const v = m as F3VarMember;
            try {
                if (v.isStatic()) then v.setValue(null, value) else v.setValue(myValue as F3ObjectValue, value);
            } catch (e is java.lang.Exception) {
                println("failed to set {v} with {myValue} -> {value}");
                e.printStackTrace();
            }
        } 
    }

    function getValue from (myValue is F3Value, m is F3Member) to F3Value 
    {
        if (m is F3VarMember) {
            var v = m as F3VarMember;
            if (v.isStatic()) then v.getValue(null) else if myValue == null then null else v.getValue(myValue as F3ObjectValue);
        } else null
    }

    override function toString to String 
    {
        "{super.toString()} row={row} label={label} {m}"
    }

    function resolvePath from (path is String) to MemberTreenode 
    {
        if (path == "") return this;
        const slash = path.indexOf("/");
        const name = if slash > 0 then path.substring(0, slash) else path;
        const remainder = if slash > 0 then path.substring(slash+1) else "";
        println("name={name}");
        println("remainder={remainder}");
        for (j in children) {
            const x = j as MemberTreenode;
            if (x.m.name == name) {
                return x.resolvePath(remainder);
            }
        }
        return null;
    }

    function makeTreenode from (x is Member) to Treenode
    {
        const m = MemberTreenode {
            parent: this;
            m: x;
            isStatic: isStatic;
        }
        insert m.get into get.observers;
        m.get.observable = get;
        return m;
    }

    override function open {
    	children;
	super.open();
    }

    public function getType to F3Type { m.t }
}

public class MemberTreemodel is Treemodel {

    function getMember to Member 
    {
        (root as MemberTreenode).m
    }

    public function resolvePath from (path00 is String) to MemberTreenode {
        const rootName = getMember().name;
        if (path00 == "/" or path00 == "/{rootName}" or path00 == "/{rootName}/") {
            return root as MemberTreenode;
        }
        var path0 = path00;
        if (not (path0.startsWith("/{rootName}"))) {
            println("path0 is {path0}");
            java.lang.Thread.currentThread().dumpStack();
            path0 = "/{rootName}{path0}";
        }
        const end = if path0.endsWith("/") then path0.length()-1 else path0.length();
        try {
            const path = path0.substring(getMember().name.length()+2, end);
            println("path0: {path0}");
            println("path: {path}");
            const result = (root as MemberTreenode).resolvePath(path);
            println("resolve path {path} => {result}");
            return result;
        } catch (exc is java.lang.StringIndexOutOfBoundsException) {
            println(exc);
            exc.printStackTrace();
            println("failed on: {path0}");
        }
        return null;
    }
}

public class ParentLinkView is LinkView {
}

class TreecellGetVarView is GetVarView {
    public var parentLink is LinkView;
    override function getInputLinks to LinkView[] { parentLink }
}

public class MemberTreecell is Treeview.Treecell 
{
    public var canvas is Canvas;
    const self = this;
    public var active is Boolean;

    public var parentCell is MemberTreecell;

    override function toString to String
    {
        "MemberTreecell {bounds} canvas={canvas}, tv={tv} fg={fg} bg={bg} visible={visible}";
    }

    var parentLink is LinkView;

    function link from () to ()
    {
        if (parentLink == null or parentLink is RootLinkView) {
            var n = (tn as MemberTreenode);
            //var p = (n.parent as MemberTreenode);
            //const pv = if p == null then null else tv.getView(p) as MemberTreecell;
            const pv = parentCell;
            if (pv <> null) {
                if (parentLink == null) {
                    parentLink = ParentLinkView {
                        visible: false;
                        canvas: canvas;
                        source: pv.linkedView;
                        //target: linkedView;
                    }
                }
                pv.link();
                parentLink.link();
            }
        }
    }

    function unlink from () to ()
    {
        var p = parentLink;
        if (not (parentLink is RootLinkView)) {
            parentLink = null;
        }
        p.unlink();
    }

    bound function getLinkBounds to Bounds 
    {
        if (not active) then parentCell.getLinkBounds() else {
                self.canvas.toLocal * self.boundsInScene;
            }
    }

    public var showSelection is Boolean;

    const linkedView is GetVarView = TreecellGetVarView {
        parentLink: bind parentLink;
        override function select to () {
            self.tv.select(self.tn);
            canvas.setSelectedExpr(this);
            selected = true;
            showSelection = true;
        }
        override function deselect to ()
        {
            println("deselecting {tn.label}");
            showSelection = false;
            selected = false;
        }
        override function getResultType to F3Type {
            return (tn as MemberTreenode).getType();
        }
	get: bind (tn as MemberTreenode).get;
        override function assignLinkIds to ()
        {
            if (links.size() > 0) {
                self.link();
            } else {
                self.unlink();
            }
            super.assignLinkIds();
            println("me={getLinkBounds()}");
            println("container={self.canvas.toLocal * self.tv.boundsInScene}");
            println("tv={tv}");
            println("tv.bounds={tv.bounds}");
            println("tn={tn}");
        }
	override bound function getLinkPos to Point3 
	{
            var me = getLinkBounds();
            var container = self.canvas.toLocal * self.tv.boundsInScene;
            new Point3(me.right()-4, 
                       Math.min(container.top(), Math.max(container.bottom(), me.center.y)),
                       0);
        }
        public override function getInputLinks to LinkView[] 
        {
            return parentLink;
        }
    };

    bound function showValue from (mtn is MemberTreenode) to Node 
    {
        if (mtn.value == null) then null else showValue1(mtn.depth, mtn.value);
    }

    function showValue1 from (depth is Integer, value is F3Value) to Node 
    {
        /*if (value == null) then null else*/ {
                if (NUMBER_TYPE.isAssignableFrom(value.getType()) or 
                    INTEGER_TYPE.isAssignableFrom(value.getType()) or  
                    BOOLEAN_TYPE.isAssignableFrom(value.getType()) or
                    STRING_TYPE.isAssignableFrom(value.getType())
                    )  {
                    var fieldWidth = 64;
                    var width = bind tv.cellWidth;
                    TransformNode {
                        tx: bind width / 2 - fieldWidth / 2.0 - depth * 6;
                        content: Text.Label {
                            rightJustified: true;
                            font: bind canvas.font;
                            height: bind tv.cellHeight;
                            width: bind fieldWidth;
                            foreground: bind if isSelected() then getFg() else canvas.textFg;
                            background: bind if isSelected() then getBg() else canvas.textBg;
                            text: bind formatValue(value);
                        }
                    }
                } else null
            }
    }

    bound var rect is Rectangle = createRect();

    function createRect to Rectangle {
        Rectangle {
            visible: bind showSelection;
            height: bind tv.cellHeight;
            width: bind tv.cellWidth;
            pickable: false;
            stroke: Stroke {
                width: 2;
            }
            strokePaint: bind SelectionPaint;
        }
    }


    override var internalContent = bind
        Group {
            content: bind [defaultContent, if showSelection then rect else null];
        }


    function formatValue from (v is F3Value) to String
    {
        const obj = (v as F3Local.Value).asObject();
        if (BOOLEAN_TYPE.isAssignableFrom(v.getType())) 
            {
                const b is Boolean = obj as Boolean;
                if b then "Yes" else "No"
            } else obj.toString()
    }

    override bound function getValueContent to Node 
    {
        var mtn = tn as MemberTreenode;
        showValue(mtn);
    }
}

class GetTreeview is AbstractNode {
    public var isStatic is Boolean;
    public var event is Member;
    public var canvas is Canvas;
    public var exprView is OutputView;
    public var cellHeight = bind canvas.cellHeight;
    public var get is GetVar;
    public var width is Number;
    function open to () {
        treeModel.root.open();
    }
    function setDebugValue from (obj is Object) to ()
    {
        debugValue = Reflect.ctx.mirrorOf(obj, get.getType());
    }

    var debugValue is F3Value;

    public var rootName is String = bind exprView.outputName; //formatType(get.member.t);

    function subst from (m is Member, t is F3Type) to Member {
        const m1 = Member {
            t: t;
            rt: t;
            m: m.m;
            name: m.name;
            isObservable: m.isObservable;
            isObserver: m.isObserver;
        }
        println("SUBST {m} => {t} => {m1}");
        return m1;
    }

    const treeModel = MemberTreemodel {
	root: MemberTreenode {
	    get: bind get;
	    m: bind get.member;
            isStatic: bind isStatic;
            override var label = bind rootName;
            value: bind debugValue;
            override function getType to F3Type
            {
                exprView.getResultType();
            }
	}
    };

    public function getLinks to LinkView[]
    {
        foreach (x in cellMap.values()) foreach (y in x.linkedView.links where not (y is ParentLinkView)) y;

    }
    function getRootLinkedView to LinkedView {
        getCell(treeModel.root as MemberTreenode).linkedView;
    }
    public var visibleRowCount is Number = 10;
    public readonly var treeHeight is Number = bind Math.min(treeModel.rowCount, visibleRowCount)*cellHeight;
    public bound function getTreeHeight to Number { treeHeight }
    const self = this;
    const cellMap is java.util.Map of (MemberTreenode, MemberTreecell) =        
	new java.util.HashMap of (MemberTreenode, MemberTreecell);

    public function getCell from (tn is MemberTreenode) to MemberTreecell {
        if (tn == null) return null;
	var r = cellMap.get(tn);
	if (r == null) {
            const parentCell = getCell(tn.parent as MemberTreenode);
	    r = MemberTreecell {
                parentCell: parentCell;
                active: parentCell == null;
		canvas: canvas;
		tn: tn;
		tv: tv;
	    }
            if (tn == treeModel.root) {
                r.parentLink = RootLinkView { source: self.exprView }
            }
	    cellMap.put(tn, r);
	}
	return r;
    }

    var linkToContainer is LinkView;
    const cellsArray = new java.util.ArrayList of MemberTreecell;
    const tv is Treeview = Treeview {
	transform: bind translate(0, -treeHeight/2+cellHeight/2);
	height: bind treeHeight;
	width: bind width;
	model: bind treeModel;
	override function createCell from (tn is Treenode) to Treecell 
	{
	    self.getCell(tn as MemberTreenode)
	}      

        override function update to ()
        {
            var cells is java.util.List of MemberTreecell = cellsArray;
            var linkCount = 0;
            cells.clear();
            /*
            const rootCell = getCell(treeModel.root as MemberTreenode);
            if (linkToContainer == null and exprView <> null and rootCell <> null) {
                linkToContainer = LinkView {}
                linkToContainer.source = exprView;
                linkToContainer.target = rootCell.linkedView;
                linkToContainer.link();
            }
            */
            for (cell in cellMap.values()) {
                if (cell.parentCell == null) {
                    cell.active = true;
                } else {
                    cell.active = false;
                }
                cells.add(cell);
            }
            java.util.Collections.sort(cells, java.util.Comparator of MemberTreecell {
                    override function compare from (x is MemberTreecell, y is MemberTreecell) to Integer 
                    {
                        java.lang.Math.signum(x.bounds.center.y - y.bounds.center.y) as Integer;
                    }
                });
            for (cell in cells) {
                for (link in cell.linkedView.links /*where not (link.target is TreecellGetVarView)*/) {
                    link.sourceLinkId = linkCount++;
                }
            }
            for (row in rows) {
                const cell = cellMap.get(row);
                cell.active = true;
            }
            super.update();
        }
    };

    override var internalContent = Group {
        content: bind  [tv, Rectangle {
                visible: bind tv.model.rowCount > 1;
                fillPaint: bind canvas.textFg;
                transform: bind translate(0, Math.round(exprView.cellHeight/2.0))
                pickable: false;
                width: bind width;
                height: 1;
                }]
    }

    // fix me: move this stuff to canvas

    const onDown = tv.observeMouseDown().subscribe(function from (e is MouseEvent) to () {
            canvas.treeLinker.onDown(tv, e);
	} );
    const onDrag = tv.observeMouseDrag().subscribe(function from (e is MouseEvent) to () {
            canvas.treeLinker.onDrag(e);
	});
    const onUp = tv.observeMouseUp().subscribe(function from (e is MouseEvent) to () {
            canvas.treeLinker.onUp(e);
	});

}

class TreeLinker {
    var canvas is Canvas;
    var tv is Treeview;
    var pathFactory = bind canvas.pathFactory;
    var layoutEngine = bind canvas.layoutEngine;
    var imageLoader = bind canvas.imageLoader;
    var effectLoader = bind canvas.effectLoader;

    function onDown from (tv is Treeview, e is MouseEvent) to () 
    {
        if (e.location.x >= 0) {
            this.tv = tv;
            const cell = tv.selectedTreecell as MemberTreecell;
            linkTmpLink();
            dx = 0; dy = 0;
            if (not e.shiftKey) {
                cell.linkedView.unlink();
            }
            startPos = canvas.toLocal * e.sceneLocation;
            insert canvas.targetArrow into canvas.arrows;
            arrowVis = true;
            updateArrow();
        } else {

        }
    }

    function onDrag from (e is MouseEvent) to ()
    {
        if (tv == null) return;
        dx += e.drag.x;
        dy += e.drag.y;
        updateArrow();
    }

    function updateArrow to () 
    {
        const cell = tv.selectedTreecell as MemberTreecell;
        const tn = tv.selectedTreenode as MemberTreenode;
        canvas.dropType = tn.m.t;
        if (canvas.dropType == null) {
            println("BAD DROP TYPE: {tn}");
        }
        const toLocal = canvas.toLocal;
        const sourcePos = canvas.toLocal * cell.toSceneTransform.getTranslation();
        linkStart.pos = sourcePos + new Vec3(cell.bounds.extent.x, 0, 0);
        linkEnd.pos = startPos + new Vec3(dx-1, dy, 0);
        canvas.targetArrow.tx = linkEnd.pos.x;
        canvas.targetArrow.ty = linkEnd.pos.y;
    }

    function onUp from (e is MouseEvent) to ()
    {
        if (tv == null) return;
        const tn = tv.selectedTreenode as MemberTreenode;
        const cell = tv.selectedTreecell as MemberTreecell;
        arrowVis = false;
        e.scene.setFocus(canvas);
        canvas.pickInput(e, tn.m.t, function from (found is LinkedInputView) to () {
                tmpLink = null;
                tv = null;
                delete canvas.targetArrow from canvas.arrows;
                link.unlink();
                if (found <> null) {
                    if (found is ShortcutTarget) {
                        canvas.shortcutPrompt(cell.linkedView, null);
                    } else {
                        //cell.link();
                        found.unlink();
                        const newlink = LinkView { 
                            canvas: canvas;
                            source: cell.linkedView; 
                            target: found;
                        };
                        newlink.link();
                        canvas.dumpSrc();
                    }
                } 
                MasterUndoable.commit();
            });
        canvas.dropType = null;
    }
    var tmpLink is LinkView = null;
    var dx = 0.0;
    var dy = 0.0;
    var arrowVis is Boolean;
    var startPos is Point3;

    const linkStart is LinkedOutputView = LinkedOutputView {
        override function serialize to ExprNode { null }
	override var toSceneTransform = bind translate(pos);
    };
    const linkEnd is LinkedInputView = LinkedInputView {
        override function serialize to ExprNode { null }
	override var toSceneTransform = bind translate(pos);
    };

    const link is LinkView = LinkView {
	canvas: bind canvas;
    };

    function linkTmpLink to () 
    {
        link.source = linkStart;
        link.target = linkEnd;
        link.link();
        tmpLink = link;
    }

}

class ViewLinker {
    var canvas is Canvas;
    var tv is OutputPort;
    var pathFactory = bind canvas.pathFactory;
    var layoutEngine = bind canvas.layoutEngine;
    var imageLoader = bind canvas.imageLoader;
    var effectLoader = bind canvas.effectLoader;

    function onDown from (tv is OutputPort, e is MouseEvent) to () 
    {
        this.tv = tv;
        linkTmpLink();
        dx = 0; dy = 0;
        if (not e.shiftKey) {
            tv.unlink();
        }
        startPos = canvas.toLocal * e.sceneLocation;
        insert canvas.targetArrow into canvas.arrows;
        arrowVis = true;
        updateArrow();
    }

    function onDrag from (e is MouseEvent) to ()
    {
        if (tv == null) return;
        dx += e.drag.x;
        dy += e.drag.y;
        updateArrow();
    }

    function updateArrow to () 
    {
        const toLocal = canvas.toLocal;
        const sourcePos = toLocal * tv.toSceneTransform.getTranslation();
        linkStart.pos = sourcePos;
        linkEnd.pos = startPos + new Vec3(dx-1, dy, 0);
        canvas.targetArrow.tx = linkEnd.pos.x;
        canvas.targetArrow.ty = linkEnd.pos.y;
    }

    function onUp from (e is MouseEvent) to ()
    {
        if (tv == null) return;
        arrowVis = false;
        canvas.pickInput(e, tv.getOutputType(), function from (found is LinkedInputView) to () {
                tmpLink = null;
                delete canvas.targetArrow from canvas.arrows;
                link.unlink();
                if (found <> null and not (found is ShortcutTarget)) {
                    found.unlink();
                    const newlink = LinkView { 
                        canvas: canvas;
                        source: tv;
                        target: found;
                    };
                    newlink.link();
                }
                tv = null;
                canvas.dumpSrc();
                MasterUndoable.commit();
            });
        canvas.dropType = null;
    }
    var tmpLink is LinkView = null;
    var dx = 0.0;
    var dy = 0.0;
    var arrowVis is Boolean;
    var startPos is Point3;

    const linkStart is LinkedOutputView = LinkedOutputView {
        override function serialize to ExprNode { null }
	override var toSceneTransform = bind translate(pos);
    };
    const linkEnd is LinkedInputView = LinkedInputView {
        override function serialize to ExprNode { null }
	override var toSceneTransform = bind translate(pos);
    };

    const link is LinkView = LinkView {
	canvas: bind canvas;
    };

    function linkTmpLink to () 
    {
        link.source = linkStart;
        link.target = linkEnd;
        link.link();
        tmpLink = link;
    }

}


public class LinkInfo {
    override function toString {
	"source: {source}, {sourceIndex}, {sourcePos}; target: {target}, {targetIndex}, {targetPos}";
    }
    public var link is LinkView;
    public var source is LinkedView;
    public var sourcePos is Point3;
    public var sourceIndex is Integer;
    public var target is LinkedView;
    public var targetPos is Point3;
    public var targetIndex is Integer;
    override function equals from (obj is Object) to Boolean {
	if (obj is LinkInfo) then {
	    const x = obj as LinkInfo;
	    link == x.link and source == x.source and
		sourcePos == x.sourcePos and
		sourceIndex == x.sourceIndex and
		target == x.target and
		targetPos == x.targetPos and
		targetIndex == x.targetIndex;
	} else false
    }
}


class Holder is Group, Scissored {
}

class MemberListview is Listview of Member {
    public var targetPosition is Point3;
    public var canvas is Canvas;
    public var k is function from LinkedInputView to ();
    public var font is Text.Font;
    public var members is Member[];
    override var model = Listmodel of Member {
        size: bind members.size();
        override function getValue from (i is Integer) to Member 
        {
            members[i];
        }
    };
    override function render from (elem is Listview.Element of Member) to Node 
    {
        var m = elem.value;
        Group {
            content:
            [Rectangle {
                height: bind cellHeight;
                width: bind width;
                fillPaint: bind if elem.index == selectedRow then selectionBackground else background;
            },
            Text.Label {
                font: bind font;
                text: bind m.name;
                foreground: bind if elem.index == selectedRow then selectionForeground else foreground;
                background: null;
                height: bind cellHeight;
                width: bind width;
            }]
        }
    }
    const app = observeApply().subscribe(function from (m is Member) to () {
            if (m == null) {
                k(null);
            } else if (m == SHORTCUT) {
                k(canvas.createShortcutTarget(targetPosition));
            } else if (m == FORK) {
                const fork = canvas.createFork(targetPosition);
                k(fork.sourcePort);
            } else if (m == BRANCH) {
                const fork = canvas.createBranch(targetPosition);
                k(fork.sourcePort);
            } else {
                const f = canvas.createMemberView(targetPosition, m, 0) as FunctionView; // hack
                const i = if (f.fun.funMember.m.isStatic()) then 1 else 0;
                k(f.inputs[i]);
            }
        });
}

// hack...
var debugCanvas is Canvas;
var debugPC is ExpressionView;

public class ExprDebugger is DebuggerEngine {

    public var canvas is Canvas;

    var todo is (function from () to ())[];

    public function update to () {
        if (not (canvas.stepping and canvas.targetTimeline.paused) and todo.size() > 0) {
            var xs = todo;
            todo = [];
            for (x in xs) {
                x();
            }
        }
    }

    public override function step of a from (location is Object, x is a, k is Observer of a) to ()
    {
        if (canvas.stepping) {
            //canvas.makeVisible();
            const view = canvas.lookup(location.toString());
            debugCanvas.clearSelection();
            debugCanvas = canvas;
            const pc = view as ExpressionView;
            debugPC = pc;
            pc.select();
            pc.setDebugValue(x);
            println("STEP {location} => {view} event={x}");
            canvas.targetTimeline.paused = true;
            insert function from () to () { k.onNext(x) } into todo;
        } else {
            println("NOT STEPPING");
            update();
            if (canvas.interactive()) {
                k.onNext(x);
            }
        }
    }
}

var showSource is Boolean;

function canConvert from (target is F3Type, src is F3Type) to Boolean 
{
    if (target.isTypeVariable()) {
        return true;
    }
    if (src is F3FunctionType and target is F3FunctionType) {
        const f1 = target as F3FunctionType;
        const f2 = src as F3FunctionType;
        for (i in [0..<f1.minArgs()]) {
            const p1 = f1.getArgumentType(i);
            const p2 = f2.getArgumentType(i);
            const c = canConvert(p2, p1);
            println("convertible {p2} from {p1} => {c}");
        }
        const c1 = canConvert(f1.getReturnType(), f2.getReturnType());
        return c1;
    }
    const result = src == null or (target == UNIT_TYPE or observeType(target).isConvertibleFrom(src)) or
        (isMappable(src) and canConvert(target, getLoweredType(src)));
    println("{src} => {target} ====> { result }");
    return result;
    
}

public class Canvas is ResizableNode, Focusable, KeyboardInputHandler, Scrollable, MouseInputHandler {

    public const menuFactory is MenuFactory;

    public var go is function from Context to ();

    public var assetModel is AssetTree.AssetModel;

    var dropType is F3Type;
    
    bound function canAssignTo from (t is F3Type) to Boolean 
    {
        canConvert(t, dropType);
    }

    public var stepping is Boolean;

    public const debuggerEngine is ExprDebugger = ExprDebugger {
        canvas: this;
    }

    const treeLinker is TreeLinker = TreeLinker {
        canvas: this;
    };

    const viewLinker is ViewLinker = ViewLinker {
        canvas: this;
    };

    var popupDisp is Disposable;

    function getPopup from (e is MouseEvent, members is Member[], k is function from LinkedInputView to ()) to Node 
    {
       const r = MemberListview  {
            targetPosition: toLocal * e.picked.dragPoint1;
            canvas: this;
            k: k;
            font: font;
            transform: translate(popupScene.mousePosition.x + 100, popupScene.mousePosition.y, 0);
            members: [SHORTCUT, FORK, sort(members)];
            height: 200;
            width: 340; 
        }
        popupScene.setFocus(r);
        popupLayer.modal = true;
        popupDisp = popupLayer.observeBackgroundClicked.subscribe(function from (_ is ()) to () {
                println("BACKGROUND CLICKED");
                popupDisp.dispose();
                k(null)
            });
        return r;
    }

    public var interactive is function from () to Boolean;

    public var popupLayer is PopupLayer;
    public var popupScene is Scene;

    var prog is Program;

    function setSelection from (vs is ExpressionView[]) to () 
    {
        const set = new java.util.HashSet of ExpressionView;
        for (v in vs) {
            v.selected = true;
            set.add(v);
        }
        for (v in views) {
            if (not set.contains(v)) {
                v.selected = false;
            }
        }
        if (not set.contains(selectedExpr)) {
            selectedExpr = vs[0];
        } 
    }

    function setSelectedExpr from (e is ExpressionView) to ()
    {
        selectionRect.visible = false;
        selectedExpr.deselect();
        selectedExpr = e;
    }

    var selectedExpr is ExpressionView on replace old {
        old.deselect();
        if (selectedExpr <> null) {
            for (v in views where v <> selectedExpr) v.deselect();
            selectedExpr.selected = true;
            moveToFront(selectedExpr);
        }
    };

    function moveToFront from (exp is ExpressionView) to ()
    {
        if (exp == terminalExprView) {
            return;
        }
        if (exp <> views[views.size()-1])  {
            delete exp from views;
            insert exp after views[views.size()-1];
        }
    }
    override public bound function getTx to Number { 1.0-(cx + width/2.0) / width }
    override public bound function getSx to Number { 
        //Math.min(width / localSpace.contentBounds.width(), 1.0);
        //zoomx;
        .1
    }    

    override public bound function getTy to Number { (cy + height/2.0) / height }

    override public bound function getSy to Number { 
        //Math.min(height / localSpace.contentBounds.height(), 1.0);
        //zoomy;
        .2
    }

    override public function setX from (tx is Number, sx is Number) to ()
    {
        //println("SET X {tx} {sx}");
        cx = (0.5-tx) * width
        //zoomx = sx;
    }

    override public function setY from (ty is Number, sy is Number) to ()
    {
        //println("SET Y {ty} {sy}");
        cy = ty * height - height/2.0;
        //zoomy = sy;
    }

    public function onDrop from (where is Pick, m is Member) to ()
    {
        const r = createMemberView(toLocal * where.scenePoint, m, 0, true);
        setSelectedExpr(r);
        MasterUndoable.commit();
    }

    public function onDrop from (where is Pick, t is F3Type) to ()
    {
        const r = createTypeView(toLocal * where.scenePoint, t, 0);
        setSelectedExpr(r);
        MasterUndoable.commit();
    }

    function createShortcutTarget from (pt is Point3) to ShortcutTarget {
        ShortcutTarget {
            pos: pt;
        }
    }

    function createFork from (pt is Point3) to ForkView {
        const r = ForkView {
            canvas: this;
        }
        insert r into views;
        r.pos = new Point3(pt.x, pt.y, pt.z);
        return r;
    }

    function createBranch from (pt is Point3) to BranchView {
        const r = BranchView {
            canvas: this;
        }
        insert r into views;
        r.pos = new Point3(pt.x, pt.y, pt.z);
        return r;
    }

    function createTypeView from (pt is Point3, t is F3Type, offset is Integer) to ExpressionView
    {
        var r is ExpressionView;
        if (t is F3ClassType) {
            const classType = t as F3ClassType;
            if (classType.getTypeParameters() <> []) {
                r = ClassView {
                    canvas: this;
                    objectExpr: ClassTypeExpression {
                        classType: classType;
                    }
                }
            }
        }
        if (r == null) {
            r = TypeRefView {
                selectable: true;
                canvas: this;
                ref: TypeExpression { typeref: t }
            };
        }
        insert r into views;
        //r.pos = new Point3(pt.x+r.bounds.extent.x, pt.y + cellHeight*(offset+1), pt.z);
        r.pos= pt;
        return r;
    }

    function createMemberView from (pt is Point3, m is Member, offset is Integer) to ExpressionView
    {
        createMemberView(pt, m, offset, false);
    }

    function createMemberView from (pt is Point3, m is Member, offset is Integer, external is Boolean) to ExpressionView
    {
        var r is ExpressionView;
        if (m is FunctionMember) {
            const fun = Function {
                funMember: m as FunctionMember;
            }
            insert r = FunctionView { 
                canvas: this;
                fun: fun;
            } into views;
        } else {
            insert r = GetVarView {
                selectable: true;
                canvas: this;
                isLabeled: true;
                get: GetVar {
                    override public function getTerminals to Expression[] 
                    {
                        if (observers == []) then this else foreach (ob in observers) ob.getTerminals();
                    }
                    member: m;
                }
            } into views;
        }
        if (external) {
            r.pos = pt;
        } else {
            r.pos = new Point3(pt.x+r.bounds.extent.x, pt.y + cellHeight*(offset+1), pt.z);
        }
        return r;
    }

    public function onDrop from (where is Pick, clip is Context) to ()
    {
        if (clip is Context.ClosureVarContext) {
            const v = clip as Context.ClosureVarContext;
            var p = v.parent;
            while (p <> null) {
                if (p == eventContext or p == varContext) break;
                p = p.parent;
            }
            if (p == null) {
                p = eventContext.parent;
                while (p <> null) {
                    if (p == v.parent) {
                        break;
                    }
                    p = p.parent;
                }
            }
            if (p == null) return;
            if (v == subject) return;
            const names = new java.util.HashSet of String;
            const members = [foreach (m in introspectMembers(v) where not m.name.contains("pdate") and names.add(m.name)) m];
            const typ = v.varType.t;
            var r is ExpressionView;
            insert r = ObjectView {
                isLinkable: true;
                pos: toLocal * where.scenePoint;
                objectExpr: VarContextExpression { 
                    varContext: v, override function getType to F3Type { typ }
                    inputMembers: foreach (x in members where x.isObserver) x;
                    outputMembers: foreach (x in members where x.isObservable) x;
                }
                canvas: this;
            } into views;
            setSelectedExpr(r);
            MasterUndoable.commit();
        }
    }

    public function onDrop from (where is Pick, clip is Node) to ()
    {
	println("ON DROP {where.scenePoint}, {where.dragPoint1} {clip}");
	const typ = if (clip is SceneAPI) then Reflect.getType("expr.SceneAPI") else if (clip is TextAPI) then Reflect.getType("expr.TextAPI") else Reflect.getType("expr.NodeAPI");
        var names = new java.util.HashSet of String;
	const members = foreach (m in introspect(typ) where not m.name.contains("pdate") and names.add(m.name)) m;
        for (m in members) {
            println(m);
        }
        var r is ExpressionView;
	insert r=ObjectView {
	    pos: toLocal * where.scenePoint;
	    objectExpr: NodeExpression { 
                node: clip, override function getType to F3Type { typ }
                inputMembers: foreach (m in members where m.isObserver) m;
                outputMembers: thisMember(typ) 
            }
	    canvas: this;
	} into views;
        setSelectedExpr(r);
        MasterUndoable.commit();
    }

    public function onDrop from (where is Pick, clip is TimeNode) to ()
    {
	println("ON DROP {where.scenePoint}, {where.dragPoint1} {clip}");
	const typ = Reflect.getType("f3.media.scene.TimeNode");
        const names = ["pause", "play", "playFromStart", "reverse"];
	const members = foreach (x in introspect(typ), y in names where x.name == y) x;
	insert ObjectView {
	    pos: toLocal * where.scenePoint;
	    objectExpr: TimeNodeExpression { 
                timeNode: clip, override function getType to F3Type { typ }
                inputMembers: foreach (m in members where not m.isObservable and m.isObserver and m.t == UNIT_TYPE) m;
                outputMembers: thisMember(typ) 
            }
	    canvas: this;
	} into views;
        MasterUndoable.commit();
    }

    function gatherInputs from (link is LinkView, 
                                result is java.util.Set of ExpressionView, 
                                links is java.util.Set of LinkView) to ()
    {
        println("factor gather link: {link.id}, source {link.source.getClass()}");
        var src is ExpressionView = link.source;
        if (src is ResultView) {
            src = (src as ResultView).sourceView;
            result.add(src);
        } else if (src is ObjectOutputView) {
            src = (src as ObjectOutputView).sourceView;
            result.add(src);
        } else if (src is OutputPort) {
            src = (src as OutputPort).target;
            result.add(src);
        } else {
            result.add(src);
            links.add(link);
        }
        foreach (i in link.source.getInputLinks()) {
            gatherInputs(i, result, links);
        }
    }

    function parameterize from (ev is ExpressionView) to ()
    {
    }

    function shortcutPrompt from (self is ExpressionView, k is function from (ExpressionView, String) to ()) to ()
    {
        const canvas = this;
        const popupLayer = canvas.popupLayer;
        function handleCreate from (name is String, asset is TypeAsset) {
            k(self, name);
        }
        const createVar = CreateVar {
            isShortcut: true;
            assetModel: bind canvas.assetModel;
            popupLayer: bind popupLayer;
            popupScene: bind canvas.popupScene;
            create: function from (name is String, asset is AssetTree.TypeAsset) to () {
                handleCreate(name, asset);
                delete win from popupLayer.content;
                popupLayer.modal = false;
            }
            cancel: function to () {
                delete win from popupLayer.content;
                popupLayer.modal = false;
            }
        };
        println("SELF={self}");
        if (self is FunctionView) {
            const f = self as FunctionView;
            const t = f.fun.ft.getReturnType();
            println("t={t.getName()}");
            createVar.selectType(canvas.assetModel.findTypeAsset(t.getName()));
        }
        const win = InternalWindow {
            isMovable: false;
            isResizable: false;
            isTransient: true;
            gadget: Text.Label {
                text: "Create Shortcut";
                override var font = bind layoutEngine.createFont(Names.DEFAULT_FONT); 
                background: null;
                foreground: Shape2D.ColorPaint(Color.color(.8, .8, .8));
                transform: translate(2, 2);
            }
            containerBounds: bind Bounds.boundsFromRect(0, 
                                                        0, 
                                                        canvas.width,
                                                        canvas.height);
            content: createVar;
            height: 140, width: 300;
            //cx: e.sceneLocation.x, cy: e.sceneLocation.y;
        };
        win.cx = canvas.popupScene.mousePosition.x;
        win.cy = canvas.popupScene.mousePosition.y;
        insert win into popupLayer.content;
        //editorScene.setFocus(createVar.nameField);
        popupLayer.modal = true;
    }

    function factor from (ev is ExpressionView) to () {
        factorAs(ev, "shortcut");
    }

    function factorAs from (ev is ExpressionView, name is String) to ()
    {
        const linked = new java.util.HashSet of ExpressionView();
        const links = new java.util.HashSet of LinkView();
        linked.add(ev);
        foreach (link in ev.getInputLinks()) {
            gatherInputs(link, linked, links);
        }
        serializationMap.clear();
        for (e in linked) {
            serialize(e);
        }
        var todo = ExprScene {};
        println("factor views {linked}");
        for (e in serializationMap.values()) {
            insert e into todo.views;
        }
        for (link in links) {
            insert link.serialize() into todo.links;
        }
        if (ev is FunctionView) {
            const f = ev as FunctionView;
            const outLinks = f.output.getTree.getLinks();
            var paths is String[];
            var srcs is LinkedOutputView[];
            var targets is LinkedInputView[];

            const ctx = IContext {}
            var evExp = ev.expression;
            if (evExp is Function) {
                evExp = (evExp as Function).output;
            }
            if (evExp is Result) {
                evExp = (evExp as Result).observers[0];
            }
            const ipath = ctx.getIPath(evExp as ObserverExpression);
            var linkIds is String[];
            for (outLink in outLinks) {
                if (outLink.target <> null) {
                    insert outLink.source into srcs;
                    insert outLink.id into linkIds;
                    const path = getPath(outLink);
                    println("path={path}");
                    insert path.substring(0, path.lastIndexOf("/")) into paths;
                    for (p in paths) println("paths => {p}");
                    insert outLink.target into targets;
                    outLink.unlink();
                }
            }
            const t = f.fun.ft.getReturnType();
            const asset = assetModel.findTypeAsset(t.getName());
            println("ASSET {t.getName()} => {asset}");
            if (asset == null) {
               println("asset not found: {t.getName()}");
            }
            const v = ClosureVarContext {
                varType: asset;
                variableName: name;    
                parent: eventContext;
                isShortcut: true;
            }
            insert VarContextObjNode {
                varId: v.variableName;
                varType: v.varType.t.getName();
                inputs: TargetNode { targetId: targets[0].id, links: linkIds }
            } into todo.views;
            insert v into eventContext.content;
            const newExp = {
                const names = new java.util.HashSet of String;
                const members = [foreach (m in introspectMembers(v) where not m.name.contains("pdate") and names.add(m.name)) m];
                const typ = v.varType.t;
                ObjectView {
                    isLinkable: true;
                    objectExpr: VarContextExpression { 
                        varContext: v, override function getType to F3Type { typ }
                        //inputMembers: foreach (x1 in members where x1.isObserver) x1;
                        outputMembers: foreach (x1 in members where x1.isObservable) x1;
                    }
                    canvas: this;
                }
            }
            for (e in linked) {
                e.unlink();
                delete e from views;
            }
            var n = if (srcs[0] == null) then ev else srcs[0];
            var x = n.pos.x;
            var y = n.pos.y;
            newExp.pos = new Point3(x - (newExp.bounds.extent.x - n.bounds.extent.x), y, 0); 
            insert newExp into views;
            paths = ["/factored"];
            if (targets <> []) {
                for (path in paths) {
                    //const src = cell.linkedView;
                    const src = newExp.outputViews[0];
                    println("SOURCE of link = {src}");
                    const lnk = LinkView {
                        canvas: canvas;
                        pathFactory: canvas.pathFactory;
                        layoutEngine: canvas.layoutEngine;
                        imageLoader: canvas.imageLoader;
                        effectLoader: canvas.effectLoader;
                        source: src;
                        target: targets[indexof path];
                    }
                    lnk.link();
                    //insert lnk into this.links;
                }
            }
            const prog = Program {
                event: event;
                parent: this.prog;
                evalContext: Program.EvalContext {
                    interactive: interactive;
                    targetNode: targetNode;
                    debugger: debugger;
                    instanceSpace: instanceSpace;
                    lookupSpatial: targetSpace.lookup;
                    targetTimeline: targetTimeline;
                    lookupTemporal: targetTime.lookup;
                    eventContext: eventContext;
                    varContext: v;
                }
                code: todo;
            }
            const newCanvas = Canvas {
                go: bind go;
                assetModel: assetModel;
                menuFactory: menuFactory;
                interactive: interactive;
                stepping: bind stepping;
                debugger: debugger;
                popupLayer: popupLayer;
                popupScene: popupScene;
                pathFactory: pathFactory;
                width: width;
                height: height;
		targetNode: targetNode,
		event: event;
                eventContext: eventContext;
                subject: v;
                varContext: v;
		targetSpace: targetSpace;
		targetTime: targetTime;
		targetTimeline: targetTimeline;
                instanceSpace: instanceSpace;
            }
            v.program = prog;
            prog.canvas = newCanvas;
            newCanvas.prog = prog;
            prog.deserialize();
            prog.reset();
            prog.canvas.genSource();
            insert prog into targetNode.programs;
        }
    }

    bound var defaultFont = layoutEngine.createFont(Names.DEFAULT_FONT);

    readonly var font = bind defaultFont;

    var fontSize is Number = -1;

    var portPaint is Paint;

    var localSpace is Node;

    public var toLocal is Mat4 = bind localSpace.toSceneTransform.inverse();

    const BG = ColorPaint(Color.color(.9, .9, .9));
    const cellSelectedBg = ColorPaint(Color.color(.80, .80, .80));
    const cellBg = ColorPaint(Color.color(.7, .7, .7));
    const textFg = ColorPaint(Color.color(.2, .2, .2));
    const disabledTextFg = ColorPaint(Color.color(.6, .6, .6));
    const textBg = ColorPaint(Color.color(.85, .85, .85));
    const titleBg = ColorPaint(Color.color(.9, .9, .9));

    const ARROW_COLOR = Color.color(.2, .2, .2);

    const cellHeight is Number = 16;
    const cellWidth is Number = 200;

    const portArrow is Polygon = Polygon {
	points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
	fillPaint: ColorPaint(Color.WHITE);
    };

    function makeArrow from (c is Color) to MeshNode 
    {
	MeshNode {
	    mesh: bind portArrow.fillMesh.mesh;
	    shader: bind effectLoader.loadPaintShader(ColorPaint(c));
	}
    }

    const targetArrow is TransformNode = TransformNode {
	px: 3.5
	content: bind makeArrow(ARROW_COLOR);
    }

    public var event is Member;
    public var parameters is Context.ClosureVarContext[];
    public var subject is Context.ClosureVarContext;
    public var eventContext is Context.MemberContext;
    public var varContext is Context.ClosureVarContext;

    public var targetNode is ResourceTarget;

    public var targetSpace is Node;
    public var targetTime is TimeNode;
    public var targetTimeline is Timeline;
    public var instanceSpace is Group;

    public function lookupVar from (id is String) to Object 
    {
        return null;
    }

    public function lookupSpatial from (id is String) to Node 
    {
	var r = targetSpace.lookup(id);
	println("lookup {id} => {r}");
	return r;
    }

    public function lookupTemporal from (id is String) to TimeNode 
    {
	var r = targetTime.lookup(id);
	println("lookup {id} => {r}");
	return r;
    }

    function reset to ()
    {
	for (link in links) {
	    link.unlink();
	}
	links = [];
	unsubscribe();
    }

    const terminalView is TransformNode = TransformNode { 
        tx: bind (1.0/zoomx)*(width / 2.0 - cx) - 120;
        ty: bind (1.0/zoomy)*(height / 2 - cy) - 20;
        content: bind terminalExprView;
    };

    const initialView is TransformNode = TransformNode { 
        tx: bind (1.0/zoomx)*(-width / 2.0 - cx) + 120;
        ty: bind (1.0/zoomy)*(height / 2 - cy) - 20;
        content: bind initialExprView;  
    };

    public readonly var initialExprView is GetVarView = bind makeGetter(event);
    public readonly var terminalExprView is SetterView = bind makeSetter(subject);

    var subjectExp is Expression;

    var subjectNameListener is Disposable;

    function makeSetter from (c is Context.ClosureVarContext) to SetterView 
    {
        if (c == null) {
            return null;
        }
        subjectNameListener.dispose();
        subjectNameListener = Observables.observe(&c.variableName).subscribe(function from (n is String) to () 
                                                                        {
                                                                            dumpSrc();
                                                                        });
        var canvas = this;
        const result = SetterView {
            parent: terminalView;
            pathFactory: pathFactory;
            layoutEngine: layoutEngine;
            imageLoader: imageLoader;
            effectLoader: effectLoader;
            variable: c;
            canvas: bind canvas;
        }
        result.updateParent();
        subjectExp = result.expression;
        return result;
    }

    var varRoot is GetVar;

    function makeGetter from (event is Member) to GetVarView {
	if (event == null) then null else {
		var r = GetVarView {
		    parent: initialView;
		    canvas: this;
                    isLabeled: true;
                    override bound function getLabel to String { Names.formatName(event.name) }
		    get: varRoot = TreeGetVar {
                        override function toEnglish to String { "the event" }
                        override function getLocalAccess to String { "i" }
			member: event;
		    }
                    dragFilter: new Tuple3(1.0, 0.0, 0.0);
		}
		r.updateParent();
                MasterUndoable.commit();
		r;
	    }
    }

    var prevLinkInfo is LinkInfo[];

    var sourceUpdate = 0;
    var sourceVersion = 0;
    var sourceUpdateTime is Long = 0;

    override function update to () {
        super.update();
        debuggerEngine.update();
    }

    override function preupdate {
        if (sourceVersion > sourceUpdate) {
            const now = java.lang.System.currentTimeMillis();
            if (sourceUpdateTime < now) {
                genSource();
                sourceUpdate = sourceVersion;
            }
        }
	const curLinkInfo = getLinkInfo();
	if (curLinkInfo <> prevLinkInfo) {
	    prevLinkInfo = curLinkInfo;
	    linkMesh = genLines(curLinkInfo, zoomx, zoomy);
	}
	super.preupdate();
    }

    var cx is Number;
    var cy is Number;

    const canvas = this;

    var selectionPoint is Tuple3;

    var selectionRect = Rectangle {
        transform: bind translate(selectionPoint);
        visible: false;
        strokePaint: ColorPaint(Color.color(.2, .2, .2, 1));
        pickable: false;
        /*
        stroke: Stroke {
            miterlimit: 2;
            dash: [2];
        }
        */
    };

    function createFunctionFromSelection 
        from (result is java.util.Set of ExpressionView,
              links is java.util.Set of LinkView) 
        to Function
    {
        var bounds is Bounds;
        for (v in views where v.selected) {
            bounds = Bounds.merge(bounds, v.boundsInScene);
        }
        bounds = canvas.toLocal * bounds;
        var inputTypes is F3Type[];
        var outputTypes is F3Type[];
        for (link in canvas.links) {
            var src is ExpressionView = link.source;
            var target is ExpressionView = link.target;
            //println("src={src}");
            //println("target={target}");
            //println("bounds={bounds}, src={src.boundsInScene}, target={target.boundsInScene}");
            var containsSrc = bounds.contains(link.source.getLinkPos());
            var containsTarget = bounds.contains(link.target.getLinkPos());
            println("containsSrc={containsSrc}, containsTarget={containsTarget}");
            if (containsSrc and containsTarget) {
                // implementation
                links.add(link);
            } else if (containsSrc and not containsTarget) {
                // output
                println("output: {src.expression.getType()}");
                insert src.expression.getType() into outputTypes;
            } else if (containsTarget and not containsSrc) {
                // input
                println("input: {target.expression.getType()}");
                insert target.expression.getType() into inputTypes;
            } else {
                continue;
            }
            if (containsSrc) {
                if (src is ResultView) {
                    src = (src as ResultView).sourceView;
                    result.add(src);
                } else if (src is ObjectOutputView) {
                    src = (src as ObjectOutputView).sourceView;
                    result.add(src);
                } else {
                    result.add(src);
                }
            }
            if (containsTarget) {
                result.add(target);
            }
        }
        const ft = ctx.makeFunctionType(inputTypes, if outputTypes.size() > 0 then outputTypes[0] else Reflect.UNIT_TYPE);
        println("ft={ft}");
        var name = "extracted function";
        return Function {
            funMember: FunctionMember {
                m: F3FunctionMember {
                    override function getName to String {
                        name;
                    }
                    override function getDeclaringClass to F3ClassType {
                        null;
                    }
                    override function isStatic to Boolean { false }
                    override function isPublic to Boolean { true }
                    override function isPackage to Boolean { false }
                    override function isProtected to Boolean { false }
                    override function getType to F3FunctionType { return ft }
                    override function invoke from (owner is F3ObjectValue, args is nativearray of F3Value) to F3Value
                    {
                        null;
                    }
                }
            }
        }
    }

    function duplicateSelection from (pt is Point3) to ()
    {
        const selection = views[v | v.selected];
        if (selection.size() == 0) return;
        const linked = new java.util.HashSet of ExpressionView;
        const links = new java.util.HashSet of LinkView;
        var center is Vec3 = Vec3.<<0>>;
        for (v in selection) {
            linked.add(v);
            for (link in v.getInputLinks()) links.add(link);
            center += (v.pos - Point3.<<0>>);
        }
        center /= selection.size();
        serializationMap.clear();
        for (e in linked) {
            serialize(e);
        }
        const todo = ExprScene {};
        for (e in serializationMap.values()) {
            insert e into todo.views;
        }
        for (link in links) {
            insert link.serialize() into todo.links;
        }
        deserializationMap.clear();
        const newSelection = new java.util.HashSet of ExpressionView;
        for (v in todo.views) {
            const j = v.createView(this);
            j.pos += pt - center; 
            newSelection.add(j);
        }
        installLinks();
        for (v in views) {
            v.selected = newSelection.contains(v);
        }
        this.links = [this.links];
        this.views = [this.views];
        MasterUndoable.commit();
    }

    function extract from () to () 
    {
        const linked = new java.util.HashSet of ExpressionView();
        const links = new java.util.HashSet of LinkView();
        const fun = createFunctionFromSelection(linked, links);
        /*
        const ctx = FunctionDefinitionContext {
            inputs: for (p in fun.
        }

        const bounds = selectionRect.boundsInScene;
        for (v in views where bounds.contains(v.boundsInScene)) {
            serialize(v);
            for (link in v.getInputLinks()) gatherInputsInSelection(link, linked, links);
        }
        var todo = ExprScene {};
        println("extract views {linked}");
        for (e in serializationMap.values()) {
            insert e into todo.views;
        }
        for (link in links) {
            insert link.serialize() into todo.links;
        }
        const newExp = FunctionView {
            fun: fun
        }
        for (e in linked) {
            e.unlink();
            delete e from views;
        }
        const prog = Program {
            event: event;
            evalContext: Program.EvalContext {
                interactive: interactive;
                targetNode: targetNode;
                debugger: debugger;
                instanceSpace: instanceSpace;
                lookupSpatial: targetSpace.lookup;
                targetTimeline: targetTimeline;
                lookupTemporal: targetTime.lookup;
                eventContext: eventContext;
                varContext: v;
            }
            code: todo;
        }
        const newCanvas = Canvas {
            go: bind go;
            menuFactory: menuFactory;
            interactive: interactive;
            stepping: bind stepping;
            debugger: debugger;
            popupLayer: popupLayer;
            popupScene: popupScene;
            pathFactory: pathFactory;
            width: width;
            height: height;
            targetNode: targetNode,
            event: event;
            eventContext: eventContext;
            varContext: v;
            targetSpace: targetSpace;
            targetTime: targetTime;
            targetTimeline: targetTimeline;
            instanceSpace: instanceSpace;
        }
        prog.canvas = newCanvas;
        newCanvas.prog = prog;
        prog.deserialize();
        prog.reset();
        prog.canvas.genSource();
        insert prog into targetNode.programs;
        */
    }

    function modifySelection from (e is MouseEvent) to ()
    {
        const drag0 = selectionTransformInverse * e.dragStart;
        const drag1 = selectionTransformInverse * e.dragEnd;
        const drag = drag1 - drag0;
        selectionPoint += new Vec3(drag.x, drag.y, 0) / 2;
        selectionRect.width += drag.x;
        selectionRect.height += -drag.y;
        println("dragStart: {e.dragStart}, dragEnd: {e.dragEnd}, location: {e.location}, drag: {e.drag}");
        println("modified selection : {selectionPoint.x}, {selectionPoint.y}, {selectionRect.width}, {selectionRect.height}");
        println("BOUNDS fill={selectionRect.fillMesh.bounds}");
        println("BOUNDS stroke ={selectionRect.strokeMesh.bounds}");
        println("CONTENT BOUNDS={selectionRect.contentBounds}");
        println("BOUNDS={selectionRect.bounds}");
        println("BOUNDS IN SCENE={selectionRect.boundsInScene}");
    }
        
    function endSelection from (e is MouseEvent) to ()
    {
        canvas.setSelectedExpr(null);
        const selected = new java.util.HashSet of ExpressionView;
        for (v in views) {
            if (Bounds.intersect(v.bounds, selectionRect.bounds) <> null) {
                selected.add(v)
            }
        }
        for (v in views) {
            v.selected = selected.contains(v)
        }
        selectionRect.visible = false;
    }
        
    function beginSelection from (e is MouseEvent) to ()
    {
        selectionRect.visible = true;
        selectionPoint = selectionTransformInverse * e.location;
        selectionRect.width = 0;
        selectionRect.height = 0;
        println("begin selection: {e}");
    }

    var mousePosition is Point3;

    const bgRect = Rectangle {
        factory: canvas.pathFactory;
        id: "canvas.bg"
        debug: true;
        width: bind width;
        height: bind height;
        fillPaint: bind ColorPaint(Color.color(.9, .9, .9));
        var panning is Boolean;
        var selecting is Boolean;
        override function onMouseMove from (e is MouseEvent) to ()
        {
            mousePosition = e.location;
        }
        override function onMouseDown from (e is MouseEvent) to ()
        {
            if (e.isMouseButton1Down()) {
                panning = e.ctrlKey;
                selecting = not panning;
                if (selecting) {
                    beginSelection(e);
                }
            } else if (e.isMouseButton2Down()) {
                panning = true;
                selecting = false;
            } else if (e.isMouseButton3Down()) {
                // popup menu
                const menu = Menu {
                    items: 
                    [MenuItem {
                        label: "Parameterize";
                        action: canvas.extract
                    },
                    MenuItem {
                        label: "Delete";
                        action: canvas.deleteSelection;
                    }
                    MenuItem {
                        label: "Collapse";
                        action: function to () { canvas.collapseSelection(e.location) }
                    }
                    MenuItem {
                        label: "Duplicate";
                        action: function to () { canvas.duplicateSelection(e.location) }
                    }]
                }
                println("menu factory => {menuFactory}");
                e.stage.showPopupMenu(e.screenx, e.screeny, menu);
            }
        }

        override function onMouseUp from (e is MouseEvent) to ()
        {
            if (panning) {
                panning = false;
            } else if (selecting) {
                endSelection(e);
                selecting = false;
            }
        }

        override function onMouseDrag from (e is MouseEvent) to ()
        {
            if (panning) {
                const d = (e.picked.dragPoint1-e.picked.dragPoint0);
                //println("drag={e.drag}, sceneDrag={e.sceneDrag}");
                canvas.cx += d.x;
                canvas.cy += d.y;
            } else if (selecting) {
                modifySelection(e)
            }
        } 	
    };

    const sourceCode = XHTML.Text {
        width: bind width;
        style: "body \{ font-family:Lucida Grande; font-weight:normal; font-size: 11pt; color: #2B1B17; \} a:link \{ text-decoration:none; \} a:hover \{text-decoration:underline;\}";
        transform: bind translate(-width/2, -height/2);
        content: bind if not showSource then "<a href='source://'>Source Code</a>" else "<a href='graph://'>Hide</a><p/><div>{englishOutput}</div>";
        visible: bind englishOutput <> "";
    };

    var zoomx = 1.0 on replace { println("ZOOM => {zoomx}") }
    var zoomy = 1.0;

    const linkHandler = sourceCode.observeLinkClicked().subscribe(function from (u is String) to () 
                                                                  {
                                                                      println("link clicked: {u}");
                                                                      println("prog={prog}");
                                                                      println("prog.sourceCode={prog.sourceCode}");
                                                                      if (u.startsWith("expr:")) {
                                                                          const id = u.substring(5);
                                                                          var target is ExpressionView;
                                                                          for (v in views) {
                                                                              if (v.expression.id == id) {
                                                                                  target = v;
                                                                                  break;
                                                                              }
                                                                          }
                                                                          if (target == null) {
                                                                              foldLeft((), 
                                                                                       function from (_ is (), n is Node) to ()
                                                                                       {
                                                                                           println("n={n}");
                                                                                           if (n is ExpressionView) {
                                                                                               const e = n as ExpressionView;
                                                                                               if (e.expression.id  == id) target = e;
                                                                                           } else if (n is MemberTreecell) {
                                                                                               const c = n as MemberTreecell;
                                                                                               if (c.linkedView.id == id) target = c.linkedView;
                                                                                           }
                                                                                       });
                                                                          }
                                                                          println("target=>{target}");
                                                                          if (target == null) {
                                                                              for (link in links) {
                                                                                  if (link.source.id == id) {
                                                                                      target = link.source;
                                                                                      break;
                                                                                  } else if (link.target.id == id) {
                                                                                      target = link.target;
                                                                                      break;
                                                                                  }
                                                                              }
                                                                          }
                                                                          println("target=>{target}");
                                                                          if (target <> null) {
                                                                              clearSelection();
                                                                              target.select();
                                                                              MasterUndoable.commit();
                                                                          }
                                                                      } else {
                                                                          showSource = (u == "source://");
                                                                      }
                                                                  });
    
    readonly var selectionTransform = bind translate(cx, cy) * scale(zoomx, zoomy);
    readonly var selectionTransformInverse = bind selectionTransform.inverse();

    override var internalContent = Holder { 
	//scissorBounds: bind bgRect.bounds;
	content:
	Group {
	    content:
           [Group { content: bind [bgRect, sourceCode] },
	   Group 
           { 
               content: localSpace = Group {
                   transform: bind selectionTransform;
	           content: 
                   [Group { content: bind initialView }, Group {content: bind terminalView}, Group { content: bind views },
                   MeshNode {
                       id: "lines"
                       pickable: false;
                       override var mesh = bind linkMesh;
                       shader: effectLoader.loadPaintShader(ColorPaint(Color.color(.1, .1, .1)));
                   },
                   Group { content: bind arrows},
                   Group { content: bind selectionRect}, 
                   if true then null else Rectangle { height: 2, width: 2, fillPaint: ColorPaint(Color.RED) },
                   if true then null else Rectangle { 
                       height: bind frameBounds.height(); 
                       width: bind frameBounds.width(); 
                       transform: bind translate(frameBounds.center);
                       fillPaint: ColorPaint(Color.color(1, 1, 0, 0.2));
                       pickable: false;
                   } ]
               }
           }]
        };
    };

    override function loseFocus to Boolean {
        clearSelection();
        return Focusable.loseFocus();
    }

    public function clearSelection to ()
    {
        selectedExpr = null;
        for (v in views) v.selected = false;
    }

    
    function moveSelection from (amount is Tuple3) to ()
    {
        for (v in views where v.selected) v.pos += amount;
    }

    public function collapseSelection from (p is Point3) to ()
    {
        var allInputs is InputView[];
        var allOutputs is OutputView[];
	const termset = new java.util.HashSet of Expression();
        var terms is Expression[];
        const context = IContext {html: false, showHoles: true};
        for (v in views where v.selected) {
            const inputs = v.getOpenInputs();
            const outputs = v.getOpenOutputs();
            insert inputs into allInputs;
            insert outputs into allOutputs;
            for (i in v.getInputLinks()) {
                const targ = i.target;
                const terms0 = targ.expression.getTerminals();
                println("terms0 for {targ} =>{terms0}");
                for (t in terms0) {
                    if (termset.add(t)) {
                        insert t into terms;
                    }
                }
            }
        }
        var eng = "";
        println("TERMS=>{terms}");
        for (term in terms) {
            var t = term;
            if (t is Result) {
                t = (t as Result).observers[0];
            }
            const p1 = context.getIPath(t as ObserverExpression);
            println("p1={p1} =>{p1.getEnglishAccess()}");
            eng = "{eng}{p1.getEnglishAccess()}. ";
        }

        const memberList = [ typeToMember(UNIT_TYPE), foreach (i in allInputs) {
                const exp = i.expression;
                if (exp is MemberExpression) then (exp as MemberExpression).member else typeToMember(exp.getType());
            }];
        const objExpr = CollapsedExpression {
            synthName: eng;
            inputMembers: memberList;
            override var inputs = foreach (i in allInputs) {
                InputExpressionRef {
                    target: this;
                    ref: i.expression;
                    member: memberList[indexof i];
                }
                
            }
            outputMembers: foreach (i in allOutputs) {
                const exp = i.expression;
                if (exp is MemberExpression) then (exp as MemberExpression).member else typeToMember(exp.getType());
            }
            override var outputs = foreach (i in allOutputs) {
                OutputExpressionRef {
                    source: this;
                    ref: i.expression;
                    member: memberList[indexof i];
                }
                
            }
        }
        const canvas = this;
        const objv = ObjectView {
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
            canvas: canvas;
            override bound function getLabel to String { eng }
            objectExpr: objExpr;
            pos: p;
        }
        for (j in allInputs) {
            const link = j.links[0];
            const source = link.source;
            link.unlink;
            link.source = source;
            link.target = objv.inputViews[indexof j+1];
            link.link();
        }
        for (j in allOutputs) {
            const link = j.links[0];
            const target = link.target;
            link.unlink;
            link.target = target;
            link.source = objv.outputViews[indexof j];
            link.link();
        }
        deleteSelection();
        insert objv into views;
    }

    public function deleteSelection to () 
    {
        const toDelete = views[v | v.selected];
        const toKeep = views[v | not v.selected];
        selectedExpr = null;
        println("DELETING {toDelete.size()} views");
        if (toDelete <> []) {
            for (n in toDelete) {
                n.unlink();
            }
            views = toKeep;
            MasterUndoable.commit();
            dumpSrc();
        }
    }

    function selectAll to ()
    {
        for (v in views where v.selectable) {
            v.selected = true;
        }
    }

    override function onKeyDown from (e is KeyboardEvent) to () 
    {
        if (e.keyCode == Keys.Delete or e.keyCode == Keys.Backspace) {
            deleteSelection();
        } else if (e.keyCode == Keys.F) {
            frameContent();
        } else if (e.keyCode == Keys.W and e.ctrlKey) {
            duplicateSelection(mousePosition);
        } else if ((e.keyCode == Keys.Equals and e.shiftKey) or e.keyCode == Keys.Plus) {
            zoomOut();
        } else if (e.keyCode == Keys.Equals) {
            resetZoom();
        } else if (e.keyCode == Keys.Minus) {
            zoomIn();
        } else if (e.keyCode == Keys.A and e.metaKey) {
            selectAll();
        }
    }

    function zoomIn to ()
    {
        if (fontSize < 0) {
            fontSize = font.height();
        }
        const smaller = fontSize-1.0;
        zoomx = zoomy = smaller / font.height();
        fontSize = smaller;
        MasterUndoable.commit();
    }

    function resetZoom to ()
    {
        fontSize = font.height();
        zoomx = zoomy = 1.0;
        cx = cy = 0;
        MasterUndoable.commit();
    }

    function zoomOut to ()
    {
        if (fontSize < 0) {
            fontSize = font.height();
        }
        const bigger = fontSize+1.0;
        zoomx = zoomy = bigger / font.height();
        fontSize = bigger;
        MasterUndoable.commit();
    }

    function frameContent to ()
    {
        cx = cy = 0;
        zoomx = zoomy = 1;
        var bounds is Bounds;
        for (v in views where v.selected) bounds = Bounds.merge(bounds, v.boundsInScene);
        if (bounds == null) {
            for (v in views) bounds = Bounds.merge(bounds, v.boundsInScene);
        }
        bounds = toSceneTransform.inverse() * bounds;
        const w = bounds.width();
        const h = bounds.height();
        const max_zoom = Math.max(1.0, (width-100) / ((if terminalExprView <> null then 2  else 1) * cellWidth + 20));
        const zoom = Math.min(max_zoom, Math.min(height / (h+100), width / (w+100)));
        frameBounds = bounds;
        cx = -bounds.center.x * zoom;
        cy = -bounds.center.y * zoom;
        zoomx = zoom;
        zoomy = zoom;
        MasterUndoable.commit();
    }

    var frameBounds is Bounds;

    override function onMouseWheel from (e is MouseWheelEvent) to ()
    {
        if (e.metaKey) {
            zoomy *= 1.0 + e.scroll.y * 0.1;
            zoomx = zoomy;
            MasterUndoable.commit();
        }
    }

    public var views is ExpressionView[] = [] on replace { canvas.dumpSrc() }

    var arrows is TransformNode[];

    public var links is LinkView[] on replace { canvas.dumpSrc() }

    var lines = LineMesh {};

    var linkMesh is AbstractMesh;

    function getLinkInfo to LinkInfo[] 
    {
	foreach (link in links where link.visible) {
	    var source = link.source;
	    var sourcePos = source.getLinkPos();
	    var target = link.target;
	    var targetPos = target.getLinkPos();
	    makeLinkInfo(link, 
			 source,
			 link.sourceLinkId,
			 sourcePos,
			 target,
                         link.targetLinkId,
			 targetPos);
	}
    }

    function makeLinkInfo 
	from (link is LinkView,
	      source is LinkedView,
	      sourceIndex is Integer,
	      sourcePos is Point3,
	      target is LinkedView,
	      targetIndex is Integer,
	      targetPos is Point3) 
	to LinkInfo
    {
	LinkInfo {
	    link: link;
	    source: source;
	    sourceIndex: sourceIndex;
	    sourcePos: sourcePos;
	    target: target;
	    targetIndex: targetIndex;
	    targetPos: targetPos;
	}
    }

    const lineOff is Vec3 = new Vec3(15, 0, 0);
    const lineOff1 is Vec3 = new Vec3(18.5, 0, 0);

    function genLines from (links is LinkInfo[], zoomx is Number, zoomy is Number) to AbstractMesh 
    {
	lines.reset();
	delete arrows[links.size()..];
	while (arrows.size() < links.size()) {
	    insert TransformNode { content: makeArrow(ARROW_COLOR) } into arrows; 
	}
        var lineOff = this.lineOff;
        var lineOff1 = this.lineOff;
	for (i in links) {
	    const p0 = i.sourcePos;
	    const sourceOff = lineOff*(i.sourceIndex+1);
            const srcCount = i.source.links.size();
	    const p1 = p0 + sourceOff;
	    const p5 = i.targetPos-lineOff1*(i.targetIndex);
            const targetCount = i.target.links.size();
	    const targetOff = lineOff*(i.targetIndex+1);
	    const p4 = i.targetPos - targetOff;
	    const mid = p1.lerp(0.5, p4);
	    const p2 = new Point3(p1.x, mid.y, 0);
	    const p3 = new Point3(p4.x, mid.y, 0);
	    const p6 = i.targetPos;
	    lines.moveTo(p0);
	    lines.lineTo(p1);
	    lines.lineTo(p2);
	    lines.lineTo(p3);
	    lines.lineTo(p4);
	    lines.lineTo(p5);
	    lines.lineTo(p6);
	    arrows[indexof i].tx = p6.x;
	    arrows[indexof i].ty = p6.y;
	    //println("gen lines {p0} {p1} {p2} {p3} {p4} {p5}");
	}
	const mesh = lines.getMesh();
	mesh.updateBounds();
	return mesh;
    }


    function pickOutput from (e is MouseEvent, t is F3Type) to ExpressionView 
    {
	for (p in e.scene.underMouse) {
	    const n = p.node;
	    if (n is ResultView) {
		const rv = n as ResultView;
		if (rv.result.getType().isConvertibleFrom(t)) {
		    return rv;
		}
	    }
	}
	null;
    }

    function endPickInput to ()
    {
        dropType = null;
    }

    function pickInput 
	from (e is MouseEvent, 
	      t is F3Type,
              k is function from LinkedInputView to ()) 
	to ()
    {
        var hit = false;
	for (p in e.scene.underMouse) {
	    const n = p.node;
            if (not hit) { hit = n is ExpressionView }
	    if (n is LinkedInputView) {
		const pv = n as LinkedInputView;
		if (canConvert(pv.getInputType(), t)) {
		    println("IS ASSIGNABLE {pv.getClass()} {pv.getInputType()} <- {t}");
		    k(pv);
                    return;
		} else {
		    println("NOT ASSIGNABLE {pv.getInputType()} <- {t}");
		}
	    }
	}
        if (hit) {
            k(null);
            return;
        }
        println("introspecting: {t}");
        var members = introspect(t, true);
        println("members=>{members}");
        if (t is F3ClassType) {
            members = members[m | m.m == null or not m.m.isStatic()];
        }
        if (isMappable(t)) {
            const t1 = (t as F3ClassType).getTypeArguments()[0];
            println("is mappable {t} => {t1}");
            members = [introspect(t1, true), members];
            if (t1 is F3ClassType) {
                members = members[m | m.m == null or not m.m.isStatic()];
            }
        }
        if (members <> []) {
            var popup is Node = getPopup(e, members, function (j is LinkedInputView) to () {
                    delete popupLayer.content;
                    popupLayer.modal = false;
                    popupDisp.dispose();
                    k(j)
                });
            println("POPUP AT {popup} => {e.sceneLocation}");
            insert popup into popupLayer.content;
        } else {
            k(null);
        }
    }

    function dumpSrc to () {
        sourceVersion++;
        sourceUpdateTime = java.lang.System.currentTimeMillis()+1000;
        const x = new java.util.HashSet of ExpressionView();
        const y = new java.util.ArrayList of FunctionView;
        for (v in views where v is FunctionView) {
            const f = v as FunctionView;
            f.ununify();
            for (j in f.getInputLinks()) {
                unifyInputs(j, x, y);
            }
            if (x.add(f)) {
                y.add(f);
            }
        }
        println("UNIFICATION ORDER:");
        for (v in y) { println(v) }
        for (v in y) {
            v.unify2();
        }
    }

    public function genSource to () {
	println("DUMP SRC:");
	unsubscribe();
	println(visit(varRoot, foreach (v in views where v.expression <> varRoot and v is GetVarView) v.expression));
        prog.parent.canvas.genSource();
    }

    const serializationMap = new java.util.IdentityHashMap of (ExpressionView, ExprNode);
    public const deserializationMap = new java.util.HashMap of (String, LinkView);

    public function installLinks to () 
    {
        println(deserializationMap);
        for (j in deserializationMap.values()) {
            if (j.source <> null and j.target <> null) {
                j.link();
                println("installLinks: linked {j.id} {j.source} to {j.target}");
                insert j into links;
            } else {
                println("installLinks: bad link: {j}");
            }
        }
        deserializationMap.clear();
    }

    function getLink from (id is String) to LinkView 
    {
        var result = deserializationMap.get(id);
        if (result == null) {
            result = LinkView {
                canvas: this;
            }
            deserializationMap.put(id, result);
        }
        return result;
    }

    function serialize from (e is ExpressionView) to ExprNode 
    {
        if (e == null) return null;
        const r = serializationMap.get(e);
        //println("serializing: { e } => { r }");
        if (r <> null) return r;
        return e.serialize();
    }

    public function clear to ()
    {
        delete views;
        delete links;
    }

    function saveCode to () 
    {
        if (links.size() == 0 and views.size() <= 1) {
            prog.code = null;
            prog.sourceCode = "";
        } else {
            serializationMap.clear();
            serialize(initialExprView);
            if (terminalExprView <> null) {
                serialize(terminalExprView);
            }
            const w = new java.io.StringWriter();
            //println("root={initialExprView} => {serializationMap.get(initialExprView)}");
            for (obj in views) {
                var x = serialize(obj);
                println("serialize {obj} => {x}");
            }
            var todo = ExprScene {};
            foreach (j in serializationMap.values()) {
                if (j is LinkNode) {
                    //insert j as LinkNode into todo.links;
                } else {
                    insert j into todo.views;
                }
            }
            for (link in links) {
                insert link.serialize() into todo.links;
            }
            //IO.writeObject(w, todo);
            //println("serialize => {w}");
            prog.code = todo;
        }
    }

    var englishOutput is String;
    
    function visit from (e is Expression, es is Expression[]) to String
    {
        saveCode();
	const termset = new java.util.HashSet of Expression();
        var terms is Expression[];
        var terms2 is Expression[];
        for (term in e.getTerminals()) {
            if (termset.add(term)) {
                insert term into terms;
            }
        }

        for (x in es, term in x.getTerminals()) {
            if (termset.add(term)) {
                insert term into terms2;
            }
        }

        const mem = e as MemberExpression;
	var itype = if mem.member.m.isStatic() then OBJECT_TYPE else mem.member.m.getDeclaringClass();
        if (itype == null) return "";
	var result = "var _ = function from (debugger is f3.util.ObservableDebugger, i$ is Object, getVar is function from String to Object, getNode is function from String to f3.media.scene.Node, getClip is function from String to f3.media.scene.TimeNode, $register is function from (Object) to ()) to (f3.util.Observable of ?)[] \{ var i0 = i$ as {itype.getName()};  var obsvbs$ is f3.util.Observable[]; \{ ";
        if (terms == []) {
            var rs = foreach (x in eventContext.content) {
                if (x is Context.ResourceNodeContext) {
                    (x as Context.ResourceNodeContext).resource;
                } else null;
            }
            if (rs <> []) {
                terms = [varRoot];
            }
        }
        var context = IContext {};
        println("IPath");
        var ret = " \} return obsvbs$;";
        var sep = "";
        for (term in terms) {
            var t = term;
            if (t is Result) {
                t = (t as Result).observers[0];
            }
            const p = context.getIPath(t as ObserverExpression);
        }
        var eng = "";
        if (subjectExp <> null) {
            for (link in terminalExprView.getInputLinks()) {
                context.getIPath(link.target.expression as ObserverExpression);
            }
            const t = terminalExprView.getInputLinks()[0].target.expression as ObserverExpression;
            var init = nil(subject.varType.t);
            if (t <> null) {
                const p = context.getIPath(t);
                const j = p.getWorldAccess();
                eng = "{p.getEnglishAccess()}";
                init = j;
                println("code => {j}");
            } else {
                eng = "Assign {nil(subject.varType.t)} to <i>{subject.variableName}</i>";
            }
            if (subject.isShortcut) {
                prog.defineVar(subject, "var <<{subject.variableName}>> is {subject.varType.t.getName()} = {init};");
            } else if (subject.isSubject) {
                prog.defineVar(subject, "var <<{subject.variableName}>> is f3.util.Subject of {subject.varType.t.getName()}; <<{subject.variableName}.onNext({init}); <<{subject.variableName}>>");
            } else {
                prog.defineVar(subject, "var _ = function from (i$ is Object, <<{subject.variableName}>> is f3.lang.Ref of {subject.varType.t.getName()}) to () \{ {init}; \}");
            }
            englishOutput = eng;
        } else {
            context.dump();
            for (term in terms) {
                var t = term;
                if (t is Result) {
                    t = (t as Result).observers[0];
                }
                const p = context.getIPath(t as ObserverExpression);
                const d = p.getContainingObservableDepth();
                var app = mem.member.toApply();
                if (not mem.member.m.isStatic()) {
                    app = "i0.{app}";
                }
                //                result = "{result} const obs{p.getRootId()} = foreach (i in {app}) \{ %VARS%; {p.getWorldAccess()} \}";
                result = "{result} \{ const obs0 = foreach (i in {app}) \{ $register(i); %VARS%; {p.getWorldAccess()} \}";
                result = "{result} insert obs{p.getContainingObservableDepth()} into obsvbs$; \} ";
                sep = ", ";
                println(p.getWorldAccess());
                eng = "{eng}For each {formatEnglishName(mem.member.name)} event: ";
                eng = "{eng}{p.getEnglishAccess()}. ";
            }
            if (eng == "") {
                eng = "For each {formatEnglishName(mem.member.name)} event: the event";
            }
            englishOutput = eng;
            result = "{result}{ret};\}";
            try {
                const toCompile = result;
                println("compiling: {toCompile}");
                prog.evaluate(if terms.size() == 0 then "" else toCompile);
            } catch (thr is java.lang.Throwable) {
                thr.printStackTrace();
            }
        }
	result;
    }

    public const debugger is ObservableDebugger;
    
    function unsubscribe {
        prog.reset();
    }

    const undoList = expr.undo.UndoList {} on replace {
	undoList.addTarget("links", &links);
	undoList.addTarget("views", &views);
	undoList.addTarget("cx", &cx);
	undoList.addTarget("cy", &cy);
	undoList.addTarget("zoomx", &zoomx);
	undoList.addTarget("zoomy", &zoomy);
    }
}

public class MemberNode {
    public var name is String;
    public var declaringClass is String;
    public var outputType is String;
    public var isStatic is Boolean;
    public function deserialize to Member 
    {
        const clazz = Reflect.getType(declaringClass) as F3ClassType;
        const members = introspect(clazz, isStatic);
        for (m in members) {
            if (m.name == name) {
                return m;
            }
        }
        return null;
    }
}

public class VarMemberNode is MemberNode {
}

public class FunctionMemberNode is MemberNode {
    public var inputTypes is String[];
    public var isInfix is Boolean;
    override public function deserialize to Member {
        FunctionMember { m: Reflect.getFunction(declaringClass, name, inputTypes), isInfix: isInfix }
    }
}

public class ExprNode {
    public var id is String;
    public var x is Number;
    public var y is Number;
    public var member is MemberNode;
    public function createView from (canvas is Canvas) to ExpressionView 
    {
        println("implement me!: {this}");
        return null;
    }
}

public class TypeRefNode is ExprNode {
    public var typeName is String;
    public var outputs is SourceNode[];
    override public function createView from (canvas is Canvas) to ExpressionView 
    {
        const t = Reflect.getType(typeName);
        var r is TypeRefView;
        r = TypeRefView {
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
            selectable: true;
            canvas: canvas;
            ref: TypeExpression { typeref: t }
            pos: new Point3(x, y, 0);
        }
        insert r into canvas.views;
        for (p in outputs) {
            const path = p.sourceId;
            const tn = r.getTree.treeModel.resolvePath(path);
            if (tn.parent <> null) {
                tn.open();
            }
            println("path={path} tn={tn}");
            for (link in p.links) {
                const lnk = canvas.getLink(link);
                const cell = r.getTree.getCell(tn);
                const t1 = cell.linkedView;
                println("t1={t1}");
                lnk.source = t1;
                cell.link();
            }
        }
        r;
    }
}

public class ExprScene {
    public var views is ExprNode[];
    public var links is LinkNode[];
}

public class ForkNode is ExprNode {
    public var input is TargetNode;
    public var outputs is SourceNode[];
    public override function createView from (canvas is Canvas) to ForkView {
        const v = ForkView {
            canvas: canvas;
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
        }
        {
            var n = input;
            const p = v.sourcePort;
            if (n.links.size() > 0) {
                for (link in n.links) {
                    const lnk = canvas.getLink(link);
                    lnk.target = p;
                }
            } 
        }
        v.targetCount = outputs.size();
        for (p in outputs) {
            if (p.links.size() > 0) {
                for (link in p.links) {
                    const lnk = canvas.getLink(link);
                    lnk.source = v.targetPorts[indexof p];
                }
            }
        }
        v.pos = new Point3(x, y, 0);
        insert v into canvas.views;
        return v;
    }
}

public class BranchNode is ExprNode {
    public var input is TargetNode;
    public var outputs is SourceNode[];
    public override function createView from (canvas is Canvas) to BranchView {
        const v = BranchView {
            canvas: canvas;
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
        }
        {
            var n = input;
            const p = v.sourcePort;
            if (n.links.size() > 0) {
                for (link in n.links) {
                    const lnk = canvas.getLink(link);
                    lnk.target = p;
                }
            } 
        }
        v.targetCount = outputs.size();
        for (p in outputs) {
            if (p.links.size() > 0) {
                for (link in p.links) {
                    const lnk = canvas.getLink(link);
                    lnk.source = v.targetPorts[indexof p];
                }
            }
        }
        v.pos = new Point3(x, y, 0);
        insert v into canvas.views;
        return v;
    }
}


public class FunNode is ExprNode {
    public var typeInputs is TargetNode[];
    public var inputs is TargetNode[];
    public var outputs is SourceNode[];
    public override function createView from (canvas is Canvas) to FunctionView {
        var m = member.deserialize();
        const v = FunctionView {
            canvas: canvas;
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
            fun: Function {
                funMember: m as FunctionMember;
            }
        }
        linkView(canvas, v);
    }
    protected function linkView from (canvas is Canvas, v is FunctionView) to FunctionView {
        const m = v.fun.funMember;
        for (n in typeInputs) {
            var i = indexof n;
            const p = v.typeInputs[i];
            if (n.links.size() > 0) {
                for (link in n.links) {
                    println("linking type input {indexof n} linkId={link}");
                    const lnk = canvas.getLink(link);
                    lnk.target = p;
                }
            } 
        }
        for (n in inputs) {
            var i = indexof n;
            const p = v.inputs[i];
            if (n.links.size() > 0) {
                for (link in n.links) {
                    println("linking parameter {indexof n} linkId={link}");
                    const lnk = canvas.getLink(link);
                    lnk.target = p;
                }
            } 
            println("parameter {i} type is {p.parameter.getType()}");
        }
        for (n in inputs) {
            var i = indexof n;
            const p = v.inputs[i];
            if (Reflect.INTEGER_TYPE.isConvertibleFrom(p.getInputType())) {
                p.parameter.constantValue = n.intValue;
            } else if (Reflect.NUMBER_TYPE.isConvertibleFrom(p.getInputType())) {
                p.parameter.constantValue = n.numberValue;
            } else if (Reflect.BOOLEAN_TYPE.isConvertibleFrom(p.getInputType())) {
                p.parameter.constantValue = n.booleanValue;
            } else if (Reflect.STRING_TYPE.isConvertibleFrom(p.getInputType())) {
                p.parameter.constantValue = n.stringValue;
            }
            p.noteConstantValue(p.constValue);
        }
        for (p in outputs) {
            println("output: {p}");
            if (p.links.size() > 0) {
                const path = p.sourceId;
                const tn = v.output.getTree.treeModel.resolvePath(path);
                if (tn.parent <> null) {
                    tn.open();
                }
                println("path={path} tn={tn}");
                for (link in p.links) {
                    const lnk = canvas.getLink(link);
                    const cell = v.output.getTree.getCell(tn);
                    const t = cell.linkedView;
                    println("t={t}");
                    lnk.source = t;
                    cell.link();
                }
            }
        }
        v.pos = new Point3(x, y, 0);
        insert v into canvas.views;
        return v;
    }
}

public class LinkNode is ExprNode {
    public var source is String;
    public var target is String;
}

public class ObjNode is ExprNode {
    public var inputs is TargetNode[];
    public var outputs is SourceNode[];
}

public class NodeObjNode is ObjNode {
    public var nodeId is String;
    public override function createView from (canvas is Canvas) to ObjectView 
    {
        const clip = canvas.lookupSpatial(nodeId);
	const typ = if (clip is SceneAPI) then Reflect.getType("expr.SceneAPI") else if (clip is TextAPI) then Reflect.getType("expr.TextAPI") else Reflect.getType("expr.NodeAPI");
        const names = new java.util.HashSet of String;
	const members = foreach (m in introspect(typ) where not m.name.contains("pdate") and names.add(m.name)) m;
        const objectExpr =  NodeExpression { 
            node: clip, override function getType to F3Type { typ }
            inputMembers: foreach (m in members where not m.isObservable and m.isObserver and m.rt == UNIT_TYPE) m;
            outputMembers: thisMember(typ) 
        }
        var result = ObjectView {
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
            canvas: canvas;
            objectExpr: objectExpr;
            pos: new Point3(x, y, 0);
        }
        for (i in inputs) {
            if (i.links.size() > 0) {
                for (link in i.links) {
                    const lnk = canvas.getLink(link);
                    lnk.target = result.inputViews[indexof i];
                }
            }
        }
        for (p in outputs) {
            println("***output: {p} {p.links}, {p.sourceId}");
            const v = result;
            if (p.links.size() > 0) {
                const path = p.sourceId;
                const tn = v.outputViews[0].getTree.treeModel.resolvePath(path);
                if (tn.parent <> null) {
                    tn.open();
                }
                println("***path={path} tn={tn}");
                for (link in p.links) {
                    const lnk = canvas.getLink(link);
                    const cell = v.outputViews[0].getTree.getCell(tn);
                    const t = cell.linkedView;
                    println("***t={t}");
                    lnk.source = t;
                    cell.link();
                }
            }
        }
        insert result into canvas.views;
        return result;
    }
}

public class TimeNodeObjNode is ObjNode {
    public var timeNodeId is String;
    public override function createView from (canvas is Canvas) to ObjectView 
    {
        const clip = canvas.lookupTemporal(timeNodeId);
	const typ = Reflect.getType("f3.media.scene.TimeNode");
        const names = ["pause", "play", "playFromStart", "reverse"];
	const members = foreach (x in introspect(typ), y in names where x.name == y) x;
        const objectExpr = TimeNodeExpression { 
            timeNode: clip, override function getType to F3Type { typ }
            inputMembers: foreach (m in members where not m.isObservable and m.isObserver and m.rt == UNIT_TYPE) m;
            outputMembers: thisMember(typ) 
        }
        var result = ObjectView {
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
            canvas: canvas;
            objectExpr: objectExpr;
            pos: new Point3(x, y, 0);
        }
        for (i in inputs) {
            if (i.links.size() > 0) {
                for (link in i.links) {
                    const lnk = canvas.getLink(link);
                    lnk.target = result.inputViews[indexof i];
                }
            }
        }
        insert result into canvas.views;
        return result;
    }
}

public class VarContextObjNode is ObjNode {
    public var varId is String;
    public var varType is String;
    public var isShortcut is Boolean;
    public override function createView from (canvas is Canvas) to ExpressionView 
    {
        const c is Context.ClosureVarContext = canvas.eventContext.resolve(varId) as Context.ClosureVarContext;
        println("RESOLVED VAR {varId} TO {c}, SUBJECT={canvas.subject} {canvas.subject.variableName}");
        if (canvas.subject <> null and c == canvas.subject) {
            var r = canvas.terminalExprView;
            for (i in inputs) {
                if (i.links.size() > 0) {
                    for (link in i.links) {
                        const lnk = canvas.getLink(link);
                        lnk.target = r.inputViews[0];
                    }
                }
            }
            return r;
        }
        const typ = c.varType.t;
        const names = new java.util.HashSet of String;
        const members = foreach (m in introspectMembers(c) where not m.name.contains("pdate") and names.add(m.name)) m;
        const result = ObjectView {
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
            canvas: canvas;
            pos: new Point3(x, y, 0);
            isLinkable: true;
            objectExpr: VarContextExpression { 
                varContext: c, override function getType to F3Type { typ }
                inputMembers: foreach (x in members where x.isObserver) x;
                outputMembers: foreach (x in members where x.isObservable) x;
            }
        }
        for (i in inputs) {
            if (i.links.size() > 0) {
                for (link in i.links) {
                    const lnk = canvas.getLink(link);
                    lnk.target = result.inputViews[indexof i];
                }
            }
        }
        for (p in outputs) {
            const tv = result.outputViews[0].getTree;
            if (p.links.size() > 0) {
                const path = p.sourceId;
                const tn = tv.treeModel.resolvePath(path);
                if (tn.parent <> null) {
                    tn.open();
                }
                for (link in p.links) {
                    const lnk = canvas.getLink(link);
                    const cell = tv.getCell(tn);
                    const t = cell.linkedView;
                    lnk.source = t;
                    cell.link();
                }
            }
        }
        insert result into canvas.views;
        return result;
    }
}

public class GetNode is ExprNode {
    public var outputs is SourceNode[];
    public var isOpen is Boolean;
    public var visibleRowCount is Number = 10;
    public override function createView from (canvas is Canvas) to GetVarView 
    {
        var m = member.deserialize();
        var v is GetVarView;
        println("CREATING GET VAR: m={m}");
        if (m == null) {
            m = canvas.event;
        }
        if (m == canvas.event) {
            println("Matched event");
            v = canvas.initialExprView;
            v.visibleRowCount = visibleRowCount;
            v.pos = new Point3(x, y, 0);
        } else {
            println("Didn't match event: {canvas.event}");
            v = GetVarView {
                selectable: true;
                isLabeled: true;
                visibleRowCount: visibleRowCount;
                pathFactory: canvas.pathFactory;
                layoutEngine: canvas.layoutEngine;
                imageLoader: canvas.imageLoader;
                effectLoader: canvas.effectLoader;
                canvas: canvas;
                pos: new Point3(x, y, 0);
                get: GetVar {
                    member: m;
                    override public function getTerminals to Expression[] 
                    {
                        if (observers == []) then this else foreach (ob in observers) ob.getTerminals();
                    }
                }
            }
            insert v into canvas.views;
        }
        if (isOpen) {
            v.tv.open();
        }
        println("GetNode outputs: {outputs.size()}");
        for (p in outputs) {
            println("output: {p}");
            if (p.links.size() > 0) {
                const path = p.sourceId;
                const tn = v.tv.treeModel.resolvePath(path);
                if (tn.parent <> null) {
                    tn.open();
                }
                println("getNode path={path} tn={tn}");
                println("getNode v={v}, tv={v.tv}, treeModel={v.tv.treeModel}");
                for (link in p.links) {
                    const lnk = canvas.getLink(link);
                    const cell = v.tv.getCell(tn);
                    const t = cell.linkedView;
                    println("getNode t={t}, pos={t.getLinkPos()}");
                    lnk.source = t;
                    cell.link();
                }
            }
        }
        return v;
    }
}


public class TargetNode is ExprNode {
    public var targetId is String;
    public var links is String[];
    public var intValue is Integer;
    public var numberValue is Number;
    public var booleanValue is Boolean;
    public var stringValue is String = "\"\"";
}

public class SourceNode is ExprNode {
    public var sourceId is String;
    public var links is String[]
}

public class Editor is ResizableNode, Focuser {

    public var go is function from Context to ();
    public var menuFactory is MenuFactory;
    public var popupLayer is PopupLayer;
    public var popupScene is Scene;

    public var assetModel is AssetTree.AssetModel;

    public var stepping is Boolean;

    override var scissorBounds = bind Bounds.boundsFromRect(width, height);

    override public function getTargetOfFocus to Focusable { canvas }
    public var targetObject is ResourceTarget;
    public var targetNode is ResourceNode = bind getAsNode(targetObject);
    public var targetTimeNode is ResourceTimeNode = bind getAsTimeNode(targetObject);
    function getAsNode from (obj is Object) to ResourceNode { if (obj is ResourceNode) then obj as ResourceNode else null }
    function getAsTimeNode from (obj is Object) to ResourceTimeNode { if (obj is ResourceTimeNode) then obj as ResourceTimeNode else null }
    public var eventContext is Context.MemberContext;
    public var varContext is Context.ClosureVarContext;
    public var event is Member = bind eventContext.member;
    public var subject is Context.ClosureVarContext;
    public var targetSpace is Node;
    public var targetTime is TimeNode;
    public var targetTimeline is Timeline;
    public var instanceSpace is Group;
    public var debugger is ObservableDebugger;

    function getTargetNode from (c is Context) to ResourceNode {
        var ctx = c;
        while (ctx <> null and not (ctx is Context.ResourceNodeContext)) {
            ctx = ctx.parent;
        }
        return (ctx as Context.ResourceNodeContext).resource;
    }

    function getTargetPath from (ctx is Context) to String 
    {
        var parent = ctx.parent;
        var result is String = null;
        if (parent is Context.SubResourceNodeContext) {
            result = (parent as Context.SubResourceNodeContext).node.id;
        }
        println("GET TARGET PATH {parent} => {result}");
        return result;
    }

    var canvas is Canvas = bind getCanvas(targetObject, getTargetPath(eventContext), targetObject.programs, eventContext, varContext);

    override var internalContent = bind sp;

    public const interactive is function from () to Boolean;

    const sp = Scrollpane {
        width: bind width;
        height: bind height;
        content: bind canvas;
        canZoomVertical: false;
        canZoomHorizontal: false;
    }

    function getCanvas 
        from (target is ResourceTarget, 
              targetPath is String,
              programs is Program[],
              eventContext is Context.MemberContext, 
              varContext is Context.ClosureVarContext) 
        to Canvas
    {
	var prog is Program;
        println("TARGET: {target}, programs={target.programs.size()}, targetPath={targetPath}");
        /*
	for (x in programs) {
            println("PROGRAM {x.event.m}, event={eventContext.member.m}, targetPath={x.targetPath}");
            println("PROGRAM {java.lang.System.identityHashCode(x.event.m)}, event={java.lang.System.identityHashCode(eventContext.member.m)}");
	    if (x.event == eventContext.member and x.evalContext.varContext == varContext and x.targetPath == targetPath) { // hack
                println("FOUND IT");
		prog = x;
                break;
	    } else {
                if (x.targetPath == targetPath and x.event == eventContext.member and varContext <> null and x.evalContext.varContext == null) {
                    parentProg = x;
                }
                println("NO MATCH");
            }
	}
        */
        prog = if (varContext <> null) then varContext.program else eventContext.program;
        var parentProg = if (varContext <> null) then eventContext.program else null;
        const event = eventContext.event.member;
        const found = prog == null;
	if (prog == null) {
            println("CREATING PROGRAM IN CANVAS: {event}");
            if (parentProg == null and varContext <> null) {
                parentProg = Program { 
                    parent: parentProg;
                    event: event;
                    targetPath: targetPath;
                    evalContext: Program.EvalContext {
                        eventContext: eventContext;
                        varContext: null;
                        interactive: interactive;
                        targetNode: target;
                    }
                }
                insert parentProg into target.programs;
                eventContext.program = parentProg;
            }
	    insert prog into target.programs;
	    prog = Program { 
                parent: parentProg;
                event: event;
                targetPath: targetPath;
                evalContext: Program.EvalContext {
                    eventContext: eventContext;
                    varContext: varContext;
                    interactive: interactive;
                    targetNode: target;
                    debugger: debugger;
                    instanceSpace: instanceSpace;
                    lookupSpatial: targetSpace.lookup;
                    targetTimeline: targetTimeline;
                    lookupTemporal: targetTime.lookup;
                }
            };
	    insert prog into target.programs;
            if (varContext <> null) {
                varContext.program = prog;
            } else {
                eventContext.program = prog;
            }
	}
	if (prog.canvas == null) {
            println("creating canvas with {pathFactory}");
	    prog.canvas = Canvas {
                go: bind go;
                assetModel: assetModel;
                menuFactory: menuFactory;
                interactive: interactive;
                stepping: bind stepping;
                debugger: debugger;
                popupLayer: popupLayer;
                popupScene: popupScene;
                pathFactory: pathFactory;
                width: width;
                height: height;
		targetNode: target,
		event: event;
                subject: varContext;
                eventContext: eventContext;
                varContext: varContext;
		targetSpace: targetSpace;
		targetTime: targetTime;
		targetTimeline: targetTimeline;
                instanceSpace: instanceSpace;
	    }
            /*
            for (v in prog.code.views) {
                const j = v.createView(canvas);
                if (j <> null) {
                    insert j into canvas.views;
                }
            }
            */
            prog.canvas.prog = prog;
            prog.deserialize();
            prog.reset();
            prog.canvas.dumpSrc();
	}
	return prog.canvas;
    }
    

}




 
