package expr.prog;
import java.lang.Math;
import f3.math.*;
import f3.math.LinearMath.*;
import expr.*;
import expr.Treeview.*;
import expr.Listview.*;
import f3.reflect.*;
import expr.Reflect.*;
import f3.util.*;
import f3.util.Observer.*;
import f3.util.Observable.*;
import f3.lang.*;
import f3.media.input.*;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import expr.Names.*;
import expr.choices.*;
import expr.undo.*;

var exprMap1 = new java.util.HashMap of (F3ClassType, Member[]);
var exprMap2 = new java.util.HashMap of (F3ClassType, Member[]);

const MAT4_TYPE = Reflect.findClass("f3.math.Mat4");

function makeFunMember from (name is String, params is F3Type[], ret is F3Type) to Member 
{
    FunctionMember {
	ft: ctx.makeFunctionType(params, ret);
	name: name;
	t: ret;
    }
}

public const NUM_MEMBERS = 
    [foreach (op in ["add", "subtract", "multiply", "divide", "remainder", "lessThan", "lessOrEqual", "greaterThan", "greaterOrEqual", "equal", "notEqual"]) {
        FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$NumberOperators", op, ["Number", "Number"]);
        }
    },
    FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$NumberOperators", "negate", ["Number"]);
    }];

public const INT_MEMBERS = 
    [foreach (op in ["add", "subtract", "multiply", "divide", "remainder","lessThan", "lessOrEqual", "greaterThan", "greaterOrEqual", "equal", "notEqual"]) {
        FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$IntegerOperators", op, ["Integer", "Integer"]);
        }
    },
    FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$IntegerOperators", "negate", ["Number"]);
    }];

public const BOOL_MEMBERS = 
    [foreach (op in ["and", "or", "equal", "notEqual"]) {
        FunctionMember {
            m: Reflect.getFunction("f3.lang.Builtins$BooleanOperators", op, ["Boolean", "Boolean"]);
        }
    },
    FunctionMember {
         m: Reflect.getFunction("f3.lang.Builtins$BooleanOperators", "not", ["Boolean"]);
    },
    FunctionMember {
         m: Reflect.getFunction("f3.lang.Builtins$BooleanOperators", "If", ["Boolean", "Object", "Object"]);
    }];

public function introspect from (t is F3Type) to Member[]
{
    introspect(t, false);
}

public function introspect from (t is F3Type, all is Boolean) to Member[]
{
    if (t.getName() == "org.f3.runtime.F3Object" or
	t.getName() == "org.f3.runtime.F3Base" or
	t.getName() == "java.lang.Object") {
	return []
    }
    if (t is F3ClassType) then introspect(t as F3ClassType, all) else if (not all) [] else {
	    if (t == NUMBER_TYPE) 
		then NUM_MEMBERS
		else if (t == INTEGER_TYPE)
		    then INT_MEMBERS 
		    else if (t == BOOLEAN_TYPE)
			then BOOL_MEMBERS
			else []
    }
}
public function introspect from (clazz is F3ClassType) to Member[]
{
    introspect(clazz, false);
}

public function introspect from (clazz is F3ClassType, all is Boolean) to Member[]
{
    if (clazz == null) return [];
    const exprMap = if all then exprMap2 else exprMap1;
    if (exprMap.containsKey(clazz)) {
	return exprMap.get(clazz);
    }
    var result is Member[];
    const funs = Reflect.getFunctions(clazz, not all);
    if (all) {
        var r = 
            foreach (f in funs where f.isPublic() and not f.getName().contains("$") and 
                     OBJECT_TYPE <> f.getDeclaringClass() 
                     ) { 
            FunctionMember {
                m: f;
                t: f.getType().getReturnType();
                ft: f.getType();
            }
        };
        const classVars = foreach (v in Reflect.getVars(clazz) where v.isStatic()) {
            Member {
                m: v;
                rt: v.getType();
                t: v.getType();
            }
        }
        exprMap.put(clazz, [r, classVars]);
        return r;
    }
    for (f in funs) {
        println("f={f}");
    }
    for (f in Reflect.getFunctions(clazz, yes)) {
        println("f'={f}");
    }
    for (f in funs where f.isPublic() and not f.getName().contains("$") and 
	     OBJECT_TYPE <> f.getDeclaringClass() 
	 ) { 

	const ft = f.getType();
	var rt = ft.getReturnType();
	var toInsert is Member;
	if (ft.minArgs() == 0) {
	    var rt_t = rt;
	    if (SUBJECT_TYPE.isAssignableFrom(rt) or OBSERVABLE_TYPE.isAssignableFrom(rt) or OBSERVER_TYPE.isAssignableFrom(rt)) {
		rt_t = getTypeArguments(rt)[0];
	    } else {
	    }	
	    if (SUBJECT_TYPE.isAssignableFrom(rt)) {
		toInsert = Member {
		    m: f;
		    t: rt_t
                    rt: rt;
		    isObservable: true, isObserver: true;
		}
		println("Subject of ({getTypeArguments(rt)})");
	    }  else if (OBSERVABLE_TYPE.isAssignableFrom(rt)) {
		toInsert = Member {
		    m: f;
		    t: rt_t
                    rt: rt;
		    isObservable: true;
		}
		println("Observable of ({getTypeArguments(rt)})");
	    } else if (OBSERVER_TYPE.isAssignableFrom(rt)) {
		toInsert = Member {
		    m: f;
		    t: rt_t
                    rt: rt;
		    isObserver: true;
		}
		println("Observer of ({getTypeArguments(rt)})");
	    } else {
		if (UNIT_TYPE == rt) {
		    toInsert = Member {
			m: f;
			t: UNIT_TYPE;
                        rt: rt;
			isObservable: false, isObserver: true;
		    }
		}
	    }
	} else {
	    if (UNIT_TYPE <> rt) {
		continue;
	    }
	    if (ft.minArgs() == 0) {
		// observer of ()
		rt = UNIT_TYPE;
		toInsert = Member {
		    m: f;
		    t: rt;
                    rt: rt;
		    isObserver: true;
		}
	    } else if (ft.minArgs() == 1) {
		// observer of ft.getArgumentType(0)
		//println("{f.getName()} => Observer of ({ft.getArgumentType(0)})");
		toInsert = Member {
		    m: f;
		    t: ft.getArgumentType(0);
                    rt: rt;
		    isObserver: true;
                    isObservable: false;
		}
	    } else {
		// observer of (ft.getArgumentType(0), ft.getArgumentType(1))
		continue;
	    }
	}
	if (toInsert <> null) {
	    insert toInsert into result;
	}
    }
    const vars = clazz.getVariables(true);
    for (v in vars where not v.getName().contains("$") and not v.getName().startsWith("bnds") and not v.isStatic()) {
        println("v={v}");
	var toInsert is Member;
	if (true or not v.isPublicInit() and not v.isDef()) {
	    var rt = v.getType();
	    var isObs = SUBJECT_TYPE.isAssignableFrom(rt) or OBSERVABLE_TYPE.isAssignableFrom(rt);
	    if (isObs or OBSERVER_TYPE.isAssignableFrom(rt)) {
		rt = getTypeArguments(rt)[0];
	    }	
	    if ((not v.isPublicRead() and not v.isPublicInit() and not v.isDef()) and v.isPublic()) {
		println("{v.getName()} => Subject of ({rt})");
		toInsert = Member {
		    m: v;
		    t: rt
		    isObserver: true;
		    isObservable: true;
		}
	    } else if (v.isPublic() or v.isPublicRead() or v.isPublicInit()) {
		println("{v.getName()} => Observable of ({rt})");
		toInsert = Member {
		    m: v;
		    t: rt
		    isObservable: isObs or v.isPublic();
		}
	    }
	}
	if (toInsert <> null) {
	    insert toInsert into result;
	}
    }
    result = foreach (x in result where not x.t.isAssignableFrom(MAT4_TYPE)) x;
    exprMap.put(clazz, result);
    return result;
}


public class Member {
    override function equals from (obj is Object) to Boolean {
        (obj is Member)  and {
            (obj as Member).m == m or (obj as Member).m.toString() == m.toString(); // hack!!
        }
    }
    public function serialize to MemberNode {
        MemberNode {
            declaringClass: m.getDeclaringClass().getName();
            name: m.getName();
            outputType: t.getName();
        }
    }
    public const rt is F3Type;
    public const m is F3Member; 
    public const t is F3Type;
    public const name = m.getName();
    public var isObservable is Boolean;
    public var isObserver is Boolean;
    public function getMembers to Member[]
    {
	Expression.introspect(t);
    }

    function toObservable to String 
    {
        const app = toApply();
        if (OBSERVABLE_TYPE.isAssignableFrom(t)) {
            return app;
        }
        return "f3.util.Observables.observe(&{app})";
    }

    function toApply to String 
    {
        toApply("");
    }

    function toApply from (arg is String) to String 
    {
	if (m is F3FunctionMember) then "{if (m.isStatic()) then m.getName() else name}({arg})" else "{name}";
    }

    override function toString to String
    {
	"m={m},t={t},name={name},isObserver={isObserver},isObservable={isObservable}";
    }
}

public class FunctionMember is Member {
    public var ft is F3FunctionType = bind (m as F3FunctionMember).getType();
    override public function serialize to MemberNode 
    {
        FunctionMemberNode {
            declaringClass: m.getDeclaringClass().getName();
            name: m.getName();
            outputType: t.getName();
            inputTypes: foreach (i in [0..<ft.minArgs()]) ft.getArgumentType(i).getName();
        }
    }
    override var name = formatName(m as F3FunctionMember);
}

function formatType(t is F3Type) to String 
{
    if t.isTypeVariable() then "Any" else if (t is F3SequenceType) 
        then "{formatType((t as F3SequenceType).getComponentType())}[]" 
        else if (t is F3FunctionType) then formatFunctionType(null, t as F3FunctionType) 
            else if (t is F3ClassType) then { 
                    const ct = t as F3ClassType; 
                    const dot = t.getName().lastIndexOf("."); 
                    if (dot >= 0) then t.getName().substring(dot+1) else t.getName();
                }
            else t.getName();
}

function formatFunctionType(clazz is F3ClassType, ft is F3FunctionType) to String 
{
    var r = if clazz == null then "(" else "({formatType(clazz)}";
    var sep = if clazz == null then "" else ", ";
    for (i in [0..<ft.minArgs()]) {
        r = "{r}{sep}{formatType(ft.getArgumentType(i))}";
        sep = ", ";
    }
    "{r}) -> {formatType(ft.getReturnType())}";
}

function formatName from (f is F3FunctionMember) to String 
{
    "{Names.formatName(f.getName())} {formatFunctionType(if f.isStatic() then null else f.getDeclaringClass(), f.getType())}"
}

function formatClassName from (t is F3Type) to String 
{
    if (t is F3FunctionType) {
        return formatFunctionType(null, t as F3FunctionType)
    }
    if (not (t is F3ClassType)) {
        return t.getName();
    }
    const n = if (t.isTypeVariable()) then "Any" else t.getName();
    const dot = n.lastIndexOf(".");
    return n.substring(dot+1);
}

function argName from (ft is F3FunctionType, i is Integer) to String 
{
    const t = ft.getArgumentType(i);
    if (t.isTypeVariable()) {
        return "Any";
    }
    const n = formatClassName(t);
    const dot = n.lastIndexOf(".");
    return n.substring(dot+1);
}

function resultName from (ft is F3FunctionType) to String 
{
    ft.getReturnType().getName();
}

var ID = 1;
function getNextId to String {
    return "{ID++}";
}

public interface Expression {
    public var id is String = getNextId();
    public bound function getName to String;
    public function getType to F3Type;
    override function toString { "{getClass()}: {getName()} / {getType()}" }
    public function toSource to String { "" }
}

public abstract class ObjectExpression is Expression {
    public var inputMembers is Member[];
    public var outputMembers is Member[];
    public var inputs is InputMemberExpression[] = bind foreach (p in inputMembers) 
        InputMemberExpression {
        target: this;
        member: p;
    }
    public var outputs is OutputMemberExpression[] = bind foreach (p in outputMembers) 
        OutputMemberExpression {
        source: this;
        member: p;
    }
}

abstract class VarContextExpression is ObjectExpression {
    public var varContext is Context.ClosureVarContext;
    override bound function getName to String { varContext.varName }
    override function toSource { "(getVar(\"{varContext.varName}\") as {getType().getName()})" }
}

abstract class TimeNodeExpression is ObjectExpression {
    public var timeNode is TimeNode;
    override bound function getName to String { timeNode.id }
    override function toSource { "(getClip(\"{timeNode.id}\") as {getType().getName()})" }
}

abstract class NodeExpression is ObjectExpression {
    public var node is Node;
    override bound function getName to String { node.id }
    override function toSource { "(getNode(\"{node.id}\") as {getType().getName()})" }
}

function simplify from (s is String) to String {
    const paren = s.indexOf("(");
    if (paren > 0) then s.substring(0, paren) else s
}

public interface MemberExpression is Expression {
    public var member is Member;
    override bound function getName to String { simplify(member.name) }
}

public interface ObservableExpression is Expression {
    public var observers is ObserverExpression[];
}

public interface ObserverExpression is Expression {
    public var observable is ObservableExpression;
}

public interface VarExpression is MemberExpression {
    override function getType to F3Type { member.t }
}

function getIVar from (ob is ObserverExpression) to String {
    var depth = 0;
    var obs = ob;
    while (true) {
	var b = obs.observable;
	if (b is Result) {
            const br = b as Result;
	    b = if br.source.inputs == null then null else br.source.inputs[0].observable;
	} 
	if (b is ObserverExpression) {
	    obs = b as ObserverExpression;
	    depth++;
	} else {
	    break;
	}
    }
    if (depth == 0) then "i" else "i{depth}";
}

public class GetVar is VarExpression, ObservableExpression, ObserverExpression {
    override public function toSource to String {
        println ("get var to source {this} observable={observable}");
        if (observable is Result) {
            return observable.toSource();
	} 
	if (observers == []) {
	    return "";
	}
	const i = getIVar(this);
	if (observable is MemberExpression and { const mexp = observable as MemberExpression; mexp.member.isObservable }) {

	    "(foreach ({i} in debugger.debug({observable.toSource()}, \"{id}\")) {i}.{member.toApply()})";
        } else {
	    if (observable == null) {
		if (OBSERVABLE_TYPE.isAssignableFrom(member.rt)) 
		    then "{i}.{member.toApply()}"
		    else "debugger.debug(f3.util.Observables.observe(&{i}.{member.toApply()}), \"{id}\")";
	    } else {
		"(foreach ({i} in debugger.debug({observable.toSource()}, \"{id}\")) {i}.{member.toApply()})";
	    }
	}
    }
}

public class SetVar is VarExpression, ObserverExpression {
}

public class Function is MemberExpression {
    public var funMember is FunctionMember;
    override var member = bind funMember;
    public var ft is F3FunctionType = bind funMember.ft;
    public var fun is F3FunctionMember = bind member.m as F3FunctionMember;
    override function getType { ft }
    public var inputs is Parameter[] =
	bind 
        [if (fun == null or fun.isStatic()) then null else 
         Parameter {
             name: formatClassName(fun.getDeclaringClass());
             target: this;
             t: fun.getDeclaringClass()
         },           
         foreach (i in [0..<ft.minArgs()]) {
             Parameter {
                 name: argName(ft, i);
                 target: this;
                 t: ft.getArgumentType(i);
             }
         }];
    public var output is Result = Result {
        source: this;
	t: ft.getReturnType()
    }

    override public function toSource to String {
	const observable = inputs[0].observable;
        println("Function to source observable={observable}");
	const result = if (observable is MemberExpression and { const mexp = observable as MemberExpression; mexp.member.isObservable } ) {
	    const m = observable as MemberExpression;
            if (inputs.size() == 1) {
                if (inputs[0].observable <> null) {
                    const i = getIVar(inputs[0]);
                    if (fun.isStatic()) {
                        println("static case 1");
                        "(foreach ({i} in debugger.debug({observable.toSource()}, \"{id}\")) {fun.getDeclaringClass().getName()}.{fun.getName()}({i}))";
                    } else {
                        println("non static case 1");
                        "(foreach ({i} in debugger.debug({observable.toSource()}, \"{id}\")) {i}.{fun.getName()}())";

                    }
                } else {
                    if (fun.isStatic()) {
                        println("static case 2");
                        "{fun.getName()}({observable.toSource()})";
                    } else {
                        println("non static case 2");
                        "{observable.toSource()}.{fun.getName()}()";
                    }
                }
            } else {
                if (not fun.isStatic()) {
                    const i = getIVar(inputs[0]);
                    var sep = "";
                    var args is String;
                    for (j in [0..<ft.minArgs()]) {
                        const p = inputs[j+1];
                        println("p={p}");
                        args = "{args}{sep}{p.toSource()}";
                        sep = ", ";
                        println("args => {args}");
                    }
                    println("non static case 3");
                    "(foreach ({i} in debugger.debug({observable.toSource()}, \"{id}\")) {i}.{fun.getName()}({args}))";
                } else {
                    const i = getIVar(inputs[0]);
                    var args is String = i;
                    var sep = ", ";
                    for (j in [1..<ft.minArgs()]) {
                        const p = inputs[j];
                        args = "{args}{sep}{p.toSource()}";
                    }
                    println("static case 3");
                    "(foreach ({i} in debugger.debug({observable.toSource()}, \"{id}\")) {fun.getDeclaringClass().getName()}.{fun.getName()}({args}))";
                }
            }
	} else {
            if (not fun.isStatic()) {
                const i = inputs[0].toSource();
                var sep = "";
                var args is String;
                for (j in [0..<ft.minArgs()]) {
                    const p = inputs[j+1];
                    args = "{args}{sep}{p.toSource()}";
                    sep = ", ";
                }
                println("non static case 4");
                "{i}.{fun.getName()}({args})";
            } else {
                var args is String = "";
                var sep = "";
                for (j in [0..<ft.minArgs()]) {
                    const p = inputs[j];
                    args = "{args}{sep}{p.toSource()}";
                    sep = ", ";
                }
                println("static case 4");
                "{fun.getDeclaringClass().getName()}.{fun.getName()}({args})";
            }
        }
        println("gen source {this} => {result}");
        return result;
    }
}

public class Parameter is ObserverExpression {
    public var name is String;
    public var t is F3Type;
    public var target is Function;
    override bound function getName to String { name }
    override function getType to F3Type { t }
    public function isTypeVariable to Boolean {
        t.isTypeVariable();
    }
    public var constantValue is Object = "null";
    override public function toSource to String 
    {
        if (observable == null) then "{constantValue}" else observable.toSource();
    }
    override function toString to String {
        var i = 0;
        for (p in target.inputs) {
            if (p == this) {
                break;
            }
            i++;
        }
        "Parameter {i} {getName()} of {target} with observable: {observable}"
    }
}

public class Result is ObservableExpression {
    override bound function getName to String { "return" }
    public var t is F3Type;
    public var source is Function;
    override function getType to F3Type { t }
    public override function toSource to String 
    {
        const result = source.toSource();
        println("source={source}");
        println("gen source {this} => {result}");
        return result;
    }
}

class DataArrow is MeshNode.Instance {
}

class ControlArrow is MeshNode.Instance {
}

public abstract class ExpressionView is AbstractNode {
    override var id = bind expression.id;
    public function unlink from () to () {}
    override function toString { "{super.toString()}: {expression}" }
    public const canvas is Canvas;
    public var expression is Expression;
    public bound function getPos to Point3 { getWorldPos() }
    bound function getWorldPos to Point3 { (toSceneTransform * canvas.toLocal).getTranslation() }
    public var pos is Point3;
    public var cellWidth is Number = 150;
    public var cellHeight is Number = bind canvas.cellHeight;
    public var font is Text.Font = bind canvas.font;
    var selected is Boolean = bind canvas.selectedExpr == this;
    public bound function getLabel to String {
        Names.formatName(expression.getName());
    }
    public var label is Text.Label = bind Text.Label {
	text: bind getLabel();
	height: bind cellHeight;
	width: bind cellWidth;
	font: bind font;
	foreground: bind canvas.textFg;
	background: bind if (selected) then canvas.cellSelectedBg else canvas.cellBg;
	pickable: true;
        indent: 4;
    };
    public var defaultTitle is Node = bind Group {
           content: bind
           [label,
           Rectangle {
                height: 1;
                width: bind cellWidth;
                fillPaint: bind canvas.textFg;
                pickable: false;
                cy: bind -cellHeight/2;
            }];
    };
    public var title is Node = bind defaultTitle;
    function onDown from (e is MouseEvent) to () 
    {
        canvas.selectedExpr = this;
    }
    function onDrag from (e is MouseEvent) to () 
    {

	pos += e.picked.dragPoint1 - e.picked.dragPoint0;
    }
    function onUp from (e is MouseEvent) to () 
    {
        canvas.saveCode();
    }
    var d1;
    var d2;
    var d3;
    postinit {
	d1 = label.observeMouseDown().subscribe(onDown);
	d2 = label.observeMouseUp().subscribe(onUp);
	d3 = label.observeMouseDrag().subscribe(onDrag);
    }

    public function serialize to ExprNode {
        throw new java.lang.RuntimeException("not implemented {getClass()}");
    }
}


class FunctionView is ExpressionView {

    override public function unlink from () to () {
        for (x in inputs) {
            x.unlink();
        }
        foreach (link in output.getTree.getLinks()) {
            link.unlink();
        }
    }

    public override function serialize to ExprNode {
        const n = FunNode {
            id: "{id}";
            x: pos.x;
            y: pos.y;
            member: fun.member.serialize();
        }
        canvas.serializationMap.put(this, n);
        n.inputs = foreach (i in inputs) TargetNode {
            targetId: "{i.id}", links: foreach (link in i.links) "{link.id}";
            intValue: if (i.parameter.constantValue is Integer) then i.parameter.constantValue as Integer else 0;
            numberValue: if (i.parameter.constantValue is Number) then i.parameter.constantValue as Number else 0.0;
            booleanValue: if (i.parameter.constantValue is Boolean) then i.parameter.constantValue as Boolean else false;
        };
        n.outputs = 
            foreach (link in output.getTree.getLinks() where not (link.target is TreecellGetVarView)) 
            {
                var p = getPath(link);
                SourceNode {
                    sourceId: p;
                    links: ["{link.id}"];
                }
            };
        return n;
    } 

    public var fun is Function;
    override var transform = bind translate(pos);
    override var expression = bind fun;
    public function assignLinkIds to () {
        var j = 0;
        for (x in inputs) {
            for (y in x.links) {
                y.targetLinkId = j++;
            }
        }
        unify();
    }
    function unify {
        for (x in inputs) {
            var t = x.parameter.t;
            if (t.isTypeVariable()) {
                if (x.links.size() > 0) {
                    var infer is F3Type = null;
                    for (link in x.links) {
                        infer = (link.source as OutputView).resultType;
                    }
                    if (infer <> x.inputType) {
                        x.inputType = infer;
                        for (j in inputs) {
                            if (j <> x and j.links.size() == 0) {
                                if (j.parameter.t.isTypeVariable() and j.parameter.t.getTypeVariable() == t.getTypeVariable()) {
                                    j.inputType = infer;
                                }
                            }
                        }
                    }
                } else {
                    var isSet = false;
                    for (j in inputs) {
                        if (j <> x and j.links.size() == 0) {
                            if (j.parameter.t.isTypeVariable() and j.parameter.t.getTypeVariable() == t.getTypeVariable()) {
                                j.inputType = null;
                            }
                        } else {
                            isSet = true;
                        }
                    }
                    if (not isSet) {
                        x.inputType = null;
                    }
                }
                if (output.result.getType().isTypeVariable() and
                    output.result.getType().getTypeVariable() == t.getTypeVariable()) {
                    output.unifiedType = x.inputType;
                }
            }
        }
    }
    var inputs is ParameterView[] = bind foreach (p in fun.inputs) ParameterView {
        targetView: this;
	canvas: bind canvas;
	parameter: p;
	cellWidth: bind cellWidth;
    };
    var output is ResultView = ResultView {
	canvas: bind canvas;
	result: bind fun.output;
    };
    const io = Group {
	transform: bind translate(0, -cellHeight);
	content: 
	[
	 Group {
	     content: bind inputs
	 }
	 Group {
	     transform: bind translate(0, -inputs.size() * cellHeight);
	     content: bind output;
	 }]
    };
    override var internalContent = Group {
	content: bind [title, io];
    }

    override function update {
	super.update();
	for (i in inputs) {
	    i.index = indexof i;
	}
    }
}

public class InputMemberExpression is MemberExpression, ObserverExpression {
    override function getType to F3Type { member.t }
    public var target is ObjectExpression;
    override public function toSource to String {
	const i = getIVar(this);
        println("INPUT MEMBER EXPR {this}");
        println("INPUT MEMBER EXPR i={i}");
        var res = 
        if (member.m is F3FunctionMember and (member.m as F3FunctionMember).getType().minArgs() > 0) {
            "(foreach ({i} in debugger.debug({observable.toSource()}, \"{id}\")) {target.toSource()}.{member.toApply(i)})";
	} else if (observable is MemberExpression and (observable as MemberExpression).member.isObservable) {
	    
	    "(foreach ({i} in debugger.debug({observable.toSource()}, \"{id}\")) {target.toSource()}.{member.toApply()})";
	} else {
	    if (observable == null) {
		if (true or member.isObservable) 
		    then "{target.toSource()}.{member.toApply()}"
		    else "debugger.debug(f3.util.Observables.observe(&{target.toSource()}.{member.toApply()}, \"{id}\"))";
	    } else {
		"(foreach ({i} in debugger.debug({observable.toSource()}, \"{id}\")) {target.toSource()}.{member.toApply()})";
		//"{observable.toSource()}.{member.toApply()}";
	    }
	}
        println("INPUT MEMBER EXPR res={res}");
        return res;
    }
}

public class OutputMemberExpression is MemberExpression, ObservableExpression {
    override function getType to F3Type { member.t }
    public var source is ObjectExpression;
    override public function toSource to String {
	""
    }
}


public class ObjectView is ExpressionView {

    override var transform = bind translate(pos);

    public var objectExpr is ObjectExpression;
    override var expression = bind objectExpr;

    override function unlink from () to () {
        for (i in inputViews) i.unlink();
        for (i in outputViews) i.unlink();
    }

    public override function serialize to ExprNode {
        var n is ObjNode;
        if (objectExpr is NodeExpression) {
            n = NodeObjNode {nodeId: (objectExpr as NodeExpression).node.id};
        } else if (objectExpr is TimeNodeExpression) {
            n = TimeNodeObjNode {timeNodeId: (objectExpr as TimeNodeExpression).timeNode.id};
        } else {
            // @Todo
        }
        n.id = "{id}";
        n.x = pos.x;
        n.y = pos.y;
        canvas.serializationMap.put(this, n);
        n.inputs = foreach (i in inputViews) TargetNode { targetId: "{i.id}", links: foreach (link in i.links) "{link.id}" };
        n.outputs = foreach (i in outputViews) SourceNode { sourceId: "{i.id}", links: foreach (link in i.links) "{link.id}" };
        return n;
    }

    function assignLinkIds to () {
        var j = 0;
        for (x in inputViews) {
            for (y in x.links) {
                y.targetLinkId = j++;
            }
        }
        j = 0;
        for (x in outputViews) {
            for (y in x.links) {
                y.sourceLinkId = j++;
            }
        }
    }

    const self = this;
    var inputViews is InputView[] = bind foreach (p in objectExpr.inputs) InputView {
	canvas: bind canvas;
	cellWidth: bind cellWidth;
	expression: p;
	//override bound function getInputType to F3Type { p.getType() }
        override function assignLinkIds to () {
            self.assignLinkIds();
        }
    };

    var outputViews is OutputView[] = bind foreach (p in objectExpr.outputs) OutputView {
	canvas: bind canvas;
	cellWidth: bind cellWidth;
	expression: p;
	override var resultType = bind this.expression.getType();
        override function assignLinkIds to () {
            self.assignLinkIds();
        }
    };
    //    var outputViews = bind foreach (r in outputs) OutputView {
    //	canvas: bind canvas;
    //    };
    const io = Group {
	transform: bind translate(0, -cellHeight);
	content: 
	[
	 Group {
	     content: bind inputViews
	 }
	 Group {
	     transform: bind translate(0, -objectExpr.inputs.size() * cellHeight);
	     content: bind outputViews
	 }]
    };

    override var internalContent = Group {
	content: bind [title, io];
    }

    override function update {
	super.update();
	for (i in inputViews) {
	    i.index = indexof i;
	}
	for (i in outputViews) {
	    i.index = indexof i;
	}
    }
}

function getPath from (v is LinkView) to String {
    if (v.source instanceof TreecellGetVarView) {
        var g = v.source as TreecellGetVarView;
        var p = getPath(g.parentLink);
        return "{p}{g.get.member.name}/";
    }
    return "/";
}

public class GetVarView is OutputView {
    public override function serialize to ExprNode {
        const n = GetNode {
            id: "{id}";
            x: pos.x;
            y: pos.y;
            member: get.member.serialize();
        }
        canvas.serializationMap.put(this, n);
        n.outputs = 
            foreach (link in tv.getLinks() where not (link.target is TreecellGetVarView)) 
            {
                var p = getPath(link);
                println("GET VAR VIEW {get.member.name} => {getPath(link)}");
                SourceNode {
                    sourceId: p;
                    links: ["{link.id}"];
                }
            }
        return n;
    }
    override var resultType = bind get.getType();
    public var get is GetVar;
    const tv is GetTreeview = GetTreeview {
        canvas: bind canvas;
        width: 150;
        height: 200;
        get: bind get;
    }
    override var transform = bind translate(pos);
    override var expression = bind get;
    override var internalContent = Group {
	content: bind tv;
    };
    override bound function getLinkPos to Point3 { getWorldPos() }
}

public class LinkView is ExpressionView {
    override function toString to String {
        "LinkView {id} source {source.id} {source} target {target.id} {target}";
    }
    public var sourceLinkId is Integer;
    public var targetLinkId is Integer;
    override var id = getNextId();
    override public function serialize to LinkNode {
        const n = LinkNode {}
        canvas.serializationMap.put(this, n);
        n.source = source.id;
        n.target = target.id;
        return n;
    }
    public var target is LinkedView;
    public var source is LinkedView;
    public function link from () to () {
	insert this into target.links;
	insert this into source.links;
	insert this into canvas.links;
	const obsvr = target.expression as ObserverExpression;
	const obsvb = source.expression as ObservableExpression;
	insert obsvr into obsvb.observers;
	obsvr.observable = obsvb;
	println("LINKING {source} to {target}");
        target.assignLinkIds();
        source.assignLinkIds();
    }

    override function unlink from () to () {
	delete this from target.links;
	delete this from source.links;
	delete this from canvas.links;
	const obsvr = target.expression as ObserverExpression;
	const obsvb = source.expression as ObservableExpression;
	if (obsvr.observable == obsvb) {
	    obsvr.observable = null;
	}
	delete obsvr from obsvb.observers;
	println("UNLINKING {source} from {target}");
        target.assignLinkIds();
        source.assignLinkIds();
    }

    override var internalContent = Group {
	override var transform = bind translate(target.getLinkPos())
	content: bind canvas.makeArrow(canvas.ARROW_COLOR);
    }
}

abstract class LinkedView is ExpressionView {
    var links is LinkView[];
    override function unlink from () to () {
        const links = this.links;
	for (link in links) {
	    link.unlink();
	}
    }
    function link from () to () {
	for (link in links) {
	    link.link();
	}
    }
    public bound function getLinkPos to Point3 { pos }
    public function assignLinkIds to () {
    }
}

public class InputView is LinkedView {
    var index is Integer;
    public bound function getInputType to F3Type { expression.getType() };
    override var transform = bind translate(0, index * -cellHeight);
    override var internalContent = bind label;

    var tmpLink is LinkedView = null;
    var link0 is LinkView;
    var dx = 0.0;
    var dy = 0.0;
    const onDown1 = observeMouseDown().subscribe(function from (e is MouseEvent) to () {
            dx = 0; dy = 0;
            if (false and links.size() == 1) {
                link0 = links[0];
                tmpLink = InputView {
                    canvas: canvas;
                }
                tmpLink.pos = canvas.toLocal * e.sceneLocation;
                insert tmpLink into canvas.views;
                link0.target = tmpLink;
                link0.link();
                delete links;
            }
        });
    const onDrag1 = observeMouseDrag().subscribe(function from (e is MouseEvent) to () {
            tmpLink.pos = canvas.toLocal * e.picked.dragPoint1;
        });
    const onUp1 = observeMouseUp().subscribe(function from (e is MouseEvent) to () {
            if (link0 <> null) {
                canvas.pickInput(e, getInputType(), function from (found is LinkedView) to () {
                        delete tmpLink from canvas.views;
                        if (found == this or found == null) {
                            insert link0 into links;
                            tmpLink = null;
                            link0 = null;
                        } else {
                            link0.target = found;
                            link0.link();
                            canvas.dumpSrc();
                        }
                    });
            }
        });
    override bound function getLinkPos to Point3 { getWorldPos() - new Vec3(cellWidth/2, 0, 0) }
}


abstract class Constant is ObservableExpression {
}

class NumberConstant is Constant {
    public var value is Number;
    override function getType to F3Type { Reflect.NUMBER_TYPE }
    override function toSource to String { "{value}" }
    override bound function getName to String { "{value}" }
}

class IntegerConstant is Constant {
    public var value is Integer;
    override function getType to F3Type { Reflect.INTEGER_TYPE }
    override function toSource to String { "{value}" }
    override bound function getName to String { "{value}" }
}

class BooleanConstant is Constant {
    public var value is Boolean;
    override function getType to F3Type { Reflect.BOOLEAN_TYPE }
    override function toSource to String { "{value}" }
    override bound function getName to String { "{value}" }
}

public class ParameterView is InputView {
    const parameter is Parameter;
    public var targetView is FunctionView;
    override var expression = bind parameter;    
    public var inputType is F3Type;
    override bound function getLabel to String {
        formatClassName(if (inputType <> null) then inputType else parameter.t)
    }
    override public bound function getInputType to F3Type {
        return if inputType <> null then inputType else parameter.t;
    }
    override public function assignLinkIds to () {
        targetView.assignLinkIds();
    }

    var numSlider = SliderField {
        height: bind cellHeight;
        width: bind cellWidth-100;
        transform: translate(50, 0, 0);
        override var t on replace {
            parameter.constantValue = t;
            canvas.dumpSrc();
        }
    };
    
    var intSlider is SliderField = SliderField {     
        height: bind cellHeight;
        width: bind cellWidth-100;
        transform: translate(50, 0, 0);
        override function setT from (t is Number) to ()
        {       
            this.t = t;
        }
        override var t on replace {
            parameter.constantValue = (t * 100) as Integer;
            canvas.dumpSrc();
        }
        override function getText from (t is Number) to String
        {
            "{Math.round(t * 100) as Integer}";
        }
    };

    var boolSlider = bind SliderField {     
        height: bind cellHeight;
        width: bind cellWidth-100;
        transform: translate(50, 0, 0);
        override function setT from (t is Number) to ()
        {       
            this.t = if (t > 0.5) then 1.0 else 0.5;
        }
        override function getText from (t is Number) to String
        {
            if (t <= 0.5) then "No" else "Yes";
        }
        override var t on replace {
            parameter.constantValue = (t > 0.5);
            canvas.dumpSrc();
        }
    }; 
    
    override var internalContent = Group { content: bind [label, if links.size() == 0 then (if (Reflect.NUMBER_TYPE.isConvertibleFrom(getInputType())) 
        then numSlider 
        else if (Reflect.INTEGER_TYPE.isConvertibleFrom(getInputType()))
            then intSlider
            else if (Reflect.BOOLEAN_TYPE.isConvertibleFrom(getInputType())) 
                then boolSlider
                else null) else null] };
    
    
}

public class OutputView is LinkedView {
    public var resultType is F3Type;
    public var index is Integer;
    override var transform = bind translate(0, index * -cellHeight);
    var getter = GetVar {
        member: bind Member {
            m: null;
            t: resultType;
            name: expression.getName();
        }
    };

    const getTree is GetTreeview = GetTreeview {
        canvas: bind canvas;
        width: 150;
        height: 200;
        get: bind getter;
    };

    init {
        insert getter into (expression as ObservableExpression).observers;
        getter.observable = (expression as ObservableExpression);
    }

    override var internalContent = Group 
    {
	content: bind getTree

    }
    override function onDrag from (e is MouseEvent) to () 
    {
	//targetPos = e.location;
	//const source = canvas.pickInput(e, result.getType());
    }
    override function onDown from (e is MouseEvent) to () 
    {
    }
    override function onUp from (e is MouseEvent) to () 
    {
    }
    override bound function getLinkPos to Point3 { getWorldPos() + new Vec3(cellWidth/2, 0, 0) }
}

class ResultView is OutputView {
    public var result is Result;
    override var expression = bind result;
    override var resultType = bind if (unifiedType <> null) then unifiedType else result.getType();
    public var unifiedType is F3Type;
}

class MemberTreenode is Treenode {
    public var m is Member;
    public var get = bind GetVar { member: m }
    override var label = bind Names.formatName(m.name);
    readonly var members = bind m.getMembers();
    override var canOpen = bind { var n = members.size(); n > 0 };
    override var children = bind foreach (x in members) makeTreeNode(x);

    override function toString to String 
    {
        "MemberTreenode {m}"
    }

    function resolvePath from (path is String) to MemberTreenode {
        if (path == "") return this;
        const slash = path.indexOf("/");
        const name = if slash > 0 then path.substring(0, slash) else path;
        const remainder = if slash > 0 then path.substring(slash+1) else "";
        println("name={name}");
        println("remainder={remainder}");
        for (j in children) {
            const x = j as MemberTreenode;
            if (x.m.name == name) {
                return x.resolvePath(remainder);
            }
        }
        return null;
    }

    function makeTreeNode from (x is Member) to MemberTreenode {
	const m = MemberTreenode {
            parent: this;
	    m: x;
	}
	insert m.get into get.observers;
	m.get.observable = get;
	return m;
    };
    override function open {
    	children;
	super.open();
    }
}

public class MemberTreemodel is Treemodel {

    function getMember to Member 
    {
        (root as MemberTreenode).m
    }

    public function resolvePath from (path00 is String) to MemberTreenode {
        const rootName = getMember().name;
        if (path00 == "/" or path00 == "/{rootName}" or path00 == "/{rootName}/") {
            return root as MemberTreenode;
        }
        var path0 = path00;
        if (not (path0.startsWith("/{rootName}"))) {
            println("path0 is {path0}");
            java.lang.Thread.currentThread().dumpStack();
            path0 = "/{rootName}{path0}";
        }
        const end = if path0.endsWith("/") then path0.length()-1 else path0.length();
        try {
            const path = path0.substring(getMember().name.length()+2, end);
            println("path0: {path0}");
            println("path: {path}");
            const result = (root as MemberTreenode).resolvePath(path);
            println("resolve path {path} => {result}");
            return result;
        } catch (exc is java.lang.StringIndexOutOfBoundsException) {
            println(exc);
            println("failed on: {path0}");
        }
        return null;
    }
}

public class ParentLinkView is LinkView {
}

class TreecellGetVarView is GetVarView {
    public var parentLink is LinkView;
}

public class MemberTreecell is Treeview.Treecell 
{
    public var canvas is Canvas;
    const self = this;

    var parentLink is LinkView;

    function link from () to ()
    {
        if (parentLink == null) {
            var n = (tn as MemberTreenode);
            var p = (n.parent as MemberTreenode);
            const pv = if p == null then null else tv.getView(p) as MemberTreecell;
            if (pv <> null) {
                if (parentLink == null) {
                    parentLink = ParentLinkView {
                        visible: false;
                        canvas: canvas;
                        source: pv.linkedView;
                        target: linkedView;
                    }
                }
                parentLink.link();
            }
        }
    }

    function unlink from () to ()
    {
        var p = parentLink;
	parentLink = null;
        p.unlink();
    }

    const linkedView is GetVarView = TreecellGetVarView {
        parentLink: bind parentLink;
	get: bind (tn as MemberTreenode).get;
        override function assignLinkIds to ()
        {
            if (links.size() > 0) {
                self.link();
            } else {
                self.unlink();
            }
            super.assignLinkIds();
        }
	override bound function getLinkPos to Point3 
	{
	    var me = self.canvas.toLocal * self.boundsInScene;
	    var container = self.canvas.toLocal * self.tv.boundsInScene;
	    new Point3(me.right(), 
                       Math.min(container.top(), Math.max(container.bottom(), me.center.y)),
		       0);
	}
    };
}

class GetTreeview is ResizableNode {
    public var event is Member;
    public var canvas is Canvas;
    public var cellHeight = bind canvas.cellHeight;
    public var get is GetVar;
    function open to () {
        treeModel.root.open();
    }
    const treeModel = MemberTreemodel {
	root: MemberTreenode {
	    get: bind get;
	    m: bind get.member;
	}
    };
    public function getLinks to LinkView[]
    {
        foreach (x in cellMap.values()) foreach (y in x.linkedView.links where not (y is ParentLinkView)) y;

    }
    function getRootLinkedView to LinkedView {
        getCell(treeModel.root as MemberTreenode).linkedView;
    }
    var treeHeight = bind Math.min(treeModel.rowCount, 8)*cellHeight;
    const self = this;
    const cellMap is java.util.Map of (MemberTreenode, MemberTreecell) =        
	java.util.HashMap of (MemberTreenode, MemberTreecell) {};

    public function getCell from (tn is MemberTreenode) to MemberTreecell {
	var r = cellMap.get(tn);
	if (r == null) {
	    r = MemberTreecell {
		canvas: canvas;
		tn: tn;
		tv: tv;
	    }
	    cellMap.put(tn, r);
	}
	return r;
    }

    const tv is Treeview = Treeview {
	transform: bind translate(0, -treeHeight/2+cellHeight/2);
	height: bind treeHeight;
	width: bind width;
	model: bind treeModel;
	override bound function createCell from (tn is Treenode) to Treecell 
	{
	    self.getCell(tn as MemberTreenode)
	}      
    };

    override var internalContent = bind tv;

    // fix me: move this stuff to canvas

    const onDown = tv.observeMouseDown().subscribe(function from (e is MouseEvent) to () {
            canvas.treeLinker.onDown(tv, e);
	} );
    const onDrag = tv.observeMouseDrag().subscribe(function from (e is MouseEvent) to () {
            canvas.treeLinker.onDrag(e);
	});
    const onUp = tv.observeMouseUp().subscribe(function from (e is MouseEvent) to () {
            canvas.treeLinker.onUp(e);
	});

}

class TreeLinker {
    var canvas is Canvas;
    var tv is Treeview;
    var pathFactory = bind canvas.pathFactory;
    var layoutEngine = bind canvas.layoutEngine;
    var imageLoader = bind canvas.imageLoader;
    var effectLoader = bind canvas.effectLoader;

    function onDown from (tv is Treeview, e is MouseEvent) to () 
    {
        if (e.location.x >= 0) {
            this.tv = tv;
            const cell = tv.selectedTreecell as MemberTreecell;
            linkTmpLink();
            dx = 0; dy = 0;
            cell.linkedView.unlink();
            startPos = canvas.toLocal * e.sceneLocation;
            insert canvas.targetArrow into canvas.arrows;
            arrowVis = true;
            updateArrow();
        }
    }

    function onDrag from (e is MouseEvent) to ()
    {
        if (tv == null) return;
        dx += e.screenDrag.x;
        dy += e.screenDrag.y;
        updateArrow();
    }

    function updateArrow to () 
    {
        const cell = tv.selectedTreecell as MemberTreecell;
        const tn = tv.selectedTreenode as MemberTreenode;
        const toLocal = canvas.toLocal;
        const sourcePos = toLocal * cell.toSceneTransform.getTranslation();
        linkStart.pos = sourcePos + new Vec3(cell.bounds.extent.x, 0, 0);
        linkEnd.pos = startPos + new Vec3(dx-3.5, dy, 0);
        canvas.targetArrow.tx = linkEnd.pos.x;
        canvas.targetArrow.ty = linkEnd.pos.y;
    }

    function onUp from (e is MouseEvent) to ()
    {
        if (tv == null) return;
        const tn = tv.selectedTreenode as MemberTreenode;
        const cell = tv.selectedTreecell as MemberTreecell;
        arrowVis = false;
        canvas.pickInput(e, tn.m.t, function from (found is LinkedView) to () {
                tmpLink = null;
                tv = null;
                delete canvas.targetArrow from canvas.arrows;
                link.unlink();
                if (found <> null) {
                    //cell.link();
                    const newlink = LinkView { 
                        canvas: canvas;
                        source: cell.linkedView; 
                        target: found;
                    };
                    newlink.link();
                } 
                canvas.dumpSrc();
            });
    }
    var tmpLink is LinkView = null;
    var dx = 0.0;
    var dy = 0.0;
    var arrowVis is Boolean;
    var startPos is Point3;

    const linkStart is LinkedView = LinkedView {
        override function serialize to ExprNode { null }
	override var toSceneTransform = bind translate(pos);
    };
    const linkEnd is LinkedView = LinkedView {
        override function serialize to ExprNode { null }
	override var toSceneTransform = bind translate(pos);
    };

    const link is LinkView = LinkView {
	canvas: bind canvas;
    };

    function linkTmpLink to () 
    {
        link.source = linkStart;
        link.target = linkEnd;
        link.link();
        tmpLink = link;
    }

}

public class LinkInfo {
    override function toString {
	"source: {source}, {sourceIndex}, {sourcePos}; target: {target}, {targetIndex}, {targetPos}";
    }
    public var link is LinkView;
    public var source is Object;
    public var sourcePos is Point3;
    public var sourceIndex is Integer;
    public var target is Object;
    public var targetPos is Point3;
    public var targetIndex is Integer;
    override function equals from (obj is Object) to Boolean {
	if (obj is LinkInfo) then {
	    const x = obj as LinkInfo;
	    link == x.link and source == x.source and
		sourcePos == x.sourcePos and
		sourceIndex == x.sourceIndex and
		target == x.target and
		targetPos == x.targetPos and
		targetIndex == x.targetIndex;
	} else false
    }
}


class Holder is Group, Scissored {
}

class MemberListview is Listview of Member {
    public var targetPosition is Point3;
    public var canvas is Canvas;
    public var k is function from LinkedView to ();
    public var font is Text.Font;
    public var members is Member[];
    override var model =  Listmodel of Member {
        size: bind members.size();
        override function getValue from (i is Integer) to Member {
            members[i];
        }
    };
    override function render from (elem is Listview.Element of Member) to Node {
        var m = elem.value;
        Text.Label {
            font: bind font;
            text: bind m.name;
            foreground: bind if elem.index == selectedRow then selectionForeground else foreground;
            background: bind if elem.index == selectedRow then selectionBackground else background;
            height: bind cellHeight;
            width: bind width;
        }
    }
    var app = observeApply().subscribe(function from (m is Member) to () {
            if (m == null) {
                k(null);
            } else {
                const f = canvas.createMemberView(targetPosition, m, 0) as FunctionView; // hack
                k(f.inputs[0]);
            }
        });
}

public class Canvas is ResizableNode, Focusable, KeyboardInputHandler, Scrollable, MouseInputHandler {

    const treeLinker is TreeLinker = TreeLinker {
        canvas: this;
    }
    function getPopup from (e is MouseEvent, members is Member[], k is function from LinkedView to ()) to Node 
    {
        var r = MemberListview  {
            targetPosition: toLocal * e.picked.dragPoint1;
            canvas: this;
            k: k;
            font: font;
            transform: translate(popupScene.mousePosition.x + 100, popupScene.mousePosition.y, 0);
            members: members;
            height: 200;
            width: 200; 
        }
        popupScene.setFocus(r);
        return r;
      }

    public var interactive is function from () to Boolean;

    public var popupLayer is Group;
    public var popupScene is Scene;

    var prog is Program;

    var selectedExpr is ExpressionView;

    override public bound function getTx to Number { 1.0-(cx + width/2.0) / width }
    override public bound function getSx to Number { 
        //Math.max(width / localSpace.contentBounds.width(), 1.0);
        0.1
    }    

    override public bound function getTy to Number { (cy + height/2.0) / height }

    override public bound function getSy to Number { 
        //Math.max(height / localSpace.contentBounds.height(), 1.0);
        0.2
    }

    override public function setX from (tx is Number, sx is Number) to ()
    {
        cx = (0.5-tx) * width;
    }

    override public function setY from (ty is Number, sy is Number) to ()
    {
        cy = ty * height - height/2.0;
    }

    public function onDrop from (where is Pick, m is Member) to ()
    {
        createMemberView(toLocal * where.scenePoint, m, 0);
    }

    function createMemberView from (pt is Point3, m is Member, offset is Integer) to ExpressionView
    {
        var r is ExpressionView;
        if (m is FunctionMember) {
            const fun = Function {
                funMember: m as FunctionMember;
            }
            insert r = FunctionView { 
                canvas: this;
                fun: fun;
            } into views;
            r.pos = new Point3(pt.x+r.bounds.extent.x, pt.y + cellHeight*(offset+1), pt.z);
        }
        return r;
    }

    public function onDrop from (where is Pick, clip is Context) to ()
    {
        if (clip is Context.ClosureVarContext) {
            var c = clip as Context.ClosureVarContext;
            const typ = c.varType.t;
            var names = new java.util.HashSet of String;
            const members = foreach (m in introspect(typ) where not m.name.contains("pdate") and names.add(m.name)) m;
            insert ObjectView {
                pos: toLocal * where.scenePoint;
                objectExpr: VarContextExpression { 
                    varContext: c, override function getType to F3Type { typ }
                    inputMembers: foreach (m in members where not m.isObservable and m.isObserver and m.rt == UNIT_TYPE) m;
                    //outputMembers: foreach (m in members where m.isObservable and m.m is F3FunctionMember) m;
                }
                canvas: this;
            } into views;
        }
    }

    public function onDrop from (where is Pick, clip is Node) to ()
    {
	println("ON DROP {where.scenePoint}, {where.dragPoint1} {clip}");
	const typ = if (clip is SceneAPI) then Reflect.getType("expr.SceneAPI") else Reflect.getType(clip.getClass().getName());
        var names = new java.util.HashSet of String;
	const members = foreach (m in introspect(typ) where not m.name.contains("pdate") and names.add(m.name)) m;
        for (m in members) {
            println(m);
        }
	insert ObjectView {
	    pos: toLocal * where.scenePoint;
	    objectExpr: NodeExpression { 
                node: clip, override function getType to F3Type { typ }
                inputMembers: foreach (m in members where m.isObserver) m;
                //outputMembers: foreach (m in members where m.isObservable and m.m is F3FunctionMember) m;
            }
	    canvas: this;
	} into views;
    }

    public function onDrop from (where is Pick, clip is TimeNode) to ()
    {
	println("ON DROP {where.scenePoint}, {where.dragPoint1} {clip}");
	const typ = Reflect.getType("f3.media.scene.TimeNode");
	const members = introspect(typ);
	for (m in members where not m.isObservable and m.isObserver) {
	    println(m);
	}
	insert ObjectView {
	    pos: toLocal * where.scenePoint;
	    objectExpr: TimeNodeExpression { 
                timeNode: clip, override function getType to F3Type { typ }
                inputMembers: foreach (m in members where not m.isObservable and m.isObserver and m.t == UNIT_TYPE) m;
                outputMembers: foreach (m in members where m.isObservable and m.m is F3FunctionMember) m;
            }
	    canvas: this;
	} into views;
    }

    readonly var font = bind layoutEngine.createFont("font-size:10;font-family:Lucida Grande;font-weight:bold");

    var portPaint is Paint;

    var localSpace is Node;

    public var toLocal is Mat4 = bind localSpace.toSceneTransform.inverse();

    var BG = ColorPaint(Color.color(.9, .9, .9));
    const cellSelectedBg = ColorPaint(Color.color(.80, .80, .80));
    const cellBg = ColorPaint(Color.color(.7, .7, .7));
    const textFg = ColorPaint(Color.color(.2, .2, .2));
    const titleBg = ColorPaint(Color.color(.9, .9, .9));

    var ARROW_COLOR = Color.color(.2, .2, .2);

    var cellHeight = 16;

    const portArrow is Polygon = Polygon {
	points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
	fillPaint: ColorPaint(Color.WHITE);
    };

    function makeArrow from (c is Color) to MeshNode 
    {
	MeshNode {
	    mesh: bind portArrow.fillMesh.mesh;
	    shader: bind effectLoader.loadPaintShader(ColorPaint(c));
	}
    }

    var targetArrow is TransformNode = TransformNode {
	px: 3.5
	content: bind makeArrow(ARROW_COLOR);
    }

    public var event is Member;
    public var eventContext is Context.MemberContext;

    public var targetNode is ResourceNode;

    public var targetSpace is Node;
    public var targetTime is TimeNode;
    public var targetTimeline is Timeline;
    public var instanceSpace is Group;

    public function lookupVar from (id is String) to Object {
        return null;
    }

    public function lookupSpatial from (id is String) to Node {
	var r = targetSpace.lookup(id);
	println("lookup {id} => {r}");
	return r;
    }

    public function lookupTemporal from (id is String) to TimeNode {
	var r = targetTime.lookup(id);
	println("lookup {id} => {r}");
	return r;
    }

    function reset {
	for (link in links) {
	    link.unlink();
	}
	links = [];
	unsubscribe();
    }

    var rootView is Node = TransformNode { tx: bind -width / 2.0 + 120, content: bind rootExprView };

    public readonly var rootExprView is GetVarView = bind makeGetter(event);

    var varRoot is GetVar;

    function makeGetter from (event is Member) to GetVarView {
	if (event == null) then null else {
		var r = GetVarView {
		    parent: rootView;
		    canvas: this;
		    get: varRoot = GetVar {
			member: event;
		    }
		}
		r.updateParent();
		r;
	    }
    }

    var prevLinkInfo is LinkInfo[];

    var sourceUpdate = 0;
    var sourceVersion = 0;
    var sourceUpdateTime is Long = 0;

    override function preupdate {
        if (sourceVersion > sourceUpdate) {
            const now = java.lang.System.currentTimeMillis();
            if (sourceUpdateTime < now) {
                genSource();
                sourceUpdate = sourceVersion;
            }
        }
	const curLinkInfo = getLinkInfo();
	if (curLinkInfo <> prevLinkInfo) {
	    prevLinkInfo = curLinkInfo;
	    linkMesh = genLines(curLinkInfo);
	}
	super.preupdate();
    }

    var cx is Number;
    var cy is Number;

    const canvas = this;

    const bgRect = Rectangle {
        factory: canvas.pathFactory;
        id: "canvas.bg"
        debug: true;
        width: bind width;
        height: bind height;
        fillPaint: bind ColorPaint(Color.color(.9, .9, .9));
        override function onMouseDrag from (e is MouseEvent) to ()
        {
            const d = (e.picked.dragPoint1-e.picked.dragPoint0);
            println("drag={e.drag}, sceneDrag={e.sceneDrag}");
            canvas.cx += d.x;
            canvas.cy += d.y;
        } 	
    };

    override var internalContent = Holder { 
	scissorBounds: bind Bounds.boundsFromRect(width, height);
	content:
	Group {
	    content:
           [Group { content: bind bgRect },
	   localSpace = Group 
           { 
	       transform: bind translate(cx, cy) * scale(zoomx, zoomy);
	       content: [Group { content: bind rootView }, Group { content: bind views }, Group { content: bind arrows},
                         MeshNode {
                             id: "lines"
                             pickable: false;
                             override var mesh = bind linkMesh;
                             shader: effectLoader.loadPaintShader(ColorPaint(Color.color(.25, .25, .25)));
                         }]
           }]
        };
    };

    var zoomx = 1.0;
    var zoomy = 1.0;

    function deleteSelection to () {
        var n = selectedExpr;
        selectedExpr = null;
        n.unlink();
        delete n from views;
    }

    override function onKeyDown from (e is KeyboardEvent) to () {
        if (e.keyCode == Keys.Delete or e.keyCode == Keys.Backspace) {
            deleteSelection();
        }
    }

    override function onMouseWheel from (e is MouseWheelEvent) to ()
    {
        if (e.metaKey) {
            zoomy *= 1+e.scroll.y*.1;
            zoomx = zoomy;
        }
    }

    const printlnFun = Function {
	fun: getFunction("expr.Console", "println", ["Object"]);
    };

    public var views is ExpressionView[] = [];
    /*
     = FunctionView {
	pos: new Point3(100, 0, 0);
	canvas: this;
	fun: printlnFun;
    };
    */

    var arrows is TransformNode[];

    public var links is LinkView[];

    var lines = LineMesh {};

    var linkMesh is AbstractMesh;

    function getLinkInfo {
	foreach (link in links where link.visible) {
	    var source = link.source;
	    var sourcePos = source.getLinkPos();
	    var target = link.target;
	    var targetPos = target.getLinkPos();
	    makeLinkInfo(link, 
			 source,
			 link.sourceLinkId,
			 sourcePos,
			 target,
                         link.targetLinkId,
			 targetPos);
	}
    }

    function makeLinkInfo 
	from (link is LinkView,
	      source is Object,
	      sourceIndex is Integer,
	      sourcePos is Point3,
	      target is Object,
	      targetIndex is Integer,
	      targetPos is Point3) 
	to LinkInfo
    {
	LinkInfo {
	    link: link;
	    source: source;
	    sourceIndex: sourceIndex;
	    sourcePos: sourcePos;
	    target: target;
	    targetIndex: targetIndex;
	    targetPos: targetPos;
	}
    }

    const lineOff is Vec3 = new Vec3(15, 0, 0);
    const lineOff1 is Vec3 = new Vec3(18.5, 0, 0);

    function genLines from (links is LinkInfo[]) to AbstractMesh {
	lines.reset();
	delete arrows[links.size()..];
	while (arrows.size() < links.size()) {
	    insert TransformNode { content: makeArrow(ARROW_COLOR) } into arrows; 
	}
	for (i in links) {
	    const p0 = i.sourcePos;
	    const sourceOff = lineOff*(i.sourceIndex+1);
	    const p1 = p0 + sourceOff;
	    const p5 = i.targetPos-lineOff1*(i.targetIndex);
	    const targetOff = lineOff*(i.targetIndex+1);
	    const p4 = i.targetPos - targetOff;
	    const mid = p1.lerp(0.5, p4);
	    const p2 = new Point3(p1.x, mid.y, 0);
	    const p3 = new Point3(p4.x, mid.y, 0);
	    const p6 = i.targetPos;
	    lines.moveTo(p0);
	    lines.lineTo(p1);
	    lines.lineTo(p2);
	    lines.lineTo(p3);
	    lines.lineTo(p4);
	    lines.lineTo(p5);
	    lines.lineTo(p6);
	    arrows[indexof i].tx = p6.x;
	    arrows[indexof i].ty = p6.y;
	    //println("gen lines {p0} {p1} {p2} {p3} {p4} {p5}");
	}
	const mesh = lines.getMesh();
	mesh.updateBounds();
	return mesh;
    }


    function pickOutput from (e is MouseEvent, t is F3Type) to ExpressionView 
    {
	for (p in e.scene.underMouse) {
	    const n = p.node;
	    if (n is ResultView) {
		const rv = n as ResultView;
		if (rv.result.getType().isConvertibleFrom(t)) {
		    return rv;
		}
	    }
	}
	null;
    }

    function pickInput 
	from (e is MouseEvent, 
	      t is F3Type,
              k is function from LinkedView to ()) 
	to ()
    {
        var hit = false;
	for (p in e.scene.underMouse) {
	    const n = p.node;
            if (not hit) { hit = n is ExpressionView }
	    if (n is InputView) {
		const pv = n as InputView;
		if (pv.getInputType() == UNIT_TYPE or pv.getInputType().isConvertibleFrom(t)) {
		    println("IS ASSIGNABLE {pv.getClass()} {pv.getInputType()} <- {t}");
		    k(pv);
                    return;
		} else {
		    println("NOT ASSIGNABLE {pv} {pv.getInputType()} <- {t}");
		}
	    }
	}
        if (hit) {
            k(null);
            return;
        }
        var members = introspect(t, true);
        if (members <> []) {
            var popup is Node = getPopup(e, members, function (j is LinkedView) to () {
                    delete popupLayer.content;
                    k(j)
                });
            println("POPUP AT {e.sceneLocation}");
            insert popup into popupLayer.content;
        } else {
            k(null);
        }
    }

    function dumpSrc to () {
        sourceVersion++;
        sourceUpdateTime = java.lang.System.currentTimeMillis()+1000;
    }

    function genSource to () {
	println("DUMP SRC:");
	unsubscribe();
	println(visit(varRoot));
    }

    function getObservers from (e is Expression) to ObserverExpression[]
    {
        var result = 
	if (e is Parameter) 
	    then { 
                const obsvs = (e as Parameter).target.output.observers;
                //println("parameter target = {(e as Parameter).target} obsvs={obsvs}");
                obsvs
            }
            else if (e is InputMemberExpression) then {
               const outs = (e as InputMemberExpression).target.outputs;
               foreach (x in outs) {
                   println("OUT {x} => {x.observers}");
                   x.observers
               }
            }
	    else if (e is ObservableExpression) 
		then (e as ObservableExpression).observers 
		else [];
        //        println("GET PARAMETERS {e} => {result}");
        return result;
    }
    
    function getTerminals from (e is Expression, 
				result is function from Expression to ()) to ()
    {
        getTerminals(null, e, result);
    }

    function getTerminals from (p is Expression,
                                e0 is Expression, 
				result is function from Expression to ()) to ()
    {
        var e = e0;
	const obsvrs = getObservers(e);
	println("observers for {p} / {e} => {obsvrs}");
	if (obsvrs == []) {
            if (e is GetVar) {
                if (p <> null) result(p);
                /*
                println("is getvar: {e}");
                while (true) {
                    if (e is Result) {
                        result((e as Result).source);
                        break;
                    } else if (e is OutputMemberExpression) {
                        result(e);
                        break;
                    }
                    if (e is ObserverExpression) {
                        e = (e as ObserverExpression).observable;
                        println("e=>{e}");
                    } else break;
                }
                */
            } else {
		result(e);
	    }
	} else {
	    for (x in obsvrs) {
                const p1 = if (e is Result) then (e as Result).source else if (e is InputMemberExpression) then e else if (e is Parameter) then e else p;
		getTerminals(p1, x, result)
	    }
	}
    }

    const serializationMap = new java.util.IdentityHashMap of (ExpressionView, ExprNode);
    public const deserializationMap = new java.util.HashMap of (String, LinkView);

    public function installLinks to () 
    {
        println(deserializationMap);
        delete links;
        for (j in deserializationMap.values()) {
            if (j.source <> null and j.target <> null) {
                j.link();
                println("linked {j.id} {j.source} to {j.target}");
                insert j into links;
            } else {
                println("bad link: {j}");
            }
        }
        deserializationMap.clear();
    }

    function getLink from (id is String) to LinkView {
        var result = deserializationMap.get(id);
        if (result == null) {
            result = LinkView {
                canvas: this;
            }
            deserializationMap.put(id, result);
        }
        return result;
    }

    function serialize from (e is ExpressionView) to ExprNode {
        if (e == null) return null;
        var r = serializationMap.get(e);
        println("serializing: { e } => { r }");
        if (r <> null) return r;
        return e.serialize();
    }

    function saveCode to () {
        serializationMap.clear();
        serialize(rootExprView);
        const w = new java.io.StringWriter();
        println("root={rootExprView} => {serializationMap.get(rootExprView)}");
        foreach (obj in views) {
            var x = serialize(obj);
            println("serialize {obj} => {x}");
        }
        var todo = ExprScene {};
        foreach (j in serializationMap.values()) {
            if (j is LinkNode) {
                //insert j as LinkNode into todo.links;
            } else {
                insert j into todo.views;
            }
        }
        for (link in links) {
            insert link.serialize() into todo.links;
        }
        IO.writeObject(w, todo);
        println("serialize => {w}");
        for (link in links) {
            println("Link {link.id} {link.source.expression.getName()}: {link.source.id} => {link.target.expression.getName()}: {link.target.id}");
        }
        var des = IO.readObject(new java.io.StringReader(w.toString()));
        prog.code = todo;
        MasterUndoable.commit();
    }
    
    function visit from (e is Expression) to String
    {
        saveCode();
	var terms is Expression[];
	getTerminals(e, 
		     function from (x is Expression) to ()
		     {
			 println("adding {x}");
			 insert x into terms;
		     });
	var itype = (e as MemberExpression).member.m.getDeclaringClass();
        if (itype == null) return "";
	var result = "var _ = function from (debugger is f3.util.ObservableDebugger, i is {itype.getName()}, getVar is function from String to Object, getNode is function from String to f3.media.scene.Node, getClip is function from String to f3.media.scene.TimeNode) to f3.util.Observable of ? \{ ";
        if (terms == []) {
            var rs = foreach (x in eventContext.content) {
                if (x is Context.ResourceNodeContext) {
                    (x as Context.ResourceNodeContext).resource;
                } else null;
            }
            if (rs <> []) {
                terms = [varRoot];
            }
        }
        for (x in terms) {
	    var src is String;
	    if (x is Parameter) {
		src = (x as Parameter).target.toSource();
	    } else {
		src = x.toSource();
	    }
	    try {
		const toCompile = "{result}{src}\}";
		println("compiling: {toCompile}");
		prog.evaluate(toCompile);
	    } catch (thr is java.lang.Throwable) {
		thr.printStackTrace();
	    }
	    result = "{result}{src};";
	    if (true) {
		break;
	    }
	}
	result;
    }

    public const debugger is ObservableDebugger;
    
    function visit1 from (e is Expression) to String 
    {
	// Observable of a -> function from a to b; // map 
	// Observable of a -> read var member // map 
	// Observable of a -> Observer of a; // subscribe
	// Observable of a -> Observer of a; // subscribe
	// Observable of a -> write var member; // subscribe
	// function from a to b -> function from b to c; // compose
	println("VISIT {e} -> {e.getName()} is {e.getType()}");
	var result = "_";
	if (e is Function) {
	    const f = e as Function;
	    println(f.inputs.size());
	    if (f.fun.isStatic()) {
		"{f.fun.getName()}()";
	    } else {
		"{f.fun.getName()}()";
	    }
	} else if (e is GetVar) {
	    const g = e as GetVar;
	    const m = g.member;
	    for (x in g.observers) {
		var y is Expression = x;
		if (x is Parameter) {
		    var qg is GetVar = g;
		    var prefix2 is String;
		    while (qg <> null) {
			const qm = qg.member;
			prefix2 = 
			    if (qm.m is F3FunctionMember) then {
				    "{qm.name}()";
				} else {
				"{qm.name}";
			    };
			if (qm.isObservable) {
			    prefix2 = "foreach (i in {prefix2}) i";
			} 
			if (result <> "") {
			    result = "{result}.";
			}
			prefix2 = "{result}{prefix2}";
			if (qg.observable is GetVar) {
			    qg = qg.observable as GetVar;
			} else {
			    break;
			}
		    }
		    var prefix = prefix2;
		    const f is Function = (x as Parameter).target;
		    if (f.fun.isStatic()) {
			result = "\{ foreach (i in {result}) {f.getName()}(i{prefix}) \}";
		    } else {
			result = "\{ foreach (i in {result}) i{prefix}{f.getName()}() \}";
		    }
		} else {
		    var huh = visit(y);
		    println("huh? {huh}");
		    if (huh <> "_") {
			result = huh;
		    }
		}
	    }
	    return result;
	} else if (e is ObservableExpression) {
	} else {
	}
	"";
    }

    /*
    function genReflect from (e is Expression) to function from (function from F3Value to F3Value) to F3Value;
    {
	// Observable of a -> function from a to b; // map 
	// Observable of a -> read var member // map 
	// Observable of a -> Observer of a; // subscribe
	// Observable of a -> Observer of a; // subscribe
	// Observable of a -> write var member; // subscribe
	// function from a to b -> function from b to c; // compose
	if (e is Function) {
	    const f = e as Function;
	    var isMap = f.inputs.size() == 1 and f.inputs[0].observable is ObservableExpression;
	    if (isMap) {
		const mapFun = getFunction(f.inputs[0].observable.getType(), "map");
		const k0 = genReflect(f.inputs[0].observable);
		function from (k is function from F3Value to F3Value) to F3Value 
		{
		    k0(function from (target is F3Value) to F3Value {
			    const obj = target as F3ObjectValue;
			    k1(function from (arg is F3Value) to F3Value {
				    k(fun.asFunction(obj).invoke())
				});
			});
		}
	    } else {
		const k0 = genReflect(f.inputs[0].observable);
		const k1 = genReflect(f.inputs[1].observable);
		function from (k is function from F3Value to F3Value) to F3Value 
		{
		    k0(function from (target is F3Value) to F3Value {
			    const obj = target as F3ObjectValue;
			    k1(function from (arg is F3Value) to F3Value {
				    k(fun.asFunction(obj).invoke())
				});
			});
		}
	    }
	} else if (e is ObservableExpression) {
	    const o = e as ObservableExpression;
	    for (x in o.observers) {
	    }
	}
    }
    */

    function unsubscribe {
        prog.reset();
    }

}

public class MemberNode {
    public var name is String;
    public var declaringClass is String;
    public var outputType is String;
    public function deserialize to Member {
        const members = introspect(Reflect.getType(declaringClass) as F3ClassType);
        for (m in members) {
            if (m.name == name) {
                return m;
            }
        }
        return null;
    }
}

public class VarMemberNode is MemberNode {
}

public class FunctionMemberNode is MemberNode {
    public var inputTypes is String[];
    override public function deserialize to Member {
        FunctionMember { m: Reflect.getFunction(declaringClass, name, inputTypes) }
    }
}

public class ExprNode {
    public var id is String;
    public var x is Number;
    public var y is Number;
    public var member is MemberNode;
    public function createView from (canvas is Canvas) to ExpressionView {
        println("implement me!: {this}");
        return null;
    }
}

public class ExprScene {
    public var views is ExprNode[];
    public var links is LinkNode[];
}

public class FunNode is ExprNode {
    public var inputs is TargetNode[];
    public var outputs is SourceNode[];
    public override function createView from (canvas is Canvas) to FunctionView {
        var m = member.deserialize();
        const v = FunctionView {
            canvas: canvas;
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
            fun: Function {
                funMember: m as FunctionMember;
            }
        }
        println("creating function {m}");
        for (n in inputs) {
            var i = indexof n;
            const p = v.inputs[i];
            if (n.links.size() > 0) {
                for (link in n.links) {
                    println("linking parameter {indexof n} linkId={link}");
                    const lnk = canvas.getLink(link);
                    lnk.target = p;
                }
            } 
            println("parameter {i} type is {p.parameter.getType()}");
            if (Reflect.INTEGER_TYPE == p.parameter.getType()) {
                println("int value is {n.intValue}");
                p.intSlider.t = n.intValue / 100.0; // hack
            } else if (Reflect.NUMBER_TYPE == p.parameter.getType()) {
                println("num value is {n.numberValue}");
                p.numSlider.t = n.numberValue;
             } else if (Reflect.BOOLEAN_TYPE == p.parameter.getType()) {
                println("bool value is {n.booleanValue}");
                p.boolSlider.t = if n.booleanValue then 1.0 else 0.5;
            }
        }
        for (p in outputs) {
            println("output: {p}");
            if (p.links.size() > 0) {
                const path = p.sourceId;
                const tn = v.output.getTree.treeModel.resolvePath(path);
                tn.open();
                println("path={path} tn={tn}");
                for (link in p.links) {
                    const lnk = canvas.getLink(link);
                    const cell = v.output.getTree.getCell(tn);
                    const t = cell.linkedView;
                    println("t={t}");
                    lnk.source = t;
                }
            }
        }
        v.pos = new Point3(x, y, 0);
        insert v into canvas.views;
        return v;
    }
}

public class LinkNode is ExprNode {
    public var source is String;
    public var target is String;
}

public class ObjNode is ExprNode {
    public var inputs is TargetNode[];
    public var outputs is SourceNode[];
}

public class NodeObjNode is ObjNode {
    public var nodeId is String;
    public override function createView from (canvas is Canvas) to ObjectView {
        const clip = canvas.lookupSpatial(nodeId);
	const typ = Reflect.getType(clip.getClass().getName());
        const names = new java.util.HashSet of String;
	const members = foreach (m in introspect(typ) where not m.name.contains("pdate") and names.add(m.name)) m;
        const objectExpr =  NodeExpression { 
            node: clip, override function getType to F3Type { typ }
            inputMembers: foreach (m in members where not m.isObservable and m.isObserver and m.rt == UNIT_TYPE) m;
        }
        var result = ObjectView {
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
            canvas: canvas;
            objectExpr: objectExpr;
            pos: new Point3(x, y, 0);
        }
        for (i in inputs) {
            if (i.links.size() > 0) {
                for (link in i.links) {
                    const lnk = canvas.getLink(link);
                    lnk.target = result.inputViews[indexof i];
                }
            }
        }
        insert result into canvas.views;
        return result;
    }
}

public class TimeNodeObjNode is ObjNode {
    public var timeNodeId is String;
    public override function createView from (canvas is Canvas) to ObjectView {
        const clip = canvas.lookupTemporal(timeNodeId);
	const typ = Reflect.getType("f3.media.scene.TimeNode");
        const names = new java.util.HashSet of String;
	const members = foreach (m in introspect(typ) where not m.name.contains("pdate") and names.add(m.name)) m;
        const objectExpr = TimeNodeExpression { 
            timeNode: clip, override function getType to F3Type { typ }
            inputMembers: foreach (m in members where not m.isObservable and m.isObserver and m.rt == UNIT_TYPE) m;
        }
        var result = ObjectView {
            pathFactory: canvas.pathFactory;
            layoutEngine: canvas.layoutEngine;
            imageLoader: canvas.imageLoader;
            effectLoader: canvas.effectLoader;
            canvas: canvas;
            objectExpr: objectExpr;
            pos: new Point3(x, y, 0);
        }
        for (i in inputs) {
            if (i.links.size() > 0) {
                for (link in i.links) {
                    const lnk = canvas.getLink(link);
                    lnk.target = result.inputViews[indexof i];
                }
            }
        }
        insert result into canvas.views;
        return result;
    }
}

public class VarContextObjNode is ObjNode {
    public override function createView from (canvas is Canvas) to ObjectView {
        null
    }
}

public class GetNode is ExprNode {
    public var outputs is SourceNode[];
    public var isOpen is Boolean;
    public override function createView from (canvas is Canvas) to GetVarView {
        const m = member.deserialize();
        var v is GetVarView;
        if (m == canvas.event) {
            v = canvas.rootExprView;
        } else {
            v = GetVarView {
                pathFactory: canvas.pathFactory;
                layoutEngine: canvas.layoutEngine;
                imageLoader: canvas.imageLoader;
                effectLoader: canvas.effectLoader;
                canvas: canvas;
                pos: new Point3(x, y, 0);
                get: GetVar {
                    member: member.deserialize();
                }
            }
            insert v into canvas.views;
        }
        if (isOpen) {
            v.tv.open();
        }
        println("GetNode outputs: {outputs.size()}");
        for (p in outputs) {
            println("output: {p}");
            if (p.links.size() > 0) {
                const path = p.sourceId;
                const tn = v.tv.treeModel.resolvePath(path);
                tn.open();
                println("path={path} tn={tn}");
                println("v={v}, tv={v.tv}, treeModel={v.tv.treeModel}");
                for (link in p.links) {
                    const lnk = canvas.getLink(link);
                    const t = v.tv.getCell(tn).linkedView;
                    println("t={t}");
                    lnk.source = t;
                }
            }
        }
        return v;
    }
}

public class TargetNode is ExprNode {
    public var targetId is String;
    public var links is String[];
    public var intValue is Integer;
    public var numberValue is Number;
    public var booleanValue is Boolean;
}

public class SourceNode is ExprNode {
    public var sourceId is String;
    public var links is String[]
}

public class Editor is ResizableNode, Focuser {

    public var popupLayer is Group;
    public var popupScene is Scene;

    override public function getTargetOfFocus to Focusable { canvas }

    public var targetNode is ResourceNode;
    public var eventContext is Context.MemberContext;
    public var event is Member = bind eventContext.member;

    public var targetSpace is Node;
    public var targetTime is TimeNode;
    public var targetTimeline is Timeline;
    public var instanceSpace is Group;
    public var debugger is ObservableDebugger;

    function getTargetNode from (c is Context) to ResourceNode {
        var ctx = c;
        while (ctx <> null and not (ctx is Context.ResourceNodeContext)) {
            ctx = ctx.parent;
        }
        return (ctx as Context.ResourceNodeContext).resource;
    }

    var canvas is Canvas = bind getCanvas(getTargetNode(eventContext), eventContext);

    override var internalContent = bind sp;

    public const interactive is function from () to Boolean;

    const sp = Scrollpane {
        width: bind width;
        height: bind height;
        content: bind canvas;
    }

    function getCanvas from (target is ResourceNode, eventContext is Context.MemberContext) to Canvas
    {
	var prog is Program;
        println("TARGET: {target.id}, programs={target.programs.size()}");
	for (x in target.programs) {
            println("PROGRAM {x.event.m}, event={eventContext.member.m}");
            println("PROGRAM {java.lang.System.identityHashCode(x.event.m)}, event={java.lang.System.identityHashCode(eventContext.member.m)}");
	    if (x.event == eventContext.member) { // hack
                println("FOUND IT");
		prog = x;
		break;
	    } else {
                println("NO MATCH");
            }
	}
	if (prog == null) {
	    prog = Program { 
                event: event;
                evalContext: Program.EvalContext {
                    interactive: interactive;
                    targetNode: target;
                    debugger: debugger;
                    instanceSpace: instanceSpace;
                    lookupSpatial: targetSpace.lookup;
                    targetTimeline: targetTimeline;
                    lookupTemporal: targetTime.lookup;
                }
            };
	    insert prog into target.programs;
	}
	if (prog.canvas == null) {
            println("creating canvas with {pathFactory}");
	    prog.canvas = Canvas {
                debugger: debugger;
                popupLayer: popupLayer;
                popupScene: popupScene;
                pathFactory: pathFactory;
                width: width;
                height: height;
		targetNode: target,
		event: event;
                eventContext: eventContext;
		targetSpace: targetSpace;
		targetTime: targetTime;
		targetTimeline: targetTimeline;
                instanceSpace: instanceSpace;
	    }
            /*
            for (v in prog.code.views) {
                const j = v.createView(canvas);
                if (j <> null) {
                    insert j into canvas.views;
                }
            }
            */
            prog.canvas.prog = prog;
            prog.deserialize();
            prog.canvas.dumpSrc()
	}
	return prog.canvas;
    }
    
}




 
