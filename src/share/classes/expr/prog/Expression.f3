package expr.prog;
import java.lang.Math;
import f3.math.*;
import f3.math.LinearMath.*;
import expr.*;
import expr.Treeview.*;
import f3.reflect.*;
import expr.Reflect.*;
import f3.util.*;
import f3.lang.*;
import f3.media.input.*;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;

var exprMap = new java.util.HashMap of (F3ClassType, Member[]);

const MAT4_TYPE = ctx.findClass("f3.math.Mat4");

function makeFunMember from (name is String, params is F3Type[], ret is F3Type) to Member 
{
    FunctionMember {
	ft: ctx.makeFunctionType(params, ret);
	name: name;
	t: ret;
    }
}

const NUM_MEMBERS = 
    foreach (op in ["+", "-", "*", "/", "remainder"]) {
	makeFunMember(op, [NUMBER_TYPE, NUMBER_TYPE], NUMBER_TYPE)
    };
const INT_MEMBERS = 
    foreach (op in ["+", "-", "*", "/", "remainder"]) {
	makeFunMember(op, [INTEGER_TYPE, INTEGER_TYPE], INTEGER_TYPE)
    };
const BOOL_MEMBERS = 
    [foreach (op in ["and", "or"]) {
	makeFunMember(op, [BOOLEAN_TYPE, BOOLEAN_TYPE], BOOLEAN_TYPE)
	}, makeFunMember("not", [BOOLEAN_TYPE], BOOLEAN_TYPE)];

public function introspect from (t is F3Type) to Member[]
{
    if (t.getName() == "org.f3.runtime.F3Object" or
	t.getName() == "org.f3.runtime.F3Base" or
	t.getName() == "java.lang.Object") {
	return []
    }
    if (t is F3ClassType) then introspect(t as F3ClassType) else if (true) [] else {
	    if (t == NUMBER_TYPE) 
		then NUM_MEMBERS
		else if (t == INTEGER_TYPE)
		    then INT_MEMBERS 
		    else if (t == BOOLEAN_TYPE)
			then BOOL_MEMBERS
			else []
    }
}

public function introspect from (clazz is F3ClassType) to Member[]
{
    if (exprMap.containsKey(clazz)) {
	return exprMap.get(clazz);
    }
    var result is Member[];
    const funs = clazz.getFunctions(true);
    for (f in funs where f.isPublic() and not f.getName().contains("$") and 
	     OBJECT_TYPE <> f.getDeclaringClass() 
	 ) { 
	const ft = f.getType();
	var rt = ft.getReturnType();
	var toInsert is Member;
	if (ft.minArgs() == 0) {
	    if (SUBJECT_TYPE.isAssignableFrom(rt) or OBSERVABLE_TYPE.isAssignableFrom(rt) or OBSERVER_TYPE.isAssignableFrom(rt)) {
		rt = getTypeArguments(rt)[0];
	    } else {
		continue;
	    }	
	    if (SUBJECT_TYPE.isAssignableFrom(rt)) {
		toInsert = Member {
		    m: f;
		    t: rt
		    isObservable: true, isObserver: true;
		}
		println("Subject of ({getTypeArguments(rt)})");
	    }  else if (OBSERVABLE_TYPE.isAssignableFrom(rt)) {
		toInsert = Member {
		    m: f;
		    t: rt
		    isObservable: true;
		}
		println("Observable of ({getTypeArguments(rt)})");
	    } else if (OBSERVER_TYPE.isAssignableFrom(rt)) {
		toInsert = Member {
		    m: f;
		    t: rt
		    isObserver: true;
		}
		println("Observer of ({getTypeArguments(rt)})");
	    } else {
		continue;
	    }
	} else {
	    if (UNIT_TYPE <> rt) {
		continue;
	    }
	    if (ft.minArgs() == 0) {
		// observer of ()
		rt = UNIT_TYPE;
	    } else if (ft.minArgs() == 1) {
		// observer of ft.getArgumentType(0)
		//println("{f.getName()} => Observer of ({ft.getArgumentType(0)})");
	    } else if (ft.minArgs() == 1) {
		// observer of (ft.getArgumentType(0), ft.getArgumentType(1))
		continue;
	    }
	    toInsert = Member {
		m: f;
		t: rt;
		isObserver: true;
	    }
	}
	if (toInsert <> null) {
	    insert toInsert into result;
	}
    }
    const vars = clazz.getVariables(true);
    for (v in vars where not v.getName().contains("$") and not v.getName().startsWith("bnds") and not v.isStatic()) {
	var toInsert is Member;
	if (true or not v.isPublicInit() and not v.isDef()) {
	    var rt = v.getType();
	    if (SUBJECT_TYPE.isAssignableFrom(rt) or OBSERVABLE_TYPE.isAssignableFrom(rt) or OBSERVER_TYPE.isAssignableFrom(rt)) {
		rt = getTypeArguments(rt)[0];
	    }	
	    if (not v.isPublicRead() and not v.isPublicInit() and not v.isDef()) {
		println("{v.getName()} => Subject of ({rt})");
		toInsert = Member {
		    m: v;
		    t: rt
		    isObserver: true;
		    isObservable: true;
		}
	    } else if (v.isPublic() or v.isPublicRead() or v.isPublicInit()) {
		println("{v.getName()} => Observable of ({rt})");
		toInsert = Member {
		    m: v;
		    t: rt
		    isObservable: true;
		}
	    } else {
	    }
	}
	if (toInsert <> null) {
	    insert toInsert into result;
	}
    }
    result = foreach (x in result where not x.t.isAssignableFrom(MAT4_TYPE)) x;
    exprMap.put(clazz, result);
    return result;
}

public class Member {
    public const m is F3Member; 
    public const t is F3Type;
    public const name = m.getName();
    public var isObservable is Boolean;
    public var isObserver is Boolean;
    public function getMembers to Member[]
    {
	Expression.introspect(t);
    }
}

public class FunctionMember is Member {
    public const ft is F3FunctionType;
}


function argName from (ft is F3FunctionType, i is Integer) to String {
    const t = ft.getArgumentType(i);
    const n = t.getName();
    const dot = n.lastIndexOf(".");
    return n.substring(dot+1);
}

function resultName from (ft is F3FunctionType) to String {
    ft.getReturnType().getName();
}

public interface Expression {
    public function getName to String;
    public function getType to F3Type;
    override function toString { "{getClass()}: {getName()} / {getType()}" }
}

public interface MemberExpression is Expression {
    public var member is Member;
    override function getName to String { member.name }
}

public interface ObservableExpression is Expression {
    public var observers is ObserverExpression[];
}

public interface ObserverExpression is Expression {
    public var observable is ObservableExpression;
}

public interface VarExpression is MemberExpression {
    override function getType to F3Type { member.t }
}

public class GetVar is VarExpression, ObservableExpression, ObserverExpression {
}

public class SetVar is VarExpression, ObserverExpression {
}

public class Function is MemberExpression {
    public const fun is F3FunctionMember;
    const ft = fun.getType();
    postinit {
	member = Member {
	    m: fun;
	    t: ft;
	}
    }
    override function getType { ft }
    public var inputs is Parameter[] =
	bind foreach (i in [0..<ft.minArgs()]) {
	Parameter {
	    name: argName(ft, i);
	    target: this;
	    t: ft.getArgumentType(i)
	}
    }
    public var output is Result = Result {
	t: ft.getReturnType()
    }
}

public class Parameter is ObserverExpression {
    public var name is String;
    public var t is F3Type;
    public var target is Function;
    override function getName to String { name }
    override function getType to F3Type { t }
}

public class Result is ObservableExpression {
    override function getName to String { "return" }
    public var t is F3Type;
    public var source is Function;
    override function getType to F3Type { t }
}

public class Program {
    public var start is ObservableExpression;
}

class DataArrow is MeshNode.Instance {
}

class ControlArrow is MeshNode.Instance {
}

public class ExpressionView is AbstractNode {
    override function toString { "{super.toString()}: {expression}" }
    public const canvas is Canvas;
    public var expression is Expression;
    public var pos is Point3;
    public var cellWidth is Number = 150;
    public var cellHeight is Number = bind canvas.cellHeight;
    public var font is Text.Font = bind canvas.font;
    public const label is Text.Label = Text.Label {
	text: bind expression.getName();
	height: bind cellHeight;
	width: bind cellWidth;
	font: bind font;
	foreground: bind canvas.textFg;
	background: bind canvas.cellBg;
	pickable: true;
    };
    function onDown from (e is MouseEvent) to () 
    {
    }
    function onDrag from (e is MouseEvent) to () 
    {
	println("dragging {label.text}");
	pos += e.picked.dragPoint1 - e.picked.dragPoint0;
    }
    function onUp from (e is MouseEvent) to () 
    {
    }
    var d1;
    var d2;
    var d3;
    postinit {
	d1 = label.observeMouseDown().subscribe(onDown);
	d2 = label.observeMouseUp().subscribe(onUp);
	d3 = label.observeMouseDrag().subscribe(onDrag);
    }
}

class FunctionView is ExpressionView {
    public var fun is Function;
    override var transform = bind translate(pos);
    override var expression = bind fun;
    var inputs is ParameterView[] = bind foreach (p in fun.inputs) ParameterView {
	canvas: bind canvas;
	parameter: p;
	cellWidth: bind cellWidth;
    };
    var output = ResultView {
	canvas: bind canvas;
	result: bind fun.output;
    };
    const io = Group {
	transform: bind translate(0, -cellHeight);
	content: 
	[
	 Group {
	     content: bind inputs
	 }
	 Group {
	     transform: bind translate(0, -inputs.size() * cellHeight);
	     content: bind output;
	 }]
    };
    override var internalContent = Group {
	content: bind [label, io];
    }

    override function update {
	super.update();
	for (i in inputs) {
	    i.index = indexof i;
	}
    }
}

class GetVarView is LinkedView {
    public var get is GetVar;
    override var transform = bind translate(pos);
    override var expression = bind get;
    override var internalContent = Group {
	content: ObjectExpressionView {
	    canvas: bind canvas;
	    width: 150;
	    height: 200;
	    get: bind get;
	}
    }
}

class LinkView is ExpressionView {
    public var target is LinkedView;
    public var source is LinkedView;
    function link from () to () {
	insert this into target.links;
	insert this into source.links;
	insert this into canvas.links;
	const obsvr = target.expression as ObserverExpression;
	const obsvb = source.expression as ObservableExpression;
	insert obsvr into obsvb.observers;
	obsvr.observable = obsvb;
	println("LINKING {source} to {target}");
    }

    function unlink from () to () {
	delete this from target.links;
	delete this from source.links;
	delete this from canvas.links;
	const obsvr = target.expression as ObserverExpression;
	const obsvb = source.expression as ObservableExpression;
	if (obsvr.observable == obsvb) {
	    obsvr.observable = null;
	}
	delete obsvr from obsvb.observers;
	println("UNLINKING {source} from {target}");
    }
}

class LinkedView is ExpressionView {
    var links is LinkView[];
    function unlink from () to () {
	for (link in links) {
	    link.unlink();
	}
    }
    function link from () to () {
	for (link in links) {
	    link.link();
	}
    }
    public function getLinkPos to Point3 { (toSceneTransform * canvas.toLocal).getTranslation() }
}

public class ParameterView is LinkedView {

    const parameter is Parameter;

    var index is Integer;
    
    override var transform = bind translate(0, index * -cellHeight);

    override var expression = bind parameter;

    override var internalContent = bind label;

    override function onDown from (e is MouseEvent) to () 
    {
    }
    override function onDrag from (e is MouseEvent) to () 
    {
    }
    override function onUp from (e is MouseEvent) to () 
    {
    }

    override function getLinkPos to Point3 { super.getLinkPos() - new Vec3(cellWidth/2, 0, 0) }
}

class ResultView is LinkedView {

    public var result is Result;
    override var expression = bind result;

    override var internalContent = Group 
    {
	content: ObjectExpressionView {
	    canvas: bind canvas;
	    width: 150;
	    height: 200;
	    event: Member {
		m: null;
	        t: bind result.getType();
		name: "return"
	    }
	}

    }

    override function onDrag from (e is MouseEvent) to () 
    {
	//targetPos = e.location;
	const source = canvas.pickInput(e, result.getType());
    }

    override function onDown from (e is MouseEvent) to () 
    {
    }

    override function onUp from (e is MouseEvent) to () 
    {
    }

    override function getLinkPos to Point3 { super.getLinkPos() + new Vec3(cellWidth/2, 0, 0) }
}

class MemberTreenode is Treenode {
    public var m is Member;
    public var get = bind GetVar { member: m }
    override var label = bind m.name;
    readonly var members = bind m.getMembers();
    override var canOpen = bind { var n = members.size(); n > 0 };
    override var children = bind foreach (x in members) makeTreeNode(x);
    function makeTreeNode from (x is Member) to MemberTreenode {
	const m = MemberTreenode {
	    m: x;
	}
	insert m.get into get.observers;
	m.get.observable = get;
	return m;
    };
    override function open {
    	children;
	super.open();
    }
}

public class MemberTreemodel is Treemodel {
    public var member is Member;
    override var root = MemberTreenode { m: bind member };
}

public class MemberTreecell is Treeview.Treecell 
{
    public var canvas is Canvas;
    const self = this;

    var parentLink is LinkView;

    function link from () to ()
    {
	var n = (tn as MemberTreenode);
	var p = (n.parent as MemberTreenode);
	const pv = tv.getView(p) as MemberTreecell;
	if (pv <> null) {
	    if (parentLink == null) {
		parentLink = LinkView {
		    canvas: canvas;
		    source: pv.linkedView;
		    target: linkedView;
		}
	    }
	    parentLink.link();
	}
    }

    function unlink from () to ()
    {
	parentLink.unlink();
    }

    const linkedView is GetVarView = GetVarView {
	get: bind (tn as MemberTreenode).get;
	override function getLinkPos to Point3 {
	    const me = self.canvas.toLocal * self.boundsInScene;
	    const container = self.canvas.toLocal * self.canvas.boundsInScene;
	    return new Point3(me.right(), 
			      Math.max(Math.min(0, me.center.y),
				       canvas.height),
			      0);
	}
    }
}

class ObjectExpressionView is ResizableNode {
    public var event is Member;
    public var canvas is Canvas;
    public var cellHeight = bind canvas.cellHeight;
    public var get is GetVar;
    const treeModel = MemberTreemodel {
	root: MemberTreenode {
	    get: bind get;
	    m: bind get.member;
	}
    };
    var treeHeight = bind Math.min(treeModel.rowCount, 5)*cellHeight;
    const self = this;
    const tv is Treeview = Treeview {
	transform: bind translate(0, -treeHeight/2+cellHeight/2);
	height: bind treeHeight;
	width: bind width;
	model: bind treeModel;
	override bound function createCell from (tn is Treenode) to Treecell 
	{
	    MemberTreecell {
		canvas: bind self.canvas;
		tn: bind tn;
		tv: this;
	    }
	}
    };
    override var internalContent = bind tv;

    // fix me: move this stuff to canvas

    const linkStart is LinkedView = LinkedView {
	override function getLinkPos to Point3 { pos }
    };
    const linkEnd is LinkedView = LinkedView {
	override function getLinkPos to Point3 { pos }
    };
    const link is LinkView = LinkView {
	canvas: bind canvas;
	source: linkStart;
	target: linkEnd;
    };
    var tmpLink is LinkView = null;
    var dx = 0.0;
    var dy = 0.0;
    var arrowVis is Boolean;
    var startPos is Point3;
    const onDown = tv.observeMouseDown().subscribe(function from (e is MouseEvent) to () {
	    if (e.location.x >= 0) {
		const cell = tv.selectedTreecell as MemberTreecell;
		const tn = tv.selectedTreenode as MemberTreenode;
		const toLocal = canvas.toLocal;
		cell.linkedView.unlink();
		tmpLink = link;
		println("CREATING LINK {e} ");
		dx = 0; dy = 0;
	    }
	} );
    const onDrag = tv.observeMouseDrag().subscribe(function from (e is MouseEvent) to () {
	    if (tmpLink == null) return;
	    if (not arrowVis) {
		startPos = canvas.toLocal * e.picked.dragPoint0;
		insert canvas.targetArrow into canvas.views;
		arrowVis = true;
		link.link();
	    }
	    const cell = tv.selectedTreecell as MemberTreecell;
	    const tn = tv.selectedTreenode as MemberTreenode;
	    const toLocal = canvas.toLocal;
	    const sourcePos = toLocal * cell.toSceneTransform.getTranslation();
	    dx += e.screenDrag.x;
	    dy += e.screenDrag.y;
	    linkStart.pos = sourcePos + new Vec3(cell.bounds.extent.x, 0, 0);
	    linkEnd.pos = startPos + new Vec3(dx-7, dy, 0);
	    println("e={e.sceneLocation} / {e.location}");
	    println("link from {linkStart.pos} to {linkEnd.pos}");
	    canvas.targetArrow.tx = linkEnd.pos.x;
	    canvas.targetArrow.ty = linkEnd.pos.y;
	    println("picked => {canvas.pickInput(e, tn.m.t)}");
	});
    const onUp = tv.observeMouseUp().subscribe(function from (e is MouseEvent) to () {
	    if (tmpLink == null) return;
	    const tn = tv.selectedTreenode as MemberTreenode;
	    const cell = tv.selectedTreecell as MemberTreecell;
	    const found = canvas.pickInput(e, tn.m.t);
	    arrowVis = false;
	    tmpLink = null;
	    link.unlink();
	    delete canvas.targetArrow from canvas.views;
	    if (found <> null) {
		cell.link();
		const newlink = LinkView { 
		    canvas: canvas;
		    source: cell.linkedView; 
		    target: found;
		};
		newlink.link();
		canvas.dumpSrc();
	    }
	});

}

public class LinkInfo {
    override function toString {
	"source: {source}, {sourceIndex}, {sourcePos}; target: {target}, {targetIndex}, {targetPos}";
    }
    public var link is LinkView;
    public var source is Object;
    public var sourcePos is Point3;
    public var sourceIndex is Integer;
    public var target is Object;
    public var targetPos is Point3;
    public var targetIndex is Integer;
    override function equals from (obj is Object) to Boolean {
	if (obj is LinkInfo) then {
	    const x = obj as LinkInfo;
	    link == x.link and source == x.source and
		sourcePos == x.sourcePos and
		sourceIndex == x.sourceIndex and
		target == x.target and
		targetPos == x.targetPos and
		targetIndex == x.targetIndex;
	} else false
    }
}

class Holder is Group, Scissored {
}

public class Canvas is ResizableNode {

    readonly var font = bind layoutEngine.createFont("font-size:11;font-style:LucidaSans");

    var portPaint is Paint;

    var localSpace is Node;

    public var toLocal is Mat4 = bind localSpace.toSceneTransform.inverse();

    var BG = ColorPaint(Color.color(.9, .9, .9));

    const cellBg = ColorPaint(Color.color(.7, .7, .7));
    const textFg = ColorPaint(Color.color(.2, .2, .2));

    var ARROW_COLOR = Color.color(.2, .2, .2);

    var cellHeight = 16;

    const portArrow is Polygon = Polygon {
	points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
	fillPaint: ColorPaint(Color.WHITE);
    };

    function makeArrow from (c is Color) to MeshNode 
    {
	MeshNode {
	    mesh: bind portArrow.fillMesh.mesh;
	    shader: bind effectLoader.loadPaintShader(ColorPaint(c));
	}
    }

    var targetArrow is TransformNode = TransformNode {
	px: 3.5
	content: bind makeArrow(ARROW_COLOR);
    }

    public var event is Member;

    var rootView is Node = Group { content: bind makeGetter(event) };

    var varRoot is GetVar;

    function makeGetter from (event is Member) to GetVarView {
	if (event == null) then null else {
		var r = GetVarView {
		    parent: rootView;
		    canvas: this;
		    pos: new Point3(-width/2+120, 0, 0);
		    get: varRoot = GetVar {
			member: event;
		    }
		}
		r.updateParent();
		r;
	    }
    }

    var prevLinkInfo is LinkInfo[];

    override function preupdate {
	const curLinkInfo = getLinkInfo();
	if (curLinkInfo <> prevLinkInfo) {
	    prevLinkInfo = curLinkInfo;
	    linkMesh = genLines(curLinkInfo);
	}
	super.preupdate();
    }

    var cx is Number;
    var cy is Number;

    override var internalContent = Holder { 
	scissorBounds: bind Bounds.boundsFromRect(width, height);
	content:
	Group {
	    content:
	    [Rectangle {
		id: "canvas.bg"
		debug: true;
		width: bind width;
		height: bind height;
		fillPaint: bind ColorPaint(Color.color(.9, .9, .9));
		override function onMouseDrag from (e is MouseEvent) to ()
		{
		    const d = (e.picked.dragPoint1-e.picked.dragPoint0);
		    println("drag={e.drag}, sceneDrag={e.sceneDrag}");
		    cx += d.x;
		    cy += d.y;
		} 	
	   },
	   localSpace = Group 
           { 
		transform: bind translate(cx, cy);
		content: [Group { content: bind rootView }, Group { content: bind views }]; 
	   },
	   MeshNode {
		transform: bind translate(cx, cy);
		id: "lines"
		pickable: false;
		override var mesh = bind linkMesh;
		shader: effectLoader.loadPaintShader(ColorPaint(Color.color(.25, .25, .25)));
	    }]
        };
    };

    const printlnFun = Function {
	fun: getFunction("f3.lang.Builtins", "println", ["Object"]);
    }

    var views is Node[] = FunctionView {
	pos: new Point3(100, 0, 0);
	canvas: this;
	fun: printlnFun;
    };

    var links is LinkView[];

    var lines = LineMesh {};

    var linkMesh is AbstractMesh;

    function getLinkInfo {
	foreach (link in links) {
	    var source = link.source;
	    var sourcePos = source.getLinkPos();
	    var target = link.target;
	    var targetPos = target.getLinkPos();
	    makeLinkInfo(link, 
			 source,
			 Sequences.indexOf(source.links, link),
			 sourcePos,
			 target,
			 Sequences.indexOf(target.links, link),
			 targetPos);
	}
    }

    function makeLinkInfo 
	from (link is LinkView,
	      source is Object,
	      sourceIndex is Integer,
	      sourcePos is Point3,
	      target is Object,
	      targetIndex is Integer,
	      targetPos is Point3) 
	to LinkInfo
    {
	LinkInfo {
	    link: link;
	    source: source;
	    sourceIndex: sourceIndex;
	    sourcePos: sourcePos;
	    target: target;
	    targetIndex: targetIndex;
	    targetPos: targetPos;
	}
    }

    const lineOff is Vec3 = new Vec3(15, 0, 0);

    function genLines from (links is LinkInfo[]) to AbstractMesh {
	lines.reset();
	for (i in links) {
	    const p0 = i.sourcePos;
	    const sourceOff = lineOff*(i.sourceIndex+1);
	    const p1 = p0 + sourceOff;
	    const p5 = i.targetPos;
	    const targetOff = lineOff*(i.targetIndex+1);
	    const p4 = i.targetPos - targetOff;
	    const mid = p1.lerp(0.5, p4);
	    const p2 = new Point3(p1.x, mid.y, 0);
	    const p3 = new Point3(p4.x, mid.y, 0);
	    lines.moveTo(p0);
	    lines.lineTo(p1);
	    lines.lineTo(p2);
	    lines.lineTo(p3);
	    lines.lineTo(p4);
	    lines.lineTo(p5);
	    lines.lineTo(p5);
	    println("gen lines {p0} {p1} {p2} {p3} {p4} {p5}");
	}
	const mesh = lines.getMesh();
	mesh.updateBounds();
	return mesh;
    }

    function pickOutput from (e is MouseEvent, t is F3Type) to ExpressionView 
    {
	for (p in e.scene.underMouse) {
	    const n = p.node;
	    if (n is ResultView) {
		const rv = n as ResultView;
		if (rv.result.getType().isAssignableFrom(t)) {
		    return rv;
		}
	    }
	}
	null;
    }

    function pickInput 
	from (e is MouseEvent, 
	      t is F3Type) 
	to LinkedView 
    {
	for (p in e.scene.underMouse) {
	    const n = p.node;
	    if (n is ParameterView) {
		const pv = n as ParameterView;
		if (pv.parameter.getType().isAssignableFrom(t)) {
		    return pv;
		} else {
		    println("NOT ASSIGNABLE {pv.parameter.getType()} <- {t}");
		}
	    }
	}
	null;
    }

    function dumpSrc {
	visit(varRoot);
    }

    function visit from (e is Expression) to String 
    {
	// Observable of a -> function from a to b; // map 
	// Observable of a -> read var member // map 
	// Observable of a -> Observer of a; // subscribe
	// Observable of a -> Observer of a; // subscribe
	// Observable of a -> write var member; // subscribe
	// function from a to b -> function from b to c; // compose
	println("VISIT {e} -> {e.getName()} is {e.getType()}");
	if (e is Function) {
	    const f = e as Function;
	    foreach (p in f.inputs) visit(p);
	    visit(f.output);
	} else if (e is ObservableExpression) {
	    const o = e as ObservableExpression;
	    println("observers = {o.observers.size()}");
	    for (x in o.observers) {
		println("observer = {x}");
		if (x is Parameter) {
		    visit((x as Parameter).target);
		} else {
		    visit(x);
		}
	    }
	} else {

	}
	"";
    }

    /*
    function genReflect from (e is Expression) to function from (function from F3Value to F3Value) to F3Value;
    {
	// Observable of a -> function from a to b; // map 
	// Observable of a -> read var member // map 
	// Observable of a -> Observer of a; // subscribe
	// Observable of a -> Observer of a; // subscribe
	// Observable of a -> write var member; // subscribe
	// function from a to b -> function from b to c; // compose
	if (e is Function) {
	    const f = e as Function;
	    var isMap = f.inputs.size() == 1 and f.inputs[0].observable is ObservableExpression;
	    if (isMap) {
		const mapFun = getFunction(f.inputs[0].observable.getType(), "map");
		const k0 = genReflect(f.inputs[0].observable);
		function from (k is function from F3Value to F3Value) to F3Value 
		{
		    k0(function from (target is F3Value) to F3Value {
			    const obj = target as F3ObjectValue;
			    k1(function from (arg is F3Value) to F3Value {
				    k(fun.asFunction(obj).invoke())
				});
			});
		}
	    } else {
		const k0 = genReflect(f.inputs[0].observable);
		const k1 = genReflect(f.inputs[1].observable);
		function from (k is function from F3Value to F3Value) to F3Value 
		{
		    k0(function from (target is F3Value) to F3Value {
			    const obj = target as F3ObjectValue;
			    k1(function from (arg is F3Value) to F3Value {
				    k(fun.asFunction(obj).invoke())
				});
			});
		}
	    }
	} else if (e is ObservableExpression) {
	    const o = e as ObservableExpression;
	    for (x in o.observers) {
	    }
	}
    }
    */

}




 
