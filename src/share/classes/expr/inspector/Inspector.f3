package expr.inspector;
import f3.media.input.*;
import f3.media.scene.*;
import f3.media.scene.Text.LayoutEngine;
import f3.media.scene.Text.Font;
import f3.media.scene.Shape2D.*;
import f3.media.svg.SVG;
import expr.choices.*;
import f3.lang.*;
import f3.util.*;
import f3.util.Observables;
import expr.*;
import expr.Reflect.*;
import f3.reflect.*;
import org.f3.runtime.*;
import expr.prog.Expression;
import expr.prog.Expression.*;
import f3.math.*;
import f3.math.LinearMath.*;
import java.lang.Math;
import expr.undo.*;
import expr.AbstractResourceText.*;
import expr.InspectedElement.*;


public const CAMERA_TYPE = Reflect.getType("f3.media.scene.Camera");
public const CAMERA_SELECTION_TYPE = Reflect.getType("expr.CameraSelection");

class ColorChooser is AbstractNode {

    const colorChooserSvg = SVG {
        url: "{__DIR__}colorchooser.svg";
    };

    public var popupLayer is PopupLayer;

    function show from (sourceScene is Scene, 
                        location is Point3, 
                        onSelect is function from Color to ()) 
        to ()
    {
        if (colorHandlers == []) {
            colorHandlers = initColors();
        }
        popupLayer.visible = true;
        const pt = popupLayer.scene.mousePosition + location;
        x = pt.x;
        y = pt.y;
        insert this into popupLayer.content;
        popupLayer.modal = true;
        this.onSelect = onSelect;
        cancel = popupLayer.observeBackgroundClicked.subscribe(function from (_ is ()) to () {
                hidePopup();
            });
    }
    
    var cancel is Disposable;
    var onSelect is function from Color to ();

    var x is Number;
    var y is Number;

    var colorHandlers is Disposable[];

    override var internalContent = TransformNode {
        tx: bind x+16;
        ty: bind y-25;
        content: bind colorChooserSvg.root;
    };

    function hidePopup to ()
    {
        cancel.dispose();
        delete this from popupLayer.content;
        popupLayer.modal = false;
    }

    function selectColor from (c is Color) to ()
    {
        hidePopup();
        onSelect(c);
    }

    function initColors to Disposable[]
    {
        foreach (row in [0..<4], col in [0..<13]) {
            const cell = lookup("shapePath{row*13+col}");
            println("cell={cell}");
            const shape = cell as MeshNode2D;
            const color = (shape.paint as ColorPaint).color;
            shape.observeTrigger().subscribe(function from (e is MouseEvent) to () {
                    println(shape.id);
                    selectColor(color);
                });
        }
    }
}

function clamp from (n is Number, lo is Number, hi is Number) to Number
{
    Math.min(Math.max(n, lo), hi);
}

public class NumericSliderField is SliderField {

    public var onSetKey is function from () to ();

    public var min is Number = 0.0;
    public var max is Number = 1.0;

    protected function onChange from (n0 is Number) to () 
    {
        var n = n0;
        if (n < min) {
            n = min;
        }
        if (n > max) {
            n = max;
        }
	setT((n-min) / (max-min));
    }

    override function onCommit from (text is String) to () {
        try {
            onChange(java.lang.Float.parseFloat(text));
        } catch (e is java.lang.Exception) {
        }
    }

    override function onCommit to () 
    {
        onChange(min + (max - min)*t);
        MasterUndoable.commit();
    }

    override function getText from (t is Number) to String
    {
	"{%.02f (min + (max - min)*t)}"
    }

    override function filterKeyInput from (k is KeyboardEvent) to Boolean
    {
        if (k.keyChar == "s") {
            onSetKey();
            return false;
        }
        if (k.keyChar == "-" or k.keyChar == "." or java.lang.Character.isDigit(k.keyChar.charAt(0))) {
           return true;
        }
        return false;
    }
}

public class ColorInspector extends AbstractNode {
    public var editable is Boolean = true;
    public var i is InspectedColor;
    public var height is Number = 15;
    var fieldWidth = 30;
    public var r is Number;
    public var g is Number;
    public var b is Number;
    public var a is Number;
    var firstTime is Boolean = true;
    public readonly var selection is Color = bind Color.color(r, g, b, a);
    public var colorChooser is ColorChooser;
    public var popupLayer is PopupLayer;
    override function update to () {
        if (firstTime) {
            firstTime = false;
            const c = i.get();
            red.setT(c.red);
            green.setT(c.green);
            blue.setT(c.blue);
            alpha.setT(c.opacity);
        } else {
            i.set(selection);
        }
        super.update();
    }
    var disp is Disposable;

    public var onSetKey is function from () to ();

    function onChange from (c is Color) to ()
    {
        if (c <> selection) {
            firstTime = true;
        }
    }

    postinit {
        disp = i.observable.subscribe(onChange);
    }

    const colorSelection = Rectangle {
        height: bind height;
        width: bind height;
        fillPaint: bind ColorPaint(selection);
        strokePaint: bind ColorPaint(Color.color(.2, .2, .2));
        pickable: bind editable;
        override function onMouseDown from (e is MouseEvent) to ()
        {
            const pt = toSceneTransform * new Point3(0, -height/2, 0);
            colorChooser.show(e.scene, Point3.<<0>> + (pt - e.sceneLocation), 
                              function from (color is Color) to ()
                              {
                                  red.setT(color.red);
                                  green.setT(color.green);
                                  blue.setT(color.blue);
                                  alpha.setT(color.opacity);
                              });
        }
    }

    const red = NumericSliderField {
        editable: bind editable;
        onSetKey: bind onSetKey;
        min: 0.0;
        max: 1.0;
        height: bind height;
        width: bind fieldWidth;
        override function setT from (t is Number) to ()
        {
            r = clamp(t, min, max);
            super.setT(r);
        }
    }

    const green = NumericSliderField {
        editable: bind editable;
        onSetKey: bind onSetKey;
        min: 0.0;
        max: 1.0;
        height: bind height;
        width: bind fieldWidth;
        override function setT from (t is Number) to ()
        {
            g = clamp(t, min, max);
            super.setT(g);
        }
    }

    const blue = NumericSliderField {
        editable: bind editable;
        onSetKey: bind onSetKey;
        min: 0.0;
        max: 1.0;
        height: bind height;
        width: bind fieldWidth;
        override function setT from (t is Number) to ()
        {
            b = clamp(t, min, max);
            super.setT(b);
        }
    }

    const alpha = NumericSliderField {
        editable: bind editable;
        onSetKey: bind onSetKey;
        min: 0.0;
        max: 1.0;
        height: bind height;
        width: bind fieldWidth;
        override function setT from (t is Number) to ()
        {
            a = clamp(t, min, max);
            super.setT(a);
        }
    }

    var t1 is TransformNode;
    var t2 is TransformNode;
    var t3 is TransformNode;
    var t4 is TransformNode;

    const margin = 5;

    bound function colorRect from (x is NumericSliderField, c is Color) to Rectangle {
        Rectangle {
            pickable: false;
            strokePaint: bind ColorPaint(c);
            cx: bind x.bounds.center.x;
            cy: bind x.bounds.center.y;
            width: bind x.bounds.width();
            height: bind x.bounds.height();
        }
    }

    const contentGroup = Group {
        content:
        [t1=TransformNode {
            content: bind colorSelection;
        },
        t2=TransformNode {
            tx: bind t1.bounds.right() + margin + fieldWidth/2;
            content: bind [red, colorRect(red, Color.color(red.t, 0, 0))];
        },
        t3=TransformNode {
            tx: bind t2.bounds.right() + margin + fieldWidth/2;
            content: bind [green, colorRect(green, Color.color(0, green.t, 0))];
        },
        t4=TransformNode {
            tx: bind t3.bounds.right() + margin + fieldWidth/2;
            content: bind [blue, colorRect(blue, Color.color(0, 0, blue.t))];
        },
        TransformNode {
            tx: bind t4.bounds.right() + margin + fieldWidth/2;
            content: bind alpha;
        }]
    };
    override var internalContent = TransformNode {
        tx: bind -contentGroup.bounds.width()/2;
        content: bind contentGroup;
    }
}

public var allFontFamilies is String[];

function inspectedFontFamily from (ptr is ObservableRef of FontFamilySelection,
                                   member is Member,
                                   label is String,
                                   families is String[]) to InspectedFontChoice of FontFamilySelection

{
    InspectedFontChoice of FontFamilySelection {
        attr: "font-family";
        fieldWidth: 512;
        label: label;
        member: member;
        choices: foreach (x in families) new FontFamilySelection(x);
        observable: Observables.observe(ptr);
        override function get to FontFamilySelection { 
            ptr.get() ;
        }
        override function set from (x is FontFamilySelection) to () { 
            ptr.set(x);
        }
    }
}

function inspectedFontWeight from (ptr is ObservableRef of FontWeightSelection,
                                   member is Member,
                                   label is String,
                                   weights is String[]) to InspectedFontChoice of FontWeightSelection
{
    InspectedFontChoice of FontWeightSelection {
        attr: "font-weight";
        label: label;
        member: member;
        choices: foreach (x in weights) new FontWeightSelection(x);
        observable: Observables.observe(ptr);
        override function get to FontWeightSelection { 
            ptr.get() ;
        }
        override function set from (x is FontWeightSelection) to () { 
            ptr.set(x);
        }
    }
}

function inspectedFontTextDecoration from (ptr is ObservableRef of FontTextDecorationSelection,
                                           member is Member,
                                           label is String
                                           ) to InspectedFontChoice of FontTextDecorationSelection

{
    InspectedFontChoice of FontTextDecorationSelection {
        attr: "text-decoration";
        label: label;
        member: member;
        fieldWidth: 80;
        choices: foreach (x in ["none", "underline", "line-through"]) 
            new FontTextDecorationSelection(x);
        observable: Observables.observe(ptr);
        override function get to FontTextDecorationSelection { 
            ptr.get() ;
        }
        override function set from (x is FontTextDecorationSelection) to () { 
            ptr.set(x);
        }
    }
}


function inspectedFontStyle from (ptr is ObservableRef of FontStyleSelection,
                                   member is Member,
                                   label is String,
                                   styles is String[]) to InspectedChoice of FontStyleSelection

{
    InspectedFontChoice of FontStyleSelection {
        attr: "font-style";
        label: label;
        member: member;
        choices: foreach (x in styles) new FontStyleSelection(x);
        observable: Observables.observe(ptr);
        override function get to FontStyleSelection { 
            ptr.get() ;
        }
        override function set from (x is FontStyleSelection) to () { 
            ptr.set(x);
        }
    }
}


function inspectedFontSize from (ptr is ObservableRef of FontSizeSelection,
                                 member is Member,
                                 label is String,
                                 sizes is Integer[]) to InspectedChoice of FontSizeSelection
{
    InspectedChoice of FontSizeSelection {
        label: label;
        member: member;
        choices: foreach (x in sizes) new FontSizeSelection(x);
        observable: Observables.observe(ptr);
        override function get to FontSizeSelection { 
            ptr.get() ;
        }
        override function set from (x is FontSizeSelection) to () { 
            ptr.set(x);
        }
    }
}

function inspectedCamera 
    from (ptr is ObservableRef of Camera,
          member is Member,
          label is String,
          cameras is Camera[]) 
    to InspectedChoice of Camera
{
    InspectedChoice of Camera {
        label: label;
        member: member;
        choices: cameras;
        labels: foreach (c in cameras) Names.formatName(c.id);
        observable: Observables.observe(ptr);
        override function get to Camera 
        { 
            ptr.get();
        }
        override function set from (x is Camera) to () 
        { 
            ptr.set(x);
        }
    }
}


public abstract class Inspected of a 
{
    public var editable is Boolean = bind member.isObservable;
    public var member is Member;
    public var label is String;
    public var observable is Observable of a;
    protected var index is Integer;
    public function get to a { null } 
    public function set from (x is a) to () {}
}

public class InspectedRange of a is Inspected of a {
    public function getAsString from (t is Number) to String
    {
	"{getFromT(t)}";
    }
    public function getFromT from (t is Number) to a { null }
    public function setFromT from (t is Number) to () 
    { 
        
	set(getFromT(t)); 
    }
}

public class InspectedColor is Inspected of Color {
}

public class InspectedNumber is InspectedRange of Number 
{
    public const low is Number;
    public const hi is Number;
    override function getFromT from (t is Number) to Number 
    { 
	if (hi > low) then low + (hi - low)*t else t;
    }
}

public class InspectedDuration is InspectedRange of Duration 
{
    public const low is Duration;
    public const hi is Duration;
    override function getFromT from (t is Number) to Duration
    { 
	if (hi > low) then low + (hi - low)*t else 1ms*t;
    }
}

public class InspectedChoice of a is InspectedRange of a 
{
    public bound var fieldWidth is Number = 64;
    public bound function getFieldWidth from (font is Font) to Number {
        getWidth(font, labels);
    }
    public const choices is (..a)[];
    public var labels is String[] = bind foreach (choice in choices) "{choice}";

    function getIndex from (t is Number) to Integer 
    {
        Math.round(Math.min(Math.max(0, t), 1.0) * (choices.size()-1)) as Integer;
    }

    function getWidth from (font is Font, labels is String[]) to Number
    {
        var w = 64.0;
        for (x in labels) w = Math.max(font.width(x)+8, w);
        return w;
    }

    override function getAsString from (t is Number) to String
    {
	labels[getIndex(t)];
    }

    override function getFromT from (t is Number) to a
    { 
	choices[getIndex(t)];
    }

    public function getT to Number
    {
        if (choices.size() == 0) {
            return 0;
        }
        if (choices.size() == 1) {
            return 1;
        }
        const v = get();
        for (x in choices) {
            if (x == v) {
                const t = indexof x / ((choices.size()-1) as Number);
                return t;
            }
        }
        println("no match: {v.getClass()}, {v} on {foreach (x in choices) "{x.getClass()}, {x}"}");
        return 0;
    }
}

public class InspectedFontChoice of a is InspectedChoice of a {
    public const attr is String;
    public bound function deriveFont from (font is Font, t is Number) to Font
    {
        var value = this.getAsString(t);
        createFont(font, attr, value);
    }
    function createFont from (orig is Font, attr is String, value is String) to Font {
        println("inspected font {orig}, {attr}, {value}");
        orig.derive("{attr}:{value}");
    }
}

public class InspectedEnum of a is InspectedChoice of a {
    public const clazz is java.lang.Class of a;
    override var choices is (..a)[] = bind clazz.getEnumConstants();
}

public class InspectedBoolean is InspectedRange of Boolean
{
    override public function getAsString from (t is Number) to String
    {
	if (getFromT(t)) then "Yes" else "No"
    }

    override public function getFromT from (t is Number) to Boolean
    {
	t == 0.0
    }
}

public class InspectedString is Inspected of String
{
}

public class InspectedObservable of a is Inspected of Observable of a
{
}


const FG = Color.color(.2, .2, .2, 1);
const FG_PAINT = ColorPaint(FG);
const SELECTED_FG = Color.color(.9, .9, .9, 1);

const SELECTED_FG_PAINT = ColorPaint(SELECTED_FG);
const BG = Color.color(.6, .6, .6);
const BG_PAINT = ColorPaint(BG);
const SELECTED_BG = Color.color(.4, .4, .4);
const SELECTED_BG_PAINT = ColorPaint(SELECTED_BG);
const DARK_BG = Color.color(.5, .5, .5);
const DARK_BG_PAINT = ColorPaint(DARK_BG);
const TRANSPARENT_PAINT = ColorPaint(Color.TRANSPARENT);
const SEMI_TRANSPARENT_PAINT = ColorPaint(Color.color(1, 1, 1, 0.1));

const TEXT_BG_PAINT = ColorPaint(Color.color(.82, .82, .82));

public class NumberField is SliderField {
    public var onSetKey is function from () to ();
    public var i is InspectedNumber;
    public var min is Number = 0.0;
    public var max is Number = 1.0;
    override function filterKeyInput from (k is KeyboardEvent) to Boolean
    {
        if (k.keyChar == "s") {
            onSetKey();
            return false;
        }
        if (k.keyCode == Keys.Backspace or k.keyChar == "." or k.keyChar == "-" or java.lang.Character.isDigit(k.keyChar.charAt(0))) {
           return true;
        }
        return false;
    }
    var disp is Disposable;
    function onChange from (n is Number) to () 
    {
	t = (n-min) / (max-min);
    }
    postinit {
        const n is Number = i.get();
        onChange(n);
        disp = i.observable.subscribe(onChange);
    }
    override var t on replace {
        var n = min + (max - min)*t;
        i.set(n);
    }

    override function onCommit from (text is String) to () {
        var num is Number = i.get();
        try {
            num = java.lang.Float.parseFloat(text);
        } catch (e is java.lang.Exception) {
        }
        onChange(num);
        MasterUndoable.commit();
    }

    override function onCommit to () {
        const n = i.get();
        if (n < min) {
            min = n;
        }
        if (n > max) {
            max = n;
        }
        onChange(n);
        MasterUndoable.commit();
    }
    override function getText from (t is Number) to String
    {
	"{%.04f (min + (max - min)*t)}"
    }
}

public class ChoiceField of a is SliderField, KeyboardInputHandler {
    public var i is InspectedChoice of a;
    override var textInputEnabled = false;
    var disp is Disposable;
    var invalid = true;
    var lastT is Number;
    function onChange from (n is a) to () 
    {
        t = i.getT();
    }

    postinit {
        onChange(i.get());
        disp = i.observable.subscribe(onChange);
    }

    override function setT from (t is Number) to () 
    {
        i.setFromT(t);
    }

    override function onCommit to ()
    {
        MasterUndoable.commit();
    }

    override function getText from (t is Number) to String
    {
        const j is Integer = i.getIndex(t);
	if (j >= 0 and j < i.labels.size()) i.labels[j] else "";
    }

    override function onKeyDown from (e is KeyboardEvent) to () 
    {
        var j is Integer = i.getIndex(t);
        if (e.keyCode == Keys.Left) {
            j--;
            if (j < 0) {
                j = sizeof i.choices-1;
            }
            i.set(i.choices[j]);
        }
        else if (e.keyCode == Keys.Right) {
            j++;
            if (j >= sizeof i.choices) {
                j = 0;
            }
            i.set(i.choices[j]);
        }
        else if (e.keyCode == Keys.Home) {
            i.set(i.choices[0]);
        }
        else if (e.keyCode == Keys.End) {
            i.set(i.choices[sizeof i.choices-1]);
        }
    }

    override function onKeyInput from (e is KeyboardEvent) to () 
    {
    }
}

public class BooleanField is SliderField {
    public var i is InspectedBoolean;
    var disp is Disposable;
    override var textInputEnabled = false;
    override function setT from (t is Number) to ()
    {
	this.t = if (t > 0.5) then 1.0 else 0.0;
    }
    function onChange from (n is Boolean) to () 
    {
	//println("on change {n}");
	t = if (n) then 1.0 else 0.0;
    }
    postinit {
        const b = if i.get() == null then no else i.get();
        onChange(b);
        disp = i.observable.subscribe(onChange);
    }
    override var t on replace {
        try {
            i.set(t > 0.5);
        } catch (e is org.f3.runtime.AssignToBoundException) {
        }
    }
    override function getText from (t is Number) to String
    {
	if (t <= 0.5) then "No" else "Yes";
    }
}

public class IntegerField is SliderField {

    public var min is Integer = 0;
    public var max is Integer = 100;

    protected function onChange from (n is Integer) to () 
    {
        if (n < min) {
            min = n;
        }
        if (n > max) {
            max = n;
        }
	t = (n-min as Number) / (max-min as Number);
    }

    override function onCommit from (text is String) to () {
        try {
            onChange(Integer.parseInt(text));
        } catch (e is java.lang.Exception) {
        }
    }

    override function onCommit to () 
    {
        const n = java.lang.Math.round(min + (max - min)*t);
        onChange(n as Integer);
        MasterUndoable.commit();
    }

    override function getText from (t is Number) to String
    {
	"{Math.round(min + (max - min)*t) as Integer}"
    }
}

public class DurationField is SliderField {
    public var fps is Duration on replace {
        onChangeDur(i.get());
    }
    public var onSetKey is function from () to ();
    public var i is InspectedDuration;
    public var min is Number = 0.0;
    public var max is Number = 1.0;
    override function filterKeyInput from (k is KeyboardEvent) to Boolean
    {
        if (k.keyChar == "s") {
            onSetKey();
            return false;
        }
        if (k.keyCode == Keys.Backspace or k.keyChar == "." or k.keyChar == "-" or java.lang.Character.isDigit(k.keyChar.charAt(0))) {
           return true;
        }
        return false;
    }
    var disp is Disposable;
    function onChangeDur from (d is Duration) to () 
    {
        onChange(d / fps);
    }
    function onChange from (n is Number) to () 
    {
	t = (n-min) / (max-min);
    }
    postinit {
        const n is Duration = i.get();
        onChangeDur(n);
        disp = i.observable.subscribe(onChangeDur);
    }

    override var t on replace {
        var n = min + (max - min)*t;
        i.set(fps * n);
    }

    override function onCommit from (text is String) to () {
        var num is Number = i.get() / fps;
        try {
            num = java.lang.Float.parseFloat(text);
        } catch (e is java.lang.Exception) {
        }
        onChange(num);
        MasterUndoable.commit();
    }

    override function onCommit to () {
        const n = i.get() / fps;
        if (n < min) {
            min = n;
        }
        if (n > max) {
            max = n;
        }
        onChange(n);
        MasterUndoable.commit();
    }
    override function getText from (t is Number) to String
    {
	"{%.04f (min + (max - min)*t)}"
    }
}

class StringField is ResizableNode {
    public var editable is Boolean = true;
    public var selected is Boolean;
    public var string is InspectedString;
    public var font is Text.Font;
    const area is Text.Field = Text.Field {
        editable: bind editable;
        width: bind width;
        height: bind height;
        rightJustified: true;
        indent: 0;
        font: bind font;
        foreground: bind if (not selected) then FG_PAINT else SELECTED_FG_PAINT;
        //background: bind if (not selected) then TEXT_BG_PAINT else SELECTED_BG_PAINT;
        background: TRANSPARENT_PAINT;
    };
    const d = area.observeCommit().subscribe(function from (text is String) to () {
            try { string.set(text); MasterUndoable.commit() } catch (e is org.f3.runtime.AssignToBoundException) { } // hack  
        });
    const d1 = string.observable.subscribe(function from (s is String) to () {
            area.setText(s);
        });
    override var internalContent = bind area;
    postinit {
        area.setText(string.get());
    }
}

public class Inspector is ResizableNode, Focusable, KeyboardInputHandler, Scrollable {
    public var fps is Duration;
    const inspector = this;
    public var selectionForeground is Paint = bind if focused then
	ColorPaint(Color.color(.9, .9, .9, 1)) else ColorPaint(Color.color(.77, .77, .77, 1));
    public var popupLayer is PopupLayer;
    const colorChooser = ColorChooser { popupLayer: bind popupLayer };
    public var onSetKey is function from () to ();
    override public bound function getTx to Number { 0.0 }
    override public bound function getSx to Number { 1.0 }
    override public bound function getTy to Number 
    { 
        low / ((inspecting.size()+1) as Number);
    }
    override public bound function getSy to Number 
    { 
        if (inspecting.size() == 0) then 1.0 else Math.min(visibleRows / ((inspecting.size()) as Number), 1.0);
    }
    override public function setX from (tx is Number, sx is Number) to ()
    {
    }
    override public function setY from (ty is Number, sy is Number) to ()
    {
        low = Math.round(ty * inspecting.size()) as Integer;
    }

    public var inspecting is (Inspected of ?)[];
    public var selectedIndex is Integer on replace {
	if (selectedIndex < low) {
	    low = selectedIndex;
	} else if (low + visibleRows < selectedIndex) {
	    low = selectedIndex - Math.round(visibleRows / 2.0) as Integer;
	}
    }
    var low is Integer;
    var hi is Integer = bind low + visibleRows;
    public var cellHeight is Number = 16;
    public var fieldWidth is Number = 64;
    public var font is Text.Font = bind layoutEngine.createFont(Names.DEFAULT_FONT);
    public var border is Number = 0;
    function drag from (i is Inspected, e is MouseEvent) to ()
    {
        if (i is InspectedNumber) {
            var sx = 0.1;
            if (e.shiftKey) {
                sx *= 10.0;
            }
            if (e.ctrlKey) {
                sx *= 0.1;
            }
            const j = i as InspectedNumber;
            var n = j.get();
            n += (e.picked.dragPoint1 - e.picked.dragPoint0).x  * sx;
            j.set(n);
        }
    }

    override function onKeyDown from (e is KeyboardEvent) to ()
    {
	if (e.keyCode == Keys.Down) {
	    selectedIndex = Math.min(inspecting.size()-1, selectedIndex+1);
	} else if (e.keyCode == Keys.Up) {
	    selectedIndex = Math.max(0, selectedIndex-1);
	} else if (e.keyCode == Keys.Home) {
	    selectedIndex = 0;
	} else if (e.keyCode == Keys.End) {
	    selectedIndex = inspecting.size()-1;
	}
    }

    function scroll from (amount is Integer) to ()
    {
	low = Math.max(0, Math.min(low+amount, inspecting.size()-visibleRows));
    }

    var visibleRows = bind Math.floor(height / cellHeight) as Integer;


    var lastInspected is (Inspected of ?)[];

    override function preupdate {
	for (i in inspecting) {
	    i.index = indexof i;
	}
	super.preupdate();	

    }

    override function update to ()
    {
        if (lastInspected <> inspecting) {
            lastInspected = inspecting;
            low = 0;
        }
        super.update();
    }


    const self = this;

    override var internalContent = Group {
        var margin = 1.0;
        var indent = 1.0;
	content:
	[Rectangle {
	     width: bind width;
	     height: bind height;
	     fillPaint: DARK_BG_PAINT;
	     override function onMouseDown from (e is MouseEvent) to ()
	     {
		 selectedIndex = low+(-e.location.y + height / 2) / (border+cellHeight) as Integer;
	     }
             override function onMouseDrag from (e is MouseEvent) to ()
             {
                 drag(inspecting[selectedIndex], e)
             }
	},
	Group {
          transform: bind translate(0, height/2-cellHeight/2);
          content: bind allRows[low..hi];
	  var allRows = bind foreach (i in inspecting) Group {
	    override var transform = bind translate(0, (low-i.index) * (border+cellHeight));
            var entryLabel = Text.Label {
                    width: bind width;
		    indent: 4;	
		    text: bind Names.formatName(i.label);
		    font: bind font;
                    foreground: bind if (i.index <> selectedIndex) FG_PAINT else selectionForeground;
                    background: null;//bind if (i.index <> selectedIndex) BG_PAINT else SELECTED_BG_PAINT;
		    height: bind cellHeight;	    
                    pickable: false;
            };
	    content: 
	    [Rectangle {
		 pickable: false;
		 width: bind width;
		 height: bind cellHeight;   
		 fillPaint: bind if (i.index <> selectedIndex) BG_PAINT else SELECTED_BG_PAINT;
	    },
	    if (i is InspectedNumber) then
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-indent;
		content: NumberField {
                    editable: bind i.editable;
                    onSetKey: bind onSetKey;
		    i: bind i as InspectedNumber;
	            width: bind fieldWidth;
		    height: bind cellHeight-margin;
		}
	    } else if (i is InspectedColor) then
	    TransformNode {
                var  widget = ColorInspector {
                    editable: bind i.editable;
                    colorChooser: bind colorChooser;
                    onSetKey: bind onSetKey;
		    i: bind i as InspectedColor;
		    height: bind cellHeight-margin;
		};
                tx: bind width / 2 - widget.bounds.width() / 2-indent + 8;
                content: bind widget;
	    } else if (i is InspectedBoolean) then
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-indent;
		content: BooleanField {
                    editable: bind i.editable;
		    i: bind i as InspectedBoolean;
	            width: bind fieldWidth;
		    height: bind cellHeight-margin;
                }
            } else if (i is InspectedFontChoice of ?) then {
                    var q = i as InspectedFontChoice of Object;                                 
                    TransformNode {
                        tx: bind width / 2 - q.fieldWidth / 2-indent;
                        content: ChoiceField of Object {
                            editable: bind i.editable;
                            //override var font = bind q.deriveFont(inspector.font, t);
                            i: bind q;
                            width: bind q.fieldWidth;
                            height: bind cellHeight-margin;
                        }
                    }
            } else if (i is InspectedChoice of ?) then {
                    var q = i as InspectedChoice of Object;                                 
                    TransformNode {
                        var w = bind q.getFieldWidth(font)
                        tx: bind width / 2 - w / 2-indent;
                        content: ChoiceField of Object {
                            i: bind q;
                            width: bind w;
                            height: bind cellHeight-margin;
                        }
                    }
	    } else if (i is InspectedDuration) then
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-indent;
		content: DurationField {
                    fps: bind fps;
                    editable: bind i.editable;
		    i: bind i as InspectedDuration;
	            width: bind fieldWidth;
		    height: bind cellHeight-margin;
		}
	    } else if (i is InspectedString) then
	    TransformNode {
                var w = width-entryLabel.getLayout().getShape().getBounds().width();
                tx: bind width/2-w/2;
                //tx: 80;
                content: StringField {
                        editable: bind i.editable;
                        string: bind i as InspectedString;
                        width: bind w;
                        height: bind cellHeight-margin;
                        font: bind font;
                        selected : bind i.index == selectedIndex;
                }    
	    } else if (i is InspectedObservable) {
		null
            } else null,
	    TransformNode {
		//tx: bind -width / 2;
                content: bind entryLabel;
	    },
            Rectangle {
		 pickable: false;
		 width: bind width;
		 height: bind cellHeight;
		 //strokePaint: bind if (i.index <> selectedIndex) BG_PAINT else SELECTED_BG_PAINT;
                 fillPaint:bind if (i.index <> selectedIndex) TRANSPARENT_PAINT else SEMI_TRANSPARENT_PAINT;
	    }]
	 }
      }]
    }
    const onWheel = 
	internalContent.observeMouseWheel().subscribe(function from (event is MouseWheelEvent) to () {
		const y = event.scroll.y as Integer;
		scroll(y);
	    });
}

public function inspect from (v is Context.ClosureVarContext) to (Inspected of ?)[] {
    if (v == null) return [];
    var ptr1 = &v.variableName;
    var ptr2 = v.ref;
    [InspectedString {
            label: "variableName";
            observable: Observables.observe(ptr1);
            override function get to String {
                ptr1.get();
            }
            override function set from (x is String) to ()
            {
                ptr1.set(x);
            }
    },
    if (v.varType.t == Reflect.NUMBER_TYPE) then InspectedNumber {
            label: "value";
            observable: Observables.observe(ptr2);
            override function get to Number {
                ptr2.get();
            }
            override function set from (x is Number) to ()
            {
                ptr2.set(x)
            }
    } else null]
}

public function inspect from (obj is Object) to (Inspected of ?)[] {
    if (obj == null) then [] else foreach (x in inspect0(obj, Reflect.getType(obj.getClass()) as F3ClassType) where x <> null) x;
}

public function inspect from (obj is Object, t is F3ClassType) to (Inspected of ?)[] {
    foreach(x in inspect0(obj, t) where x <> null) x;
}

function inspect from (elem is InspectedElement) to (Inspected of ?)[] 
{
    if (not elem.visible) then null
    else if (elem is InspectionGroup) {
        const g = elem as InspectionGroup;
        foreach (x in g.targets) {
            inspect(x)
        }
    } else {
        const name = elem.displayName;
        const x = elem;
        if (x is InspectedNumberValue) {
            const v = x as InspectedNumberValue;
            InspectedNumber {
                editable: v.editable;
                low: v.min;
                hi: v.max;
                observable: Observables.observe(v.target);
                label: name;
                override function get to Number { v.target.get() }
                override function set from (n is Number) to () { if (v.editable) v.target.set(n) }
            }
        } else if (x is InspectedBooleanValue) {
            const v = x as InspectedBooleanValue;
            InspectedBoolean {
                editable: v.editable;
                observable: Observables.observe(v.target);
                label: name;
                override function get to Boolean { v.target.get() }
                override function set from (n is Boolean) to () { if (v.editable) v.target.set(n) }
            }
        } else if (x is ReadonlyInspectedNumberValue) {
            const v = x as ReadonlyInspectedNumberValue;
            InspectedNumber {
                editable: false;
                low: v.min;
                hi: v.max;
                observable: Observables.observe(v.target);
                label: name;
                override function get to Number { v.target.get() }
                override function set from (n is Number) to () {}
            }
        } else if (x is ReadonlyInspectedBooleanValue) {
            const v = x as ReadonlyInspectedBooleanValue;
            InspectedBoolean {
                editable: false;
                observable: Observables.observe(v.target);
                label: name;
                override function get to Boolean { v.target.get() }
                override function set from (n is Boolean) to () {}
            }
            /*
        } else if (x is InspectedIntegerValue) {
            const v = x as InspectedIntegerValue;
            InspectedInteger {
                observable: v.target;
                label: name;
                override function get to Integer { v.target.get() }
                override function set from (n is Integer) to () { v.target.set(n) }
                } */
            /*
        } else if (x is InspectedNumberVector) {
            const v = x as InspectedNumberVector;
            foreach (j in v.targets) {
                const vname = j.displayName;
                const v1 = j.target;
                InspectedNumber {
                    observable: Observables.observe(v1);
                    label: vname;
                    override function get to Number { v1.get() }
                    override function set from (n is Number) to () { v1.set(n) }
                }
            }
            */
        } else if (x is InspectedVector of ?) {
            const v = x as InspectedVector of ?;
            foreach (j in v.targets) {
                inspect(j)
            }
        } else if (x is InspectedValue of ?) {        
            const j = x as InspectedValue of Object;
            const value = j.target.get();
            const ptr = j.target;
            if (value is java.lang.Enum of ?) {
                InspectedEnum of Object {
                    editable: j.editable;
                    label: j.displayName;
                    observable: Observables.observe(ptr) as Observable of Object;
                    clazz: value.getClass() as java.lang.Class of Object;
                    override function get to Object { ptr.get() }
                    override function set from (x is Object) to () { if (j.editable) ptr.set(x) }
                }
            } else null
        } else null
    }
}

function inspect0 from (obj is Object, classType is F3ClassType) to (Inspected of ?)[]
{
    println("INSPECTING => {obj} class={classType}");
    const hidden = new java.util.HashSet of String;
    if (obj is Inspectable) {
        const j = obj as Inspectable;
        for (n in j.$hideMembers) hidden.add(n);
    }
    if (obj == null) then [] else {
	    const members = Expression.introspect(classType);
	    foreach (m in members where not m.name.contains("$") and not hidden.contains(m.name)) {
                var result is (Inspected of ?)[];
                try {
                    result = 
                        if (true or m.isObservable)  {
                            if (m.m is F3VarMember and INSPECTED_ELEMENT_TYPE.isAssignableFrom(m.t)) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of InspectedElement;
                                const elem = ptr.get();
                                inspect(elem)
                            } else if (m.m is F3VarMember and m.t == NUMBER_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Number;
                                InspectedNumber {
                                    member: m;
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to Number { 
                                        println("getting value of {m.m.getName()} in {obj}");
                                        ptr.get() 
                                    }
                                    override function set from (x is Number) to () { 
                                        if (m.isObservable) ptr.set(x);
                                        //println("set {m.m.getName()} => {x} => {ptr.get()}");
                                    }
                                }
                            } else if (m.m is F3VarMember and m.t == COLOR_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Color;
                                InspectedColor {
                                    member: m;
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to Color { ptr.get() }
                                    override function set from (x is Color) to () { if (m.isObservable) ptr.set(x) }
                                }
                            } else if (m.m is F3VarMember and ENUM_TYPE.isAssignableFrom(m.t)) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Object;
                                    InspectedEnum of Object {
                                        member: m;
                                        label: m.m.getName();
                                        observable: Observables.observe(ptr) as Observable of Object;
                                        clazz: java.lang.Class.forName(m.t.getName()) as java.lang.Class of Object;
                                        override function get to Object { ptr.get() }
                                        override function set from (x is Object) to () { if (m.isObservable) ptr.set(x) }
                                    }
                            } else if (m.m is F3VarMember and m.t == BOOLEAN_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Boolean;
                                InspectedBoolean {
                                    member: m;
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to Boolean { ptr.get() }
                                    override function set from (x is Boolean) to () { if (m.isObservable) ptr.set(x) }
                                }
                            } else if (m.m is F3VarMember and m.t == FONT_STYLE_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of FontStyleSelection;
                                inspectedFontStyle(ptr, m, m.m.getName(), ["normal", "italic"]);
                            } else if (m.m is F3VarMember and m.t == FONT_WEIGHT_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of FontWeightSelection;
                                inspectedFontWeight(ptr, m, m.m.getName(), ["normal", "bold"]);
                            } else if (m.m is F3VarMember and m.t == FONT_FAMILY_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of FontFamilySelection;
                                inspectedFontFamily(ptr, m, m.m.getName(), allFontFamilies);
                            } else if (m.m is F3VarMember and m.t == FONT_SIZE_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of FontSizeSelection;
                                inspectedFontSize(ptr, m, m.m.getName(), [8..128]);
                            } else if (m.m is F3VarMember and m.t == FONT_TEXT_DECORATION_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of FontTextDecorationSelection;
                                inspectedFontTextDecoration(ptr, m, m.m.getName());
                            } else if (m.m is F3VarMember and m.t == DURATION_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Duration;
                                InspectedDuration {
                                    member: m;
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to Duration { ptr.get() }
                                    override function set from (x is Duration) to () { if (m.isObservable) ptr.set(x) }
                                }
                            } else if (m.m is F3VarMember and m.t == CAMERA_SELECTION_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of CameraSelection;
                                const ptr1 = &ptr.get().camera;
                                inspectedCamera(ptr1, m, m.m.getName(), ptr.get().cameras);
                            } else if (m.m is F3VarMember and m.t == STRING_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of String;
                                InspectedString {
                                    member: m;
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to String { var s = ptr.get(); println("{label} => get={s}"); s }
                                    override function set from (x is String) to () { if (m.isObservable) ptr.set(x) }
                                }
                            } else {
                                /*
                                  InspectedObservable of Object {
                                  member: m;
                                  label: m.m.getName();
                                  }
                                */
                                null
                            }
                        } else null;

                    //result.get();
                } catch (e is java.lang.Exception) {
                    e.printStackTrace();
                    result = null;
                }
                result;
	    }
	}
}