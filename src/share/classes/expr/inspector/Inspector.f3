package expr.inspector;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import expr.choices.*;
import f3.lang.*;
import f3.util.*;
import f3.util.Observables;
import expr.*;
import f3.math.*;
import f3.math.LinearMath.*;

public abstract class Inspected of a 
{
    public var pointer is ObservableRef of a;
    public var label is String;
    public function getAsString from (t is Number) to String
    {
	"{get(t)}";
    }
    public function get from (t is Number) to a;
    public function set from (t is Number) to () 
    { 
	pointer.set(get(t)); 
    }
    public var observable = bind Observables.observe(pointer);
    protected var index is Integer;
}

public class InspectedNumber is Inspected of Number 
{
    public const low is Number;
    public const hi is Number;
    override function get from (t is Number) to Number 
    { 
	if (hi > low) then low + (hi - low)*t else t;
    }
}

public class InspectedChoice of a is Inspected of a 
{
    public const choices is (..a)[];
    public const labels is String[] = foreach (choice in choices) "{choice}";

    function getIndex from (t is Number) to Integer 
    {
	(t * choices.size()) as Integer
    }

    override function getAsString from (t is Number) to String
    {
	labels[getIndex(t)];
    }

    override function get from (t is Number) to a
    { 
	choices[getIndex(t)];
    }
}

public class InspectedBoolean is Inspected of Boolean
{
    override public function getAsString from (t is Number) to String
    {
	if (get(t)) then "Yes" else "No"
    }

    override public function get from (t is Number) to Boolean
    {
	t == 0.0
    }
}

public class InspectedString is Inspected of String
{
    override public function getAsString from (t is Number) to String
    {
        pointer.get();
    }

    override public function get from (t is Number) to String
    {
        pointer.get();
    }
}

const FG = Color.color(.2, .2, .2);
const FG_PAINT = ColorPaint(FG);
const BG = Color.color(.8, .8, .8);
const BG_PAINT = ColorPaint(BG);
const DARK_BG = Color.color(.5, .5, .5);
const DARK_BG_PAINT = ColorPaint(DARK_BG);

class NumberField is SliderField {
    public var i is InspectedNumber;
    var disp is Disposable;
    function onChange from (n is Number) to () 
    {
	println("on change {n}");
	t = n;
    }
    postinit {
	t = i.pointer.get();
	println("I.observable = {i.observable}");
	disp = i.observable.subscribe(onChange);
    }
    override var t on replace {
	println("t={t}");
    }
    override function getText from (t is Number) to String
    {
	"{%.04f t}"
    }
}

public class Inspector is ResizableNode {
    public var inspecting is (Inspected of ?)[];
    public var cellHeight is Number = 15;
    public var fieldWidth is Number = 64;
    public var font is Text.Font = bind layoutEngine.createFont("font-size:12;font-style:LucidaSans");
    public var border is Number = 1;
    override function update {
	super.update();
	for (i in inspecting) {
	    i.index = indexof i;
	}
    }
    override var internalContent = Group {
	content:
	[Rectangle {
	     width: bind width;
	     height: bind height;
	     fillPaint: DARK_BG_PAINT;
	},
	Group {
          transform: bind translate(0, height/2-cellHeight/2);
	  content: bind foreach (i in inspecting) Group {
	    override var transform = bind translate(0, -i.index * (border+cellHeight));
	    content: [TransformNode {
		//tx: bind -width / 2;
		content: Text.Label {
		    width: bind width;
		    indent: 4;	
		    text: bind i.label;
		    font: bind font;
		    foreground: FG_PAINT;
		    background: BG_PAINT;
		    height: bind cellHeight;	    
		}
	    }
	    if not (i is InspectedNumber) then null else
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-4;
		content: NumberField {
		    i: bind i as InspectedNumber;
	            width: bind fieldWidth;
		    height: bind cellHeight;
		}
	    }]
	 }
      }]
    }
}