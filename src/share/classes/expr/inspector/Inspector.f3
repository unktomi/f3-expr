package expr.inspector;
import f3.media.input.*;
import f3.media.scene.*;
import f3.media.scene.Text.LayoutEngine;
import f3.media.scene.Shape2D.*;
import expr.choices.*;
import f3.lang.*;
import f3.util.*;
import f3.util.Observables;
import expr.*;
import expr.Reflect.*;
import f3.reflect.*;
import org.f3.runtime.*;
import expr.prog.Expression;
import expr.prog.Expression.*;
import f3.math.*;
import f3.math.LinearMath.*;
import java.lang.Math;
import expr.undo.*;
import expr.AbstractResourceText.*;

function clamp from (n is Number, lo is Number, hi is Number) to Number
{
    Math.min(Math.max(n, lo), hi);
}

public class NumericSliderField is SliderField {

    public var onSetKey is function from () to ();

    public var min is Number = 0.0;
    public var max is Number = 1.0;

    protected function onChange from (n0 is Number) to () 
    {
        var n = n0;
        if (n < min) {
            n = min;
        }
        if (n > max) {
            n = max;
        }
	setT((n-min) / (max-min));
    }

    override function onCommit from (text is String) to () {
        try {
            onChange(java.lang.Float.parseFloat(text));
        } catch (e is java.lang.Exception) {
        }
    }

    override function onCommit to () 
    {
        onChange(min + (max - min)*t);
        MasterUndoable.commit();
    }

    override function getText from (t is Number) to String
    {
	"{%.02f (min + (max - min)*t)}"
    }

    override function filterKeyInput from (k is KeyboardEvent) to Boolean
    {
        if (k.keyChar == "s") {
            onSetKey();
            return false;
        }
        if (k.keyChar == "-" or java.lang.Character.isDigit(k.keyChar.charAt(0))) {
           return true;
        }
        return false;
    }
}


public class ColorInspector extends AbstractNode {
    public var i is InspectedColor;
    public var height is Number = 15;
    var fieldWidth = 30;
    public var r is Number;
    public var g is Number;
    public var b is Number;
    public var a is Number;
    var firstTime is Boolean = true;
    public readonly var selection is Color = bind Color.color(r, g, b, a);
    override function update to () {
        if (firstTime) {
            firstTime = false;
            const c = i.get();
            red.setT(c.red);
            green.setT(c.green);
            blue.setT(c.blue);
            alpha.setT(c.opacity);
        } else {
            i.set(selection);
        }
        super.update();
    }
    var disp is Disposable;

    public var onSetKey is function from () to ();

    function onChange from (c is Color) to ()
    {
        if (c <> selection) {
            firstTime = true;
        }
    }

    postinit {
        disp = i.observable.subscribe(onChange);
    }
    const colorSelection = Rectangle {
        height: bind height;
        width: bind height;
        fillPaint: bind ColorPaint(selection);
        strokePaint: bind ColorPaint(Color.color(.2, .2, .2));
    };
    const red = NumericSliderField {
        onSetKey: bind onSetKey;
        min: 0.0;
        max: 1.0;
        height: bind height;
        width: bind fieldWidth;
        override function setT from (t is Number) to ()
        {
            r = clamp(t, min, max);
            super.setT(r);
        }
    }
    const green = NumericSliderField {
        onSetKey: bind onSetKey;
        min: 0.0;
        max: 1.0;
        height: bind height;
        width: bind fieldWidth;
        override function setT from (t is Number) to ()
        {
            g = clamp(t, min, max);
            super.setT(g);
        }
    }
    const blue = NumericSliderField {
        onSetKey: bind onSetKey;
        min: 0.0;
        max: 1.0;
        height: bind height;
        width: bind fieldWidth;
        override function setT from (t is Number) to ()
        {
            b = clamp(t, min, max);
            super.setT(b);
        }
    }
    const alpha = NumericSliderField {
        onSetKey: bind onSetKey;
        min: 0.0;
        max: 1.0;
        height: bind height;
        width: bind fieldWidth;
        override function setT from (t is Number) to ()
        {
            a = clamp(t, min, max);
            super.setT(a);
        }
    };
    var t1 is TransformNode;
    var t2 is TransformNode;
    var t3 is TransformNode;
    var t4 is TransformNode;

    const margin = 5;

    const contentGroup = Group {
        content:
        [t1=TransformNode {
            content: bind colorSelection;
        },
        t2=TransformNode {
            tx: bind t1.bounds.right() + margin + fieldWidth/2;
            content: bind red;
        },
        t3=TransformNode {
            tx: bind t2.bounds.right() + margin + fieldWidth/2;
            content: bind green;
        },
        t4=TransformNode {
            tx: bind t3.bounds.right() + margin + fieldWidth/2;
            content: bind blue;
        },
        TransformNode {
            tx: bind t4.bounds.right() + margin + fieldWidth/2;
            content: bind alpha;
        }]
    };
    override var internalContent = TransformNode {
        tx: bind -contentGroup.bounds.width()/2;
        content: bind contentGroup;
    }
}

public var allFontFamilies is String[];

function inspectedFontFamily from (ptr is ObservableRef of FontFamilySelection,
                                   member is Member,
                                   label is String,
                                   families is String[]) to InspectedChoice of FontFamilySelection
{
    InspectedChoice of FontFamilySelection {
        fieldWidth: 512;
        label: label;
        member: member;
        choices: foreach (x in families) new FontFamilySelection(x);
        observable: Observables.observe(ptr);
        override function get to FontFamilySelection { 
            ptr.get() ;
        }
        override function set from (x is FontFamilySelection) to () { 
            ptr.set(x);
        }
    }
}

function inspectedFontWeight from (ptr is ObservableRef of FontWeightSelection,
                                   member is Member,
                                   label is String,
                                   weights is String[]) to InspectedChoice of FontWeightSelection
{
    InspectedChoice of FontWeightSelection {
        label: label;
        member: member;
        choices: foreach (x in weights) new FontWeightSelection(x);
        observable: Observables.observe(ptr);
        override function get to FontWeightSelection { 
            ptr.get() ;
        }
        override function set from (x is FontWeightSelection) to () { 
            ptr.set(x);
        }
    }
}

function inspectedFontStyle from (ptr is ObservableRef of FontStyleSelection,
                                   member is Member,
                                   label is String,
                                   styles is String[]) to InspectedChoice of FontStyleSelection
{
    InspectedChoice of FontStyleSelection {
        label: label;
        member: member;
        choices: foreach (x in styles) new FontStyleSelection(x);
        observable: Observables.observe(ptr);
        override function get to FontStyleSelection { 
            ptr.get() ;
        }
        override function set from (x is FontStyleSelection) to () { 
            ptr.set(x);
        }
    }
}


function inspectedFontSize from (ptr is ObservableRef of FontSizeSelection,
                                 member is Member,
                                 label is String,
                                 sizes is Integer[]) to InspectedChoice of FontSizeSelection
{
    InspectedChoice of FontSizeSelection {
        label: label;
        member: member;
        choices: foreach (x in sizes) new FontSizeSelection(x);
        observable: Observables.observe(ptr);
        override function get to FontSizeSelection { 
            ptr.get() ;
        }
        override function set from (x is FontSizeSelection) to () { 
            ptr.set(x);
        }
    }
}

public abstract class Inspected of a 
{
    public var member is Member;
    public var label is String;
    public var observable is Observable of a;
    protected var index is Integer;
    public function get to a { null } 
    public function set from (x is a) to () {}
}

public class InspectedRange of a is Inspected of a {
    public function getAsString from (t is Number) to String
    {
	"{getFromT(t)}";
    }
    public function getFromT from (t is Number) to a { null }
    public function setFromT from (t is Number) to () 
    { 
	set(getFromT(t)); 
    }
}

public class InspectedColor is Inspected of Color {
}

public class InspectedNumber is InspectedRange of Number 
{
    public const low is Number;
    public const hi is Number;
    override function getFromT from (t is Number) to Number 
    { 
	if (hi > low) then low + (hi - low)*t else t;
    }
}

public class InspectedDuration is InspectedRange of Duration 
{
    public const low is Duration;
    public const hi is Duration;
    override function getFromT from (t is Number) to Duration
    { 
	if (hi > low) then low + (hi - low)*t else 1ms*t;
    }
}

public class InspectedChoice of a is InspectedRange of a 
{
    public const fieldWidth is Number = 64;
    public const choices is (..a)[];
    public const labels is String[] = foreach (choice in choices) "{choice}";

    function getIndex from (t is Number) to Integer 
    {
	const i = (Math.round(t * choices.size()) as Integer);
        return Math.min(Math.max(i, 0), choices.size()-1);
    }

    override function getAsString from (t is Number) to String
    {
	labels[getIndex(t)];
    }

    override function getFromT from (t is Number) to a
    { 
	choices[getIndex(t)];
    }

    public function getT to Number
    {
        const v = get();
        for (x in choices) {
            if (x == v) {
                const t = indexof x / (choices.size() as Number);
                return t;
            }
        }
        println("no match: {v.getClass()}, {v} on {foreach (x in choices) "{x.getClass()}, {x}"}");
        return 0;
    }
}

public class InspectedBoolean is InspectedRange of Boolean
{
    override public function getAsString from (t is Number) to String
    {
	if (getFromT(t)) then "Yes" else "No"
    }

    override public function getFromT from (t is Number) to Boolean
    {
	t == 0.0
    }
}

public class InspectedString is Inspected of String
{
}

public class InspectedObservable of a is Inspected of Observable of a
{
}


const FG = Color.color(.2, .2, .2, 1);
const FG_PAINT = ColorPaint(FG);
const SELECTED_FG = Color.color(.9, .9, .9, 1);
const SELECTED_FG_PAINT = ColorPaint(SELECTED_FG);
const BG = Color.color(.6, .6, .6);
const BG_PAINT = ColorPaint(BG);
const SELECTED_BG = Color.color(.4, .4, .4);
const SELECTED_BG_PAINT = ColorPaint(SELECTED_BG);
const DARK_BG = Color.color(.5, .5, .5);
const DARK_BG_PAINT = ColorPaint(DARK_BG);
const TRANSPARENT_PAINT = ColorPaint(Color.TRANSPARENT);
const SEMI_TRANSPARENT_PAINT = ColorPaint(Color.color(1, 1, 1, 0.1));

const TEXT_BG_PAINT = ColorPaint(Color.color(.82, .82, .82));

public class NumberField is SliderField {
    public var onSetKey is function from () to ();
    public var i is InspectedNumber;
    public var min is Number = 0.0;
    public var max is Number = 1.0;
    override function filterKeyInput from (k is KeyboardEvent) to Boolean
    {
        if (k.keyChar == "s") {
            onSetKey();
            return false;
        }
        if (k.keyCode == Keys.Backspace or k.keyChar == "-" or java.lang.Character.isDigit(k.keyChar.charAt(0))) {
           return true;
        }
        return false;
    }
    var disp is Disposable;
    function onChange from (n is Number) to () 
    {
	t = (n-min) / (max-min);
    }
    postinit {
        onChange(i.get());
        disp = i.observable.subscribe(onChange);
    }
    override var t on replace {
        var n = min + (max - min)*t;
        i.set(n);
    }

    override function onCommit from (text is String) to () {
        var num is Number = i.get();
        try {
            num = java.lang.Float.parseFloat(text);
        } catch (e is java.lang.Exception) {
        }
        onChange(num);
        MasterUndoable.commit();
    }

    override function onCommit to () {
        const n = i.get();
        if (n < min) {
            min = n;
        }
        if (n > max) {
            max = n;
        }
        onChange(n);
        MasterUndoable.commit();
    }
    override function getText from (t is Number) to String
    {
	"{%.04f (min + (max - min)*t)}"
    }
}

public class ChoiceField of a is SliderField, KeyboardInputHandler {
    public var i is InspectedChoice of a;
    override var textInputEnabled = false;
    var disp is Disposable;
    var invalid = true;
    var lastT is Number;
    function onChange from (n is a) to () 
    {
        t = i.getT();
    }

    postinit {
        onChange(i.get());
        disp = i.observable.subscribe(onChange);
    }

    override function setT from (t is Number) to () 
    {
        i.setFromT(t);
    }

    override function onCommit to ()
    {
        MasterUndoable.commit();
    }

    override function getText from (t is Number) to String
    {
        const j is Integer = i.getIndex(t);
	if (j >= 0 and j < i.labels.size()) i.labels[j] else "";
    }

    override function onKeyDown from (e is KeyboardEvent) to () 
    {
        var j is Integer = i.getIndex(t);
        if (e.keyCode == Keys.Left) {
            j--;
            if (j < 0) {
                j = sizeof i.choices-1;
            }
            i.set(i.choices[j]);
        }
        else if (e.keyCode == Keys.Right) {
            j++;
            if (j >= sizeof i.choices) {
                j = 0;
            }
            i.set(i.choices[j]);
        }
        else if (e.keyCode == Keys.Home) {
            i.set(i.choices[0]);
        }
        else if (e.keyCode == Keys.End) {
            i.set(i.choices[sizeof i.choices-1]);
        }
    }

    override function onKeyInput from (e is KeyboardEvent) to () 
    {
    }
}

public class BooleanField is SliderField {
    public var i is InspectedBoolean;
    var disp is Disposable;
    override var textInputEnabled = false;
    override function setT from (t is Number) to ()
    {
	this.t = if (t > 0.5) then 1.0 else 0.5;
    }
    function onChange from (n is Boolean) to () 
    {
	println("on change {n}");
	t = if (n) then 1.0 else 0.5;
    }
    postinit {
        onChange(i.get());
        disp = i.observable.subscribe(onChange);
    }
    override var t on replace {
        try {
            i.set(t > 0.5);
        } catch (e is org.f3.runtime.AssignToBoundException) {
        }
    }
    override function getText from (t is Number) to String
    {
	if (t <= 0.5) then "No" else "Yes";
    }
}

public class DurationField is SliderField {
    public var i is InspectedDuration;
    var disp is Disposable;
    function onChange from (n is Duration) to () 
    {
	println("on change {n}");
	t = n.toMillis() / 1000.0;
    }
    postinit {
        onChange(i.get());
        disp = i.observable.subscribe(onChange);
    }
    override var t on replace {
	println("t={t}");
        i.set(Duration.valueOf(t * 1000.0));
    }
    override function getText from (t is Number) to String
    {
	"{%.04f t}s"
    }
    override function onCommit from () to () 
    {
        MasterUndoable.commit();
    }
    override function onCommit from (text is String) to () {
        //onChange(Duration.valueOf(text));
        MasterUndoable.commit();
    }
}

class StringField is ResizableNode {
    public var selected is Boolean;
    public var string is InspectedString;
    public var font is Text.Font;
    const area is Text.Field = Text.Field {
        width: bind width;
        height: bind height;
        rightJustified: true;
        font: bind font;
        foreground: bind if (not selected) then FG_PAINT else SELECTED_FG_PAINT;
        //background: bind if (not selected) then TEXT_BG_PAINT else SELECTED_BG_PAINT;
        background: TRANSPARENT_PAINT;
    };
    const d = area.observeCommit().subscribe(function from (text is String) to () {
            try { string.set(text) } catch (e is org.f3.runtime.AssignToBoundException) { } // hack  
        });
    override var internalContent = bind area;
    postinit {
        area.setText(string.get());
    }
}

public class Inspector is ResizableNode, Focusable, KeyboardInputHandler, Scrollable {
    public var onSetKey is function from () to ();
    override public bound function getTx to Number { 0.0 }
    override public bound function getSx to Number { 1.0 }
    override public bound function getTy to Number 
    { 
        low / ((inspecting.size()+1) as Number);
    }
    override public bound function getSy to Number 
    { 
        if (inspecting.size() == 0) then 1.0 else Math.min(visibleRows / ((inspecting.size()) as Number), 1.0);
    }
    override public function setX from (tx is Number, sx is Number) to ()
    {
    }
    override public function setY from (ty is Number, sy is Number) to ()
    {
        low = Math.round(ty * inspecting.size()) as Integer;
    }

    public var inspecting is (Inspected of ?)[];
    public var selectedIndex is Integer on replace {
	if (selectedIndex < low) {
	    low = selectedIndex;
	} else if (low + visibleRows < selectedIndex) {
	    low = selectedIndex - Math.round(visibleRows / 2.0) as Integer;
	}
    }
    var low is Integer;
    var hi is Integer = bind low + visibleRows;
    public var cellHeight is Number = 16;
    public var fieldWidth is Number = 64;
    public var font is Text.Font = bind layoutEngine.createFont(Names.DEFAULT_FONT);
    public var border is Number = 0;
    function drag from (i is Inspected, e is MouseEvent) to ()
    {
        if (i is InspectedNumber) {
            var sx = 0.1;
            if (e.shiftKey) {
                sx *= 10.0;
            }
            if (e.ctrlKey) {
                sx *= 0.1;
            }
            const j = i as InspectedNumber;
            var n = j.get();
            n += (e.picked.dragPoint1 - e.picked.dragPoint0).x  * sx;
            j.set(n);
        }
    }

    override function onKeyDown from (e is KeyboardEvent) to ()
    {
	if (e.keyCode == Keys.Down) {
	    selectedIndex = Math.min(inspecting.size()-1, selectedIndex+1);
	} else if (e.keyCode == Keys.Up) {
	    selectedIndex = Math.max(0, selectedIndex-1);
	} else if (e.keyCode == Keys.Home) {
	    selectedIndex = 0;
	} else if (e.keyCode == Keys.End) {
	    selectedIndex = inspecting.size()-1;
	}
    }

    function scroll from (amount is Integer) to ()
    {
	low = Math.max(0, Math.min(low+amount, inspecting.size()-visibleRows));
    }

    var visibleRows = bind Math.floor(height / cellHeight) as Integer;
    var scrollOffset is Integer;

    override function preupdate {
	for (i in inspecting) {
	    i.index = indexof i;
	}
	super.preupdate();	

    }
    const self = this;

    override var internalContent = Group {
        var margin = 1.0;
        var indent = 1.0;
	content:
	[Rectangle {
	     width: bind width;
	     height: bind height;
	     fillPaint: DARK_BG_PAINT;
	     override function onMouseDown from (e is MouseEvent) to ()
	     {
		 selectedIndex = low+(-e.location.y + height / 2) / (border+cellHeight) as Integer;
	     }
             override function onMouseDrag from (e is MouseEvent) to ()
             {
                 drag(inspecting[selectedIndex], e)
             }
	},
	Group {
          transform: bind translate(0, height/2-cellHeight/2);
          content: bind allRows[low..hi];
	  var allRows = bind foreach (i in inspecting) Group {
	    override var transform = bind translate(0, (low-i.index) * (border+cellHeight));
            var entryLabel = Text.Label {
                    width: bind width;
		    indent: 4;	
		    text: bind Names.formatName(i.label);
		    font: bind font;
		    foreground: bind if (i.index <> selectedIndex) FG_PAINT else SELECTED_FG_PAINT;
                    background: null;//bind if (i.index <> selectedIndex) BG_PAINT else SELECTED_BG_PAINT;
		    height: bind cellHeight;	    
                    pickable: false;
            };
	    content: 
	    [Rectangle {
		 pickable: false;
		 width: bind width;
		 height: bind cellHeight;   
		 fillPaint: bind if (i.index <> selectedIndex) BG_PAINT else SELECTED_BG_PAINT;
	    },
	    if (i is InspectedNumber) then
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-indent;
		content: NumberField {
                    onSetKey: bind onSetKey;
		    i: bind i as InspectedNumber;
	            width: bind fieldWidth;
		    height: bind cellHeight-margin;
		}
	    } else if (i is InspectedColor) then
	    TransformNode {
                var  widget = ColorInspector {
                    onSetKey: bind onSetKey;
		    i: bind i as InspectedColor;
		    height: bind cellHeight-margin;
		};
                tx: bind width / 2 - widget.bounds.width() / 2-indent + 8;
                content: bind widget;
	    } else if (i is InspectedBoolean) then
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-indent;
		content: BooleanField {
		    i: bind i as InspectedBoolean;
	            width: bind fieldWidth;
		    height: bind cellHeight-margin;
		}
                } else if (i is InspectedChoice of ?) then {
                    var q = i as InspectedChoice of Object;                                 
                    TransformNode {
                        tx: bind width / 2 - q.fieldWidth / 2-indent;
                        content: ChoiceField of Object {
                            i: bind q;
                            width: bind q.fieldWidth;
                            height: bind cellHeight-margin;
                        }
                    }
	    } else if (i is InspectedDuration) then
	    TransformNode {
		tx: bind width / 2 - fieldWidth / 2-indent;
		content: DurationField {
		    i: bind i as InspectedDuration;
	            width: bind fieldWidth;
		    height: bind cellHeight-margin;
		}
	    } else if (i is InspectedString) then
	    TransformNode {
                var w = width-entryLabel.getLayout().getShape().getBounds().width();
                tx: bind width/2-w/2-indent;
                //tx: 80;
                content: StringField {
                        string: bind i as InspectedString;
                        width: bind w;
                        height: bind cellHeight-margin;
                        font: bind font;
                        selected : bind i.index == selectedIndex;
                }    
	    } else if (i is InspectedObservable) {
		null
            } else null,
	    TransformNode {
		//tx: bind -width / 2;
                content: bind entryLabel;
	    },
            Rectangle {
		 pickable: false;
		 width: bind width;
		 height: bind cellHeight;
		 //strokePaint: bind if (i.index <> selectedIndex) BG_PAINT else SELECTED_BG_PAINT;
                 fillPaint:bind if (i.index <> selectedIndex) TRANSPARENT_PAINT else SEMI_TRANSPARENT_PAINT;
	    }]
	 }
      }]
    }
    const onWheel = 
	internalContent.observeMouseWheel().subscribe(function from (event is MouseWheelEvent) to () {
		const y = event.scroll.y as Integer;
		scroll(y);
	    });
}

public function inspect from (v is Context.ClosureVarContext) to (Inspected of ?)[] {
    if (v == null) return [];
    var ptr1 = &v.variableName;
    var ptr2 = v.ref;
    [InspectedString {
            label: "variableName";
            observable: Observables.observe(ptr1);
            override function get to String {
                ptr1.get();
            }
            override function set from (x is String) to ()
            {
                ptr1.set(x);
            }
    },
    if (v.varType.t == Reflect.NUMBER_TYPE) then InspectedNumber {
            label: "value";
            observable: Observables.observe(ptr2);
            override function get to Number {
                ptr2.get();
            }
            override function set from (x is Number) to ()
            {
                ptr2.set(x)
            }
    } else null]
}

public function inspect from (obj is Object) to (Inspected of ?)[] {
    if (obj == null) then [] else foreach (x in inspect0(obj, Reflect.getType(obj.getClass()) as F3ClassType) where x <> null) x;
}

public function inspect from (obj is Object, t is F3ClassType) to (Inspected of ?)[] {
    foreach(x in inspect0(obj, t) where x <> null) x;
}

function inspect0 from (obj is Object, classType is F3ClassType) to (Inspected of ?)[]
{
    println("INSPECTING => {obj}");
    if (obj == null) then [] else {
	    const members = Expression.introspect(classType);
	    foreach (m in members where not m.name.contains("$")) {
		println("m={m} {m.m} t={m.t}");
                var result is Inspected of ?;
                try {
                    result = 
                        if (m.isObservable)  {
                            if (m.m is F3VarMember and m.t == NUMBER_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Number;
                                InspectedNumber {
                                    member: m;
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to Number { 
                                        println("getting value of {m.m.getName()} in {obj}");
                                        ptr.get() 
                                    }
                                    override function set from (x is Number) to () { 
                                        ptr.set(x);
                                        println("set {m.m.getName()} => {x} => {ptr.get()}");
                                    }
                                }
                            } else if (m.m is F3VarMember and m.t == COLOR_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Color;
                                InspectedColor {
                                    member: m;
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to Color { ptr.get() }
                                    override function set from (x is Color) to () { ptr.set(x) }
                                }
                            } else if (m.m is F3VarMember and m.t == BOOLEAN_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Boolean;
                                InspectedBoolean {
                                    member: m;
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to Boolean { ptr.get() }
                                    override function set from (x is Boolean) to () { ptr.set(x) }
                                }
                            } else if (m.m is F3VarMember and m.t == FONT_STYLE_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of FontStyleSelection;
                                inspectedFontStyle(ptr, m, m.m.getName(), ["normal", "italic"]);
                            } else if (m.m is F3VarMember and m.t == FONT_WEIGHT_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of FontWeightSelection;
                                inspectedFontWeight(ptr, m, m.m.getName(), ["normal", "bold"]);
                            } else if (m.m is F3VarMember and m.t == FONT_FAMILY_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of FontFamilySelection;
                                inspectedFontFamily(ptr, m, m.m.getName(), allFontFamilies);
                            } else if (m.m is F3VarMember and m.t == FONT_SIZE_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of FontSizeSelection;
                                inspectedFontSize(ptr, m, m.m.getName(), [8..128]);
                            } else if (m.m is F3VarMember and m.t == DURATION_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of Duration;
                                InspectedDuration {
                                    member: m;
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to Duration { ptr.get() }
                                    override function set from (x is Duration) to () { ptr.set(x) }
                                }
                            } else if (m.m is F3VarMember and m.t == STRING_TYPE) {
                                const ptr = (m.m as F3Local.VarMember).getPointer(obj as F3Object) as ObservableRef of String;
                                InspectedString {
                                    label: m.m.getName();
                                    observable: Observables.observe(ptr);
                                    override function get to String { var s = ptr.get(); println("{label} => get={s}"); s }
                                    override function set from (x is String) to () { ptr.set(x) }
                                }
                            } else {
                                /*
                                  InspectedObservable of Object {
                                  member: m;
                                  label: m.m.getName();
                                  }
                                */
                                null
                            }
                        } else null;
                    result.get();
                } catch (e is java.lang.Exception) {
                    e.printStackTrace();
                    result = null;
                }
                result;
	    }
	}
}