package expr.timeline;
import expr.*;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import f3.media.input.*;
import f3.util.*;
import f3.util.Observer.*;
import f3.math.*;
import f3.math.LinearMath.*;
import java.lang.Math;
import expr.undo.*;

public const CLIP_COLOR = Color.rgb(50, 50, 50);
public const CLIP_SELECTED_COLOR = Color.rgb(77, 77, 77);
public const CLIP_LABEL_COLOR = Color.rgb(180, 180, 180);
public const CLIP_SELECTED_LABEL_COLOR = Color.rgb(230, 230, 230);

public const CHANNEL_COLOR = Color.rgb(140, 140, 140);
public const CHANNEL_LABEL_COLOR = Color.rgb(51, 51, 51);
public const CHANNEL_SELECTED_COLOR = Color.rgb(166, 166, 166);
public const CHANNEL_SELECTED_LABEL_COLOR = Color.rgb(26, 26, 26);

public const MODEL_COLOR = Color.rgb(80, 50, 50);
public const MODEL_SELECTED_COLOR = Color.rgb(130, 50, 50);

public const SOUND_COLOR = Color.rgb(50, 80, 50);
public const SOUND_SELECTED_COLOR = Color.rgb(50, 130, 50);

public const MOVIE_COLOR = Color.rgb(50, 50, 80);
public const MOVIE_SELECTED_COLOR = Color.rgb(50, 50, 130);


public const CLIP_PAINT = ColorPaint(CLIP_COLOR);
public const CLIP_SELECTED_PAINT = ColorPaint(CLIP_SELECTED_COLOR);

public const CLIP_LABEL_PAINT = ColorPaint(CLIP_LABEL_COLOR);
public const CLIP_SELECTED_LABEL_PAINT = ColorPaint(CLIP_SELECTED_LABEL_COLOR);


class TimeNodeView is AbstractNode 
{
    public var row is Integer;
    public var trax is Trax;
    public var target is TimeNode;
    public var playX is Number = bind getPlayX(target.playTime);
    public var content is Node[] = bind getContent(target);
    public var expanded = false;

    public var selected is Boolean;

    function getPlayX from (d is Duration) to Number {
	trax.durationToX(d);
    }

    function getWidth from (i0 is Interval, visible is Interval) to Number 
    {
	trax.durationToX(i0.duration())
    }

    var selected1 = bind selected and trax.focused;

    bound function getFill from (target is TimeNode) to Paint 
    {
	if (selected) then CLIP_SELECTED_PAINT else CLIP_PAINT;
    }

    bound function getContent from (target is TimeNode) to Node[]
    {
	[]
    }
    const self = this;
    var w = bind getWidth(target.bounds, trax.visibleInterval);
    var h = bind trax.getViewHeight();
    var fg = bind if (selected1) then CLIP_SELECTED_LABEL_PAINT else CLIP_LABEL_PAINT;//ColorPaint(Color.color(.7, .7, .7, 1));
    var bg = bind getFill(target);
    override var transform = bind translate(playX + w / 2.0, trax.height / 2 + 2 - 15 -(row+1)*trax.getViewHeight());
    override var internalContent = Group {
	content:
	Group {
            var dx is Number;
	    content: bind
	    [
             Group is MouseInputHandler {
		 visible: bind w > 0;
		     override function onMouseDown from (event is MouseEvent) to ()
		     {
			 dx = trax.durationToX(target.playTime);
			 trax.selectTimeNodeView(self)
		     }
		     override function onMouseDrag from (event is MouseEvent) to ()
		     {
			 dx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
			 target.playTime = trax.frameTo(trax.xToDuration(dx));
			 trax.updatePlayhead();
		     }
		     override function onMouseUp from (event is MouseEvent) to ()
		     {
			 //println("commit playTime={target.playTime}, pickable={target.pickable}");
			 MasterUndoable.commit();
		     }
		content: 
		[Rectangle
		 {
		     height: bind h;
		     width: bind w;
		     fillPaint: bind bg;
		     strokePaint: bind CLIP_LABEL_PAINT;
		     blocksPointer: true;
		 },
		 Text.Label {
		     blocksPointer: false;
		     transform: bind translate(20, font.descent);
		     //height: bind h;
		     width: bind w;
		     background: null;
		     foreground: fg;
		     text: bind target.id;
		     font: bind timeNodeViewFont;
		 },
		 Rectangle is MouseInputHandler {
		     transform: bind translate(-w/2+5.0/2+2, 0);
		     height: 9.0;
		     width: 5.0;
		     fillPaint: bind if target.pickable then fg else TransparentPaint;
		     strokePaint: bind if not target.pickable then fg else TransparentPaint;
		     override function onMouseDown from (event is MouseEvent) to ()
		     {
			 target.pickable = not target.pickable;
		     }
		 }]
	      },
              Group { 
                   content: bind if (expanded) then content else [] 
	      }]
	 }
    }
}

public class Playhead is AbstractNode 
{
    public var x is Number;
    public var height is Number = 500;
    public var trax is Trax;

    override var transform = bind translate(x, 0);

    const playhead_top = Image { 
	url: "{__DIR__}playhead_top.png" 
	transform: bind translate(0, height/2);
    };

    const playhead_middle = Image { 
	url: "{__DIR__}playhead_middle.png";
	transform: bind scale(1, (height-15)/8)
    };

    const playhead_bottom = Image { 
	url: "{__DIR__}playhead_bottom.png" 
	transform: bind translate(0, -height / 2);
    };

    const playhead_marker is Image = Image { 
	url: "{__DIR__}playhead_marker.png";
	transform: bind translate(0, height/2 -5);
    };

    override var internalContent = Group {
	content: bind [playhead_middle, playhead_bottom, playhead_top, playhead_marker];
    } 

    var tx = 0.0;
    var dragging = false;

    const onDown = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    dragging = true;
	    tx = trax.frameToX(trax.currentFrame-trax.scrollOffset);
	}
    }

    const onDrag = DefaultObserver of MouseEvent {

	override function onNext from (event is MouseEvent) to ()
	{
	    tx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
	    println("drag {tx}");
	    trax.movePlayheadTo(tx);
	}
    };

    const onUp = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    dragging = false;
	}
    };
	
    const down = observeMouseDown().subscribe(onDown);
    const drag = observeMouseDrag().subscribe(onDrag);
    const up = observeMouseUp().subscribe(onUp);
}

public class Trax is ResizableNode, Focusable, KeyboardInputHandler {

    public function onDrop from (where is Pick, clip is TimeNode) to ()
    {
	println("ON DROP {where} {clip}");
    }

    var timelineListener is Disposable;

    const onPlayhead = DefaultObserver of Duration {
	override function onNext from (event is Duration) to () {
	    const d = if (not target.paused and targetNode.contentBounds.duration() > 0s) event.rem(targetNode.contentBounds.duration()) else event;
	    currentFrame = Math.round((d.toMillis() / 1000) * frameRate) as Integer;
	    //println("currentFrame {event} => {currentFrame}");
	    if (target.paused) {
		playhead.x = frameToX(currentFrame);
	    } else {
		playhead.x = durationToX(d);
	    }
	}
    }

    public var target is Timeline on replace {
	timelineListener.dispose();
	timelineListener = target.observePlayhead().subscribe(onPlayhead);
    }

    public var targetNode is TimeLayer;

    public var temporalHierarchy is TemporalHierarchy;

    public var removeClip is function from TimeNode to ();


    var selectedTimeNodeView is TimeNodeView = null on replace old {
	old.selected = false;
	selectedTimeNodeView.selected = true;
    }
    
    const undoList = UndoList {};

    readonly var visibleInterval = bind
	new Interval(frameToDuration(scrollOffset), 
		     frameToDuration(scrollOffset+visibleFrameCount));

    var clips is TimeNode[] on replace deleted[i..j] = inserted {
	for (x in deleted[i..j]) {
	    undoList.removeTarget(&x.playTime);
	    undoList.removeTarget(&x.pickable);
	}
	for (x in inserted) {
	    undoList.addTarget("{x.id}.playtime", &x.playTime);
	    undoList.addTarget("{x.id}.pickable", &x.pickable);
	}
    }

    public function setClips from (clips is TimeNode[]) to ()
    {
        this.clips = clips;
	for (t in timeNodeViews) t.row = indexof t;
    }

    readonly var timeNodeViews is TimeNodeView[] = bind getTimeNodes(clips);
    
    bound function getTimeNodes from (content is TimeNode[]) to TimeNodeView[] 
    {
	foreach (t in content) makeTimeNodeView(null, t)
    }

    var frameRate is Integer = 24;

    const lineMesh = LineMesh {};
    const backgroundColor is Color = Color.color(0.90, 0.90, 0.90);
    const backgroundPaint is Paint = ColorPaint(backgroundColor);
    const foregroundPaint is Paint = ColorPaint(Color.color(0.2, 0.2, 0.2));

    function autoScrollLeft {
    }

    function autoScrollRight {
    }

    public var currentFrame is Integer on replace {
	if (not playhead.dragging) {
	    if (currentFrame < scrollOffset) {
		scrollOffset = currentFrame;
	    } else if (currentFrame > scrollOffset + visibleFrameCount) {
		scrollOffset = currentFrame - visibleFrameCount / 2;
	    }
	} else {
	    if (currentFrame < scrollOffset) {
		autoScrollLeft();
	    } else if (currentFrame > scrollOffset + visibleFrameCount) {
		autoScrollRight();
	    }
	}
    }
    
    const PIXELS_PER_FRAME = 10;
    
    var visibleFrameCount is Integer = bind Math.round((width-10) / PIXELS_PER_FRAME) as Integer;

    function durationToFrame from (d is Duration) to Integer 
    {
	Math.round((d / 1s) * frameRate) as Integer;
    }

    function frameToDuration from (frames is Integer) to Duration {
	(1s / frameRate) * frames
    }
    
    function frameTo from (d is Duration) to Duration {
	const seconds = d / 1s;
	const frames = Math.round(seconds * frameRate);
	return (1s / frameRate) * frames;
    }

    function xToDuration from (x is Number) to Duration
    {
	1s * x / (10 * frameRate);
    }

    function xToFrame from (x is Number) to Integer
    {
	Math.round(x / 10) as Integer;
    }

    function durationToX from (d0 is Duration) to Number
    {
	durationToX(d0, false);
    }

    function durationToX from (d0 is Duration, loop is Boolean) to Number
    {
	const d = if (loop and targetNode.contentBounds.duration() > 0s) d0.rem(targetNode.contentBounds.duration()) else d0;
	const pixels = d / 1s * pixelsPerSecond();
	return pixels;
    }
    
    function pixelsPerSecond to Number {  
	pixelsPerFrame() * frameRate;
    }

    function pixelsPerFrame to Integer { 10 }

    function frameToX from (frame is Integer) to Number {
	frame * pixelsPerFrame();
    }

    function getViewHeight to Number {
	15
    }

    function updatePlayhead {
	target.setPlayhead(target.playhead);
    }

    function advancePlayhead from (frames is Integer) to ()
    {
	target.setPlayhead(target.playhead + frameToDuration(frames));
    }

    function movePlayheadTo from (x is Number) to ()
    {
	const scrollX = frameToX(scrollOffset);
	const d = xToDuration(x+scrollX);
	target.setPlayhead(frameToDuration(durationToFrame(d)));
	println("move playhead to {x}, scrollX={scrollX} d={d} frame={durationToFrame(d)}");
    }

    function getSelf to Trax { this }

    const playhead is Playhead = Playhead {
	id: "playhead";
	trax: this;
	override var height = bind getSelf().height;
    }
    var scrollOffset is Integer;
    var visibleDuration is Duration;
    var labels is Node[] = bind drawLabels(width, height, scrollOffset);
    var font = bind layoutEngine.createFont("font-size:8;font-family:Lucida Grande");
    var timeNodeViewFont = bind layoutEngine.createFont("font-size:11;font-family:Lucida Grande");

    function makeTimeNodeView from (parent is TimeNodeView, t is TimeNode) to TimeNodeView {
	println("Make time node view {parent}: {t}");
	TimeNodeView {
	    trax: this;
	    target: t;
	    expanded: t.id == "";
	}
    }

    function drawLabels from (w is Number, h is Number, offset is Integer) to Node[] 
    {
	//println("draw labels {offset}");
	const x = -w / 2 + 15;
	const y = h / 2 - 19;
	var off = offset - 10;
	foreach (i in [0..<w step 100]) {
	    off += 10;
	    Text.Label {
		height: 10;
		width: 30;
		background: this.backgroundPaint;
		foreground: this.foregroundPaint;
		transform: translate(x+i+10, y+10);
		font: font;
		text: "{off}"
	    }
	}
    }

    function drawLines from (w is Number, h is Number, viewHeight is Number) to AbstractMesh {
	println("TIMELINE={target}");
	const x0 = -w / 2 + 15;
	const y0 = Math.round(h / 2 - viewHeight-5);
	var x is Number = x0;
	var y is Number = y0;
	var mid is Boolean = false;
	lineMesh.reset();
	lineMesh.moveTo(x, y);
	for (i in [0..<w step pixelsPerFrame()]) {
	    var n = if (mid) then 3 else 5;
	    mid = not mid;
	    lineMesh.moveTo(x+i, y);
	    lineMesh.lineTo(x+i, y+n);
	}
	for (i in [0..<h step pixelsPerFrame()]) {
	    lineMesh.moveTo(x, y);
	    lineMesh.lineTo(x + width-pixelsPerFrame(), y);
	    y -= viewHeight;
	    println("y={y}");
	}
	const mesh = lineMesh.getMesh();
	mesh.updateBounds();
	println("draw lines: {mesh.bounds} {mesh.vertices.getVertexCount()}");
	return mesh;
    }

    public function selectClip from (clip is TimeNode) to ()
    {
	for (i in timeNodeViews) {
	    if (i.target == clip) {
		selectTimeNodeView(i);
		break;
	    }
	}
    }
    
    override var internalContent = Group {
	content: 
	[Rectangle is MouseInputHandler {
		id: "background"
		override var height = bind getSelf().height;
		override var width = bind getSelf().width;
		fillPaint: bind ColorPaint(backgroundColor);
		override function onMouseDown from (event is MouseEvent) to ()
		{
		    if (event.location.y >= height / 2 -15) {
			movePlayheadTo(event.location.x+width/2-10);
		    }
		    dx = 0;
		    startOff = scrollOffset;
		}
		var dx = 0.0;
		var startOff = 0;
		override function onMouseDrag from (event is MouseEvent) to ()
		{
		    if (event.location.y < height / 2 -15) {
			dx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
			const off = scrollOffset;
			scrollOffset = -xToFrame(dx) + startOff;
			const delta = scrollOffset - off;
			target.setPlayhead(target.playhead);
		    }
		}
	 },
	 Group { pickable: false, content: bind labels },
         MeshNode {
	     id: "lines"
	     pickable: false;
	     override var mesh = bind getSelf().drawLines(getSelf().width, getSelf().height, getViewHeight());
	     shader: effectLoader.loadPaintShader(ColorPaint(Color.color(.75, .75, .75)));
	 },
	 TransformNode { 
	     override var tx = bind -getSelf().width/2+15-frameToX(scrollOffset);
	     content:
	     [Group {
		 content: bind timeNodeViews;
	     },
	     TransformNode { ty: -6, content: bind playhead }]
	 }]
    }

    override function onKeyDown from (e is KeyboardEvent) to () {
	var i = selectedTimeNodeView.row;
	if (e.keyCode == Keys.Down) {
	    const n = timeNodeViews[i+1];
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Up) {
	    const n = timeNodeViews[i-1];
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Home) {
	    const n = timeNodeViews[0];
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.End) {
	    const n = timeNodeViews[clips.size()-1];
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Left) {
	    if (e.metaKey) {
		advancePlayhead(-1);
	    } else {
		selectedTimeNodeView.target.playTime -= frameToDuration(1);
	    }
	} else if (e.keyCode == Keys.Right) {
	    if (e.metaKey) {
		advancePlayhead(1);
	    } else {
		selectedTimeNodeView.target.playTime += frameToDuration(1);
	    }
	} else if (e.keyCode == Keys.Delete or e.keyCode == Keys.Backspace) {
	    if (selectedTimeNodeView.target <> null) {
		var selectedIndex = selectedTimeNodeView.row;
		removeClip(selectedTimeNodeView.target);
		selectedIndex = Math.min(selectedIndex, clips.size()-1);
		selectTimeNodeView(timeNodeViews[selectedIndex]);
	    }
	}
    }
    override function onKeyUp from (e is KeyboardEvent) to () {
    }

    override function onKeyInput from (e is KeyboardEvent) to () {
    }

    function selectTimeNodeView from (x is TimeNodeView) to () {
	if (x <> null) {
	    temporalHierarchy.selectTimeNode(x.target);
	}
	selectedTimeNodeView = x;
    }

}
