package expr.timeline;
import expr.*;
import expr.Names.*;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import f3.media.scene.KeyFrame.*;
import f3.media.input.*;
import f3.util.*;
import f3.util.Observer.*;
import f3.math.*;
import f3.math.LinearMath.*;
import java.lang.Math;
import expr.undo.*;

public const CLIP_COLOR = Color.rgb(50, 50, 50);
public const CLIP_SELECTED_COLOR = Color.rgb(77, 77, 77);
public const CLIP_LABEL_COLOR = Color.rgb(180, 180, 180);
public const CLIP_SELECTED_LABEL_COLOR = Color.rgb(230, 230, 230);

public const CHANNEL_COLOR = Color.rgb(140, 140, 140);
public const CHANNEL_LABEL_COLOR = Color.rgb(51, 51, 51);
public const CHANNEL_SELECTED_COLOR = Color.rgb(166, 166, 166);
public const CHANNEL_SELECTED_LABEL_COLOR = Color.rgb(26, 26, 26);

public const MODEL_COLOR = Color.rgb(80, 50, 50);
public const MODEL_SELECTED_COLOR = Color.rgb(130, 50, 50);

public const SOUND_COLOR = Color.rgb(50, 80, 50);
public const SOUND_SELECTED_COLOR = Color.rgb(50, 130, 50);

public const MOVIE_COLOR = Color.rgb(50, 50, 80);
public const MOVIE_SELECTED_COLOR = Color.rgb(50, 50, 130);


public const CLIP_PAINT = ColorPaint(CLIP_COLOR);
public const CLIP_SELECTED_PAINT = ColorPaint(CLIP_SELECTED_COLOR);

public const CLIP_LABEL_PAINT = ColorPaint(CLIP_LABEL_COLOR);
public const CLIP_SELECTED_LABEL_PAINT = ColorPaint(CLIP_SELECTED_LABEL_COLOR);

function debugPrint of a (label is String, value is a) to a {
    println("{label}: {value}");
    return value;
}

class KeyMark is Image, MouseInputHandler, KeyboardInputHandler {
    var kx = 0.0;
    override var url = "{__DIR__}keybubblemarker.png";
    public var k is Key;
    public var ch is Channel;
    public var trax is Trax;
    override var transform = bind translate(trax.durationToX(k.position), 0);
    override function onMouseDown from (event is MouseEvent) to ()
    {
        kx = trax.durationToX(k.position);
    }
    override function onMouseDrag from (event is MouseEvent) to ()
    {
        kx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
        k = trax.moveKeyTo(ch, k, trax.frameTo(trax.xToDuration(kx)));
        trax.updatePlayhead();
    }
    override function onMouseUp from (event is MouseEvent) to ()
    {
        //println("commit playTime={target.playTime}, pickable={target.pickable}");
        MasterUndoable.commit();
    }
}

class GroupKeyMark is Image, MouseInputHandler, KeyboardInputHandler {
    var kx = 0.0;
    override var url = "{__DIR__}keybubblemarker.png";
    public var k is Duration;
    public var ch is ResourceTarget.ChannelBoxGroup;
    public var trax is Trax;
    override var transform = bind translate(trax.durationToX(k), 0);
    override function onMouseDown from (event is MouseEvent) to ()
    {
        kx = trax.durationToX(k);
    }
    override function onMouseDrag from (event is MouseEvent) to ()
    {
        kx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
        k = ch.moveKeyTo(k, trax.frameTo(trax.xToDuration(kx)));
        trax.updatePlayhead();
    }
    override function onMouseUp from (event is MouseEvent) to ()
    {
        //println("commit playTime={target.playTime}, pickable={target.pickable}");
        MasterUndoable.commit();
    }
}


class TimeNodeView is AbstractNode 
{
    public var cy is Number;
    public var row is Integer;
    public var trax is Trax;
    public var target is TimeNode;
    public var playX is Number = bind getPlayX(target.playTime);
    public var content is TransformNode[] = bind getContent(target);
    public var expanded = false;

    var repeatMesh is LineMesh;

    function getRepeatMesh from (x is Number, w is Number, h is Number, repeats is Number) to MeshNode 
    {
        if (repeats <= 1) {
            repeatMesh = null;
            return null;
        }
        if (repeatMesh == null) {
            repeatMesh = LineMesh {};
        }
        repeatMesh.reset();
        for (i in [0..<Math.floor(repeats) as Integer]) {
            repeatMesh.moveTo(x + w * i, -h/2);
            repeatMesh.lineTo(x + w * i, h/2);
        }
        const mesh = repeatMesh.getMesh();
        mesh.updateBounds();
        MeshNode {
            mesh: mesh;
            shader: bind effectLoader.loadPaintShader(CLIP_LABEL_PAINT);
        }
    }

    function updateRows from (row is Integer) to Integer
    {
        this.row = row;
        var j = row+1;
        if (expanded) {
            for (k in content) {
                const i = k.content[0] as TimeNodeView;
                j = i.updateRows(j);
            }
        } 
        rowCount = j - row;
        return j;
    }

    override function toString to String 
    {
        "TimeNodeView {target}";
    }

    public function close to ()
    {
        expanded = false;
    }

    public function open to ()
    {
        getParentTimeNodeView().open();
        expanded = true;
    }

    public function getParentTimeNodeView to TimeNodeView {
        var p = parent;
        while (p <> null and not (p is TimeNodeView)) {
            p = p.parent;
            if (p is Trax) {
                return null;
            }
        }
        return p as TimeNodeView;
    }

    public function getRow from (row is Integer) to TimeNodeView {
        if (row == 0) {
            return this;
        }
        if (expanded) {
            var j = 1;
            for (k in content) {
                const i = k.content[0] as TimeNodeView;
                if (j + i.rowCount > row) {
                    return i.getRow(row-j);
                }
                j += i.rowCount;
            }
        }
        return null;
    }

    public var rowCount is Integer;

    bound function getRowCount from (content is Group[], result is Integer) to Integer {
        if (content == []) then result else {
                var x = content[0].content[0] as TimeNodeView;
                var xs = content[1..];
                var dummy = getRowCount(xs, result + x.rowCount);
            }
    }

    public var selected is Boolean;

    function getPlayX from (d is Duration) to Number 
    {
        trax.durationToX(d, false);
    }

    function getWidth from (i0 is Interval, visible is Interval) to Number 
    {
        const i = if (i0.duration() == 0s or i0.duration() > 10000s) then visible.end - i0.start else i0.duration();
    	trax.durationToX(i);
    }

    var selected1 = bind selected and trax.focused;

    bound function blendColor from (c is Color, a is Number) to ColorPaint {
        ColorPaint(if (a == 1.0) then c else Color.color(c.red, c.green, c.blue, c.opacity * a));
    }

    bound function getFill from (target is TimeNode) to Paint 
    {
	if (selected) then blendColor(CLIP_SELECTED_COLOR, target.sceneBlendWeight) else blendColor(CLIP_COLOR, target.sceneBlendWeight);
    }

    bound function getContent from (target0 is TimeNode) to TransformNode[]
    {
        var target = if target0 is ResourceTimeNodeWrapper then (target0 as ResourceTimeNodeWrapper).wrapped else target0;
        if (target is TimeGroup) {
            var g = target as TimeGroup;
            foreach (x in g.content) TransformNode { content: bind trax.makeTimeNodeView(null, x) }
        } else []
    }

    override function update to () 
    {
        if (expanded) {
            var y = -trax.getViewHeight();
            for (i in content) {
                i.ty = y;
                const tv = i.content[0] as TimeNodeView;
                y -= trax.getViewHeight() * tv.rowCount;
            }
        }
        super.update();
    }
    const self = this;
    var w = bind getWidth(if target.hasIndefiniteDuration() then Interval.<<0>> else target.bounds,
                          trax.visibleInterval);
    var h = bind trax.getViewHeight();
    var fg = bind if w == 0 then bg else if (selected1) then CLIP_SELECTED_LABEL_PAINT else CLIP_LABEL_PAINT;//ColorPaint(Color.color(.7, .7, .7, 1));
    var bg = bind getFill(target);
    var bg1 = ColorPaint(Color.color(.83, .83, .83));
    override var transform = bind translate(playX + w / 2.0, 0);
    function getTrackName from (target is TimeNode) to String
    {
        const shouldFormat1 = not (target is ResourceTimeNode) or not (target as ResourceTimeNode).useLiteralId;
        const shouldFormat2 = not (target is ResourceTarget.ChannelBoxGroup) or not (target as ResourceTarget.ChannelBoxGroup).useLiteralId;
        const shouldFormat = shouldFormat1 and shouldFormat2;
        if ((target.parent is ResourceTimeNode and not (target.parent is ResourceTimeNodeWrapper)) and target.parent.id == target.id) then "Main Timeline" else if shouldFormat then formatName(target.id) else target.id;
    }   
    var labelX = bind 
        if (target.hasIndefiniteDuration() and trax.visibleInterval.start > target.playTime + target.contentBounds.start)
            then trax.durationToX(trax.visibleInterval.start) - playX
            else 
                trax.durationToX(target.contentBounds.start);//Math.min(trax.durationToX(target.contentBounds.start), 0.0);

    override var internalContent = Group {
	content:
	Group {
            var dx is Number;
	    content: bind
	    [if (target == null) then null else Group { 
                visible: bind row > trax.scrollY;
		content: 
                [Rectangle {
                     var ww = bind w + trax.durationToX(target.contentBounds.start);              
                     transform: bind translate((ww - w) / 2.0, 0);
                     width: bind ww
                     height: bind h;
		     fillPaint: bind bg1;
                },
                Rectangle is MouseInputHandler {
                     transform: bind translate(trax.durationToX(target.contentBounds.start), 0)
                     height: bind h;
                     width: bind w;
		     fillPaint: bind bg;
		     strokePaint: bind CLIP_LABEL_PAINT;
		     blocksPointer: true;
		     override function onMouseDown from (event is MouseEvent) to ()
		     {
			 dx = trax.durationToX(target.playTime);
			 trax.selectTimeNodeView(self)
		     }
		     override function onMouseDrag from (event is MouseEvent) to ()
		     {
			 dx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
			 target.playTime = trax.frameTo(trax.xToDuration(dx));
			 trax.updatePlayhead();
		     }
		     override function onMouseUp from (event is MouseEvent) to ()
		     {
			 //println("commit playTime={target.playTime}, pickable={target.pickable}");
                         MasterUndoable.commit();
		     }
		 },
                 Group {
                     transform: bind translate(trax.durationToX(target.contentBounds.start), 0)
                     content: bind getRepeatMesh(-w/2, trax.durationToX(target.contentBounds.duration()), h, target.playCount);
                 },
		 Text.Label {
		     blocksPointer: false;
                     transform: bind translate(20+labelX, 
                                               font.descent);
		     //height: bind h;
		     width: bind Math.max(w, 100);
		     background: null;
		     foreground: bind fg;
		     text: bind getTrackName(target);
		     font: bind timeNodeViewFont;
		 },
		 Rectangle is MouseInputHandler {
		     transform: bind translate(labelX+-w/2+5.0/2+2, 0);
		     height: 9.0;
		     width: 5.0;
		     fillPaint: bind if target.pickable then fg else TransparentPaint;
		     strokePaint: bind if not target.pickable then fg else TransparentPaint;
		     override function onMouseDown from (event is MouseEvent) to ()
		     {
			 target.pickable = not target.pickable;
		     }
                     blocksPointer: true;
		 },
                 TransformNode {
                     visible: bind target is TimeGroup and { var g = target as TimeGroup; g.content.size() > 0 }
                     tx: bind labelX+-w/2 + 13;
                     rz: bind if (expanded) then -90 else 0;
                     content: Polygon is MouseInputHandler {
                         points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
                         fillPaint: bind fg;
                         override function onMouseDown from (event is MouseEvent) to ()
                         {
                             expanded = not expanded;
                         }
                     }
                 }]
              },
              if (not trax.graph) then null else Group {
                visible: bind row > trax.scrollY;
                  transform: bind translate(-w/2, 0);
                  content: bind if (target is ResourceTarget.ChannelBoxGroup) then {
                          var ch = target as ResourceTarget.ChannelBoxGroup;
                          foreach (k in ch.keyTimes) {
                              GroupKeyMark {
                                  ch: bind ch;
                                  k: k;
                                  trax: bind trax;
                              }
                          }
                      } else null;
              },
              if (not trax.graph) then null else Group {
                visible: bind row > trax.scrollY;
                  transform: bind translate(-w/2, 0);
                  content: bind if (target is Channel of ?) then {
                          var ch = target as Channel of Object;
                          foreach (k in ch.keys) {
                              KeyMark {
                                  ch: bind ch;
                                  k: k;
                                  trax: bind trax;
                              }
                          }
                      } else null;
              },
              if (not trax.graph or not (target is Channel of Number)) then null else Group {
                visible: bind row > trax.scrollY;
                  pickable: false;
                  transform: bind translate(-w/2, 0);
                  content: bind makeCurve(target as Channel of Number);
              },
              Group { 
                  transform: bind translate(-w/2, 0);
                  content: bind if (expanded) then content else [] 
	      }]
	 }
    }
}

public class Playhead is AbstractNode 
{
    public var x is Number;
    public var height is Number = 500;
    public var trax is Trax;

    override var transform = bind translate(x, 0);

    const playhead_top = Image { 
	url: "{__DIR__}playhead_top.png" 
	transform: bind translate(0, height/2-5);
    };

    const playhead_middle = Image { 
	url: "{__DIR__}playhead_middle.png";
	transform: bind translate(0, -5) * scale(1, (height-15)/8)
    };

    const playhead_bottom = Image { 
	url: "{__DIR__}playhead_bottom.png" 
	transform: bind translate(0, -height / 2);
    };

    const playhead_marker is Image = Image { 
	url: "{__DIR__}playhead_marker.png";
	transform: bind translate(0, height/2 -5);
    };

    override var internalContent = Group {
	content: bind [playhead_middle, playhead_bottom, playhead_top, playhead_marker];
    } 

    var tx = 0.0;
    var dragging = false;

    const onDown = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    dragging = true;
	    tx = trax.frameToX(trax.currentFrame-trax.scrollOffset);
	}
    }

    const onDrag = DefaultObserver of MouseEvent {

	override function onNext from (event is MouseEvent) to ()
	{
	    tx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
	    println("drag {tx}");
	    trax.movePlayheadTo(tx);
	}
    };

    const onUp = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    dragging = false;
	}
    };
	
    const down = observeMouseDown().subscribe(onDown);
    const drag = observeMouseDrag().subscribe(onDrag);
    const up = observeMouseUp().subscribe(onUp);
}

public class Trax is ResizableNode, Focusable, KeyboardInputHandler, Scrollable {

    const onWheel = 
	internalContent.observeMouseWheel().subscribe(function from (event is MouseWheelEvent) to () {
		const y = event.scroll.y as Integer;
		scrollVertically(y);
	    });

    public var graph is Boolean;
    const arrow is Polygon = Polygon {
	points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
	fillPaint: ColorPaint(Color.WHITE);
    };

    bound function arrowIcon (p is Paint, f is function from () to ()) to Node 
    {
	MeshNode is MouseInputHandler {
            blocksPointer: true;
            override function onMouseDown from (e is MouseEvent) to () 
            {
                println("mouse down {e}");
                f();
            }
	    mesh: bind arrow.fillMesh.mesh;
	    shader: bind effectLoader.loadPaintShader(p);
	}
    }

    public function onDrop from (where is Pick, clip is TimeNode, add is function from TimeNode to ()) to ()
    {
	//println("ON DROP {where} {clip}");
        const pt = toSceneTransform.inverse() * where.scenePoint;
        println("ON DROP {pt}");
        println("row={yToRow(pt.y)}");
        const row = yToRow(pt.y);
        const tv = rowToTimeNodeView(row);
        var targetNode = tv.target;
        println("targetNode={targetNode}");
        if (targetNode is ResourceTimeNodeWrapper) {
            targetNode = (targetNode as ResourceTimeNodeWrapper).wrapped;
        }
        if (targetNode is TimeGroup) {
            tv.getParentTimeNodeView().open();
            insert clip into (targetNode as TimeGroup).content;
        } else if (targetNode <> null) {
            tv.open();
            const g = targetNode as TimeGroup;
            insert clip after g.content[Sequences.indexOf(g.content, targetNode)];
        } else {
            add(clip);
        }
    }

    var timelineListener is Disposable;
    
    public var loop is Boolean;

    const onPlayhead = DefaultObserver of Duration {
	override function onNext from (event is Duration) to () {
            onPlayheadChange(event)
	}
    };

    protected function onPlayheadChange from (event is Duration) to ()
    {
        //const d = if (loop and not target.paused and targetNode.contentBounds.duration() > 0s) event.rem(targetNode.bounds.start + targetNode.contentBounds.duration()) else event;
        const d = event;
        currentFrame = (d.toMillis() / 1000) * frameRate;
        //println("currentFrame {event} => {currentFrame}");
        refreshPlayhead();
        if (target.paused) {
            playhead.x = frameToX(currentFrame);
        } else {
            playhead.x = durationToX(d);
        }
    }

    public var target is Timeline on replace {
	timelineListener.dispose();
	timelineListener = target.observePlayhead().subscribe(onPlayhead);
    }

    public var targetNode is TimeNode;

    public var temporalHierarchy is TemporalHierarchy;

    public var removeClip is function from TimeNode to ();


    var selectedTimeNodeView is TimeNodeView = null on replace old {
	old.selected = false;
	selectedTimeNodeView.selected = true;
    }
    
    const undoList = UndoList {};

    readonly var visibleInterval = bind
	new Interval(frameToDuration(scrollOffset), 
		     frameToDuration(scrollOffset+visibleFrameCount));

    public var clips is TimeNode[] on replace deleted[i..j] = inserted {
	for (x in deleted[i..j]) {
	    undoList.removeTarget(&x.playTime);
	    undoList.removeTarget(&x.pickable);
	}
	for (x in inserted) {
	    undoList.addTarget("{x.id}.playtime", &x.playTime);
	    undoList.addTarget("{x.id}.pickable", &x.pickable);
	}
    };

    override function update {
        super.update();
        performUpdate();
    }

    protected function performUpdate to ()
    {
        root.updateRows(0);
        rowCount = root.rowCount;
    }

    const root is TimeNodeView = TimeNodeView {
        expanded: true;
        trax: this;
        override var content = bind foreach (tv in timeNodeViews) TransformNode { content: bind tv }
    }

    var rowCount is Integer;

    readonly var timeNodeViews is TimeNodeView[] = bind getTimeNodes(clips);
    
    bound function getTimeNodes from (content is TimeNode[]) to TimeNodeView[] 
    {
	foreach (t in content) makeTimeNodeView(null, t)
    }

    public readonly var frameRate is Number = bind frameRateN on replace { frameRateGadget.setText("{Math.round(frameRate) as Integer}") };
    protected var frameRateN is Number = 24.0;

    const lineMesh = LineMesh {};
    const backgroundColor is Color = Color.color(0.6, 0.6, 0.6);//Color.color(0.90, 0.90, 0.90);
    const backgroundPaint is Paint = ColorPaint(backgroundColor);
    const foregroundPaint is Paint = ColorPaint(Color.color(0.2, 0.2, 0.2));

    function autoScrollLeft {
    }

    function autoScrollRight {
    }

    public var currentFrame is Number on replace { 
        frameGadget.setText("{(currentFrame as Integer)}");
        refreshPlayhead();
    }

    public function refreshPlayhead from () to () 
    {
	if (not playhead.dragging and not backgroundDragging and not horizontalScrolling) {
	    if (currentFrame < scrollOffset) {
		scrollOffset = currentFrame;
	    } else if (currentFrame > scrollOffset + visibleFrameCount) {
		scrollOffset = currentFrame - visibleFrameCount / 2;
	    }
	} else {
	    if (currentFrame < scrollOffset) {
		autoScrollLeft();
	    } else if (currentFrame > scrollOffset + visibleFrameCount) {
		autoScrollRight();
	    }
	}
    }
    
    const PIXELS_PER_FRAME = 10;
    const TICK_PIXELS = 10;
    
    var visibleFrameCount is Number = bind (width-10) / pixelsPerFrame();

    var unzoomedVisibleFrameCount is Number = bind (width-10) / PIXELS_PER_FRAME;
    var unzoomedVisibleDuration = bind 1s / 24 * unzoomedVisibleFrameCount;

    bound function durationToFrame from (d is Duration) to Number
    {
	Math.round((d / 1s) * frameRate);
    }

    bound function frameToDuration from (frames is Number) to Duration 
    {
	(1s / frameRate) * frames
    }
    
    bound function frameTo from (d is Duration) to Duration {
	var seconds = d / 1s;
	var frames = Math.round((seconds * frameRate));
	return (1s / frameRate) * frames;
    }
    
    function rowToTimeNodeView from (row is Integer) to TimeNodeView
    {
        var j = 0;
        for (i in timeNodeViews) {
            if (j + i.rowCount > row) {
                return i.getRow(row-j);
            }
            j += i.rowCount;
        }
        return null;
    }

    function yToRow from (y0 is Number) to Integer 
    {
        const y = y0 - height/2;
        -Math.round(y / getViewHeight() + 2) as Integer;
    }

    bound function xToDuration from (x is Number) to Duration
    {
	1s * x / (pixelsPerFrame() * frameRate);
    }

    bound function xToFrame from (x is Number) to Number
    {
	Math.round(x / pixelsPerFrame());
    }

    bound function durationToX from (d0 is Duration) to Number
    {
	durationToX(d0, false);
    }

    bound function durationToX from (d0 is Duration, loop is Boolean) to Number
    {
        var dur = targetNode.contentBounds.duration();
	var d = if (loop and dur > 0s) d0.rem(dur) else d0;
	var pixels = d / 1s * pixelsPerSecond();
	return pixels;
    }

    bound function framesPerTick to Number {
        pixelsPerFrame() * TICK_PIXELS;
    }
    
    bound function pixelsPerSecond to Number {  
	pixelsPerFrame() * frameRate;
    }

    bound function pixelsPerFrame to Number { PIXELS_PER_FRAME }
    
    bound function frameToX from (frame is Number) to Number 
    {
	frame * pixelsPerFrame();
    }

    public function getViewHeight to Number 
    {
	15
    }

    function updatePlayhead {
        const value = target.paused;
        target.paused = true;
	target.setPlayhead(target.playhead);
        target.paused = value;
    }

    public function setFrameRate from (fps is Integer) to ()
    {
        frameRateN = fps;
    }

    function advancePlayhead from (frames is Number) to ()
    {
	target.setPlayhead(target.playhead + frameToDuration(frames));
    }

    function movePlayheadTo from (x is Number) to ()
    {
	const scrollX = frameToX(scrollOffset);
	const d = xToDuration(x+scrollX);
	target.setPlayhead(frameToDuration(durationToFrame(d)));
	println("move playhead to {x}, scrollX={scrollX} d={d} frame={durationToFrame(d)}");
    }

    function getSelf to Trax { this }


    override bound function getTx to Number { 
        if (dur == 0s) then 0.0 else frameToDuration(scrollOffset) /  dur;
    }

    override bound function getSx to Number { 
        targetSx(visibleInterval.duration(), targetNode.contentBounds) * (frameRate / frameRateN)
    }

    function targetSx from (dur is Duration, bounds is Interval) to Number {
        if (0s == bounds.end) then 1.0 else dur/(dur + bounds.end);
    }

    var dur = bind visibleInterval.duration() + targetNode.contentBounds.end;
    var traxHeight = bind height - 20;
    var rootContent = bind getRootContent();
    var sy0 = bind Math.min(traxHeight / Math.max(rootContent.bounds.height(), 1), 1.0);
    var ty0 = bind if rootContent.bounds.height() == 0 then 0.0 else (scrollY * getViewHeight()) / rootContent.bounds.height();

    override bound function getSy to Number { sy0 }

    override bound function getTy to Number { ty0 }

    function scrollVertically from (i is Integer) to ()
    {
        scrollY = Math.max(0, Math.min(i+scrollY, rowCount - (traxHeight / getViewHeight()) as Integer));
    }

    override public function setY from (ty is Number, sy is Number) to () {
        scrollY = (ty * rootContent.bounds.height() / getViewHeight()) as Integer;
    }

    override public function setX from (tx is Number, sx is Number) to ()
    {
        const cur = getSx();
        if (sx <> 0) {
            frameRateN *= cur / sx;
        }
        scrollOffset = durationToFrame(dur * tx);
    }

    const playhead is Playhead = Playhead {
	id: "playhead";
	trax: this;
	override var height = bind getSelf().height;
    }
    var scrollY is Integer;
    public var scrollOffset is Number;
    var visibleDuration is Duration = bind visibleInterval.duration();
    var labels is Node[] = bind drawLabels(width, height, scrollOffset, frameRate);
    var font = bind layoutEngine.createFont("font-size:8;font-family:Lucida Grande");
    var timeNodeViewFont = bind layoutEngine.createFont("font-size:10;font-family:Lucida Grande;font-weight:bold");

    function makeTimeNodeView from (parent is TimeNodeView, t0 is TimeNode) to TimeNodeView 
    {
        var t = t0;
        /*
        if (t0 is ResourceTimeNode) {
            const rtn = t0 as ResourceTimeNode;
            const c = rtn.content[0];
            if (c is TransitionLayer) {
                t = c;
            } else if (c is BlendLayer) {
                t = c;
            }
        }
        */
        println("making time node view for target: {t} with content bounds {t.contentBounds}");
        TimeNodeView {
            trax: this;
            target: t;
        }
    }

    readonly var gadgetFont = bind layoutEngine.createFont("font-size:10;font-family:Lucida Grande");
    readonly var gadgetFg = ColorPaint(Color.color(.8, .8, .8));
    readonly var gadgetBg = ColorPaint(Color.color(.4, .4, .4));
        

    public var frameGadget is Text.Field = Text.Field {
        width: bind 64;
        height: 13;
        rightJustified: true;
        font: bind gadgetFont;
        foreground: bind gadgetFg;
        background: bind gadgetBg;
        text: "0"
    };

    const onGadgetCommit = frameGadget.observeCommit().subscribe(function from (_ is ()) to () {
           const currentFrame = Integer.parseInt(frameGadget.text);
           target.setPlayhead(1s / frameRate * currentFrame);
        });

    public var frameRateGadget is Text.Field = Text.Field {
        width: 48
        height: 13;
        rightJustified: true;
        font: bind gadgetFont;
        foreground: bind gadgetFg;
        background: bind gadgetBg;
        text: "24"
    };

    const onRateGadgetCommit = frameRateGadget.observeCommit().subscribe(function from (_ is ()) to () {
            frameRateN = Math.max(Integer.parseInt(frameRateGadget.text), 1);
        });

    public var combinedGadget is Node = Group {
        content: 
        [TransformNode {
            tx: -64
            content: frameGadget;
        },
        TransformNode {
            content: frameRateGadget;
        },
        TransformNode {
            tx: 31;
            content: Text.Label {
                text: "fps";
                font: bind gadgetFont;
                width: 15;
                height: 13;
                foreground: bind gadgetFg;
                background: bind gadgetBg;
            }
        }]
    }


    bound function drawLabels from (w is Number, h is Number, offset is Number, frameRateN is Number) to Node[] 
    {
	//println("draw labels {offset}");
	var x0 = -w / 2 + 15 + 15;
	var y = h / 2 - 19;
        var slop = offset mod 10;
        var x = x0 - frameToX(slop);
	foreach (i in [0..(w+100) step 100]) {
            if (x+i < x0) then null else  {
                    var t = Text.Label {
                        height: 10;
                        width: 30;
                        background: bind this.backgroundPaint;
                        foreground: bind this.foregroundPaint;
                        transform: bind translate(x+i, y+10);
                        font: bind font;
                        text: bind "{Math.round(xToFrame(i)+offset-slop) as Integer}"
                    }
                    TransformNode {
                        tx: bind -t.content.textShape.getBounds().width() / 2
                            content: t
                            }
                }
	}
    }

    function drawLines from (w is Number, h is Number, viewHeight is Number, scroll is Number) to AbstractMesh {
	//println("TIMELINE={target} pp={pixelsPerFrame()}");
	const x0 = -w / 2 + 15;
	const y0 = Math.round(h / 2 - viewHeight-5);
	var x is Number = x0;
        var slop = scroll mod 2;
	var y is Number = y0;
	var mid is Boolean = false;
	lineMesh.reset();
	lineMesh.moveTo(x, y);
        const pp = PIXELS_PER_FRAME;
        var offset = 0;
        var off0 = offset mod pp;
	var off = (offset - off0) * pp;
        var off1 = off0 * pp;
        x -= frameToX(slop);
        //println("OFF={offset}");
	for (i in [0..(w+off) step PIXELS_PER_FRAME]) {
	    var n = if (mid) then 3 else 5;
	    mid = not mid;
            const x1 = -off1+x+i;
            if (x1 >= x0) {
                lineMesh.moveTo(x1, y);
                lineMesh.lineTo(x1, y+n);
            }
	}
        x = x0;
	for (i in [0..<h step pp]) {
	    lineMesh.moveTo(x, y);
	    lineMesh.lineTo(x + width, y);
	    y -= viewHeight;
	    //println("y={y}");
	}
	const mesh = lineMesh.getMesh();
	mesh.updateBounds();
	//println("draw lines: {mesh.bounds} {mesh.vertices.getVertexCount()}");
	return mesh;
    }

    public function selectClip from (clip is TimeNode) to ()
    {
	for (i in timeNodeViews) {
	    if (i.target == clip) {
		selectTimeNodeView(i);
		break;
	    }
	}
    }

    var horizontalScrolling = false;
    
    override function onScrollHorizontally from (b is Boolean) to ()
    {
        horizontalScrolling = b;
        if (not b) {
            frameRateN = Math.max(Math.round(frameRateN), 1.0);
            fixupPlayhead();
        }
    }

    function fixupPlayhead to () {
        if (currentFrame < scrollOffset) {
            target.setPlayhead(frameToDuration(scrollOffset));
        } else if (currentFrame > scrollOffset + visibleFrameCount) {
            target.setPlayhead(frameToDuration(scrollOffset + visibleFrameCount));
        }
    }

    var backgroundDragging = false;
    
    override var internalContent = Group {
	content: 
	[Rectangle is MouseInputHandler {
		id: "background"
		override var height = bind getSelf().height;
		override var width = bind getSelf().width;
		fillPaint: bind ColorPaint(backgroundColor);
		override function onMouseDown from (event is MouseEvent) to ()
		{
		    if (event.location.y >= height / 2 - 20) {
			movePlayheadTo(event.location.x+width/2-15);
		    } else {
                        backgroundDragging = true;
                    }
		    dx = 0;
		    startOff = scrollOffset;
		}
		var dx = 0.0;
		var startOff = 0.0;
		override function onMouseUp from (event is MouseEvent) to () 
                {
                    backgroundDragging = false;
                }
		override function onMouseDrag from (event is MouseEvent) to ()
		{
		    if (backgroundDragging) {
			dx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
			const off = scrollOffset;
			scrollOffset = Math.round(-xToFrame(dx) + startOff);
			const delta = scrollOffset - off;
                        if (target.playhead < visibleInterval.start) {
                            target.setPlayhead(visibleInterval.start);
                        } else if (target.playhead > visibleInterval.end) {
                            target.setPlayhead(visibleInterval.end - frameToDuration(1));
                        } else {
                            target.setPlayhead(target.playhead);
                        }
		    }
		}
	 },
	 Group { pickable: false, content: bind labels },
         MeshNode {
	     id: "lines"
	     pickable: false;
	     override var mesh = bind getSelf().drawLines(getSelf().width, getSelf().height, getViewHeight(), scrollOffset);
	     shader: bind effectLoader.loadPaintShader(foregroundPaint);
	 },
	 TransformNode { 
	     tx: bind -getSelf().width/2+15-frameToX(scrollOffset);
	     content:
	     [TransformNode {
                 ty: bind height / 2 + 2 - 15 + scrollY * getViewHeight(); 
                 content: bind getRootContent();
	     },
	     TransformNode { ty: -6, content: bind playhead }]
	 }]
    }

    protected bound function getRootContent to Node { root }

    override function onKeyDown from (e is KeyboardEvent) to () {
	var i = selectedTimeNodeView.row;
	if (e.keyCode == Keys.F) {
            frameSelection();
            e.stopPropagation();
	} else if (e.keyCode == Keys.Down) {
	    const n = rowToTimeNodeView(i+1);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Up) {
	    const n = rowToTimeNodeView(i-1);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Home) {
	    const n = rowToTimeNodeView(0);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.End) {
	    const n = rowToTimeNodeView(rowCount-1);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Left) {
	    if (e.metaKey) {
		advancePlayhead(-1);
	    } else  if (selectedTimeNodeView.expanded) {
                selectedTimeNodeView.close();
            } else {
		selectedTimeNodeView.target.playTime -= frameToDuration(1);
		updatePlayhead()
	    }
	} else if (e.keyCode == Keys.S) {
            setKeys();
	} else if (e.keyCode == Keys.Right) {
	    if (e.metaKey) {
		advancePlayhead(1);
	    } else {
                if (not selectedTimeNodeView.expanded) {
                    selectedTimeNodeView.open();
                } else {
                    selectedTimeNodeView.target.playTime += frameToDuration(1);
                    updatePlayhead();
                }
	    }
        } else if (e.keyCode == Keys.Spacebar) {
            target.paused = not target.paused;
	} else if (e.keyCode == Keys.Delete or e.keyCode == Keys.Backspace) {
            handleDelete();
	}
    }

    protected function handleDelete to ()
    {
        if (selectedTimeNodeView.target <> null) {
            var selectedIndex = selectedTimeNodeView.row;
            removeClip(selectedTimeNodeView.target);
            selectedIndex = Math.min(selectedIndex, rowCount-1);
            selectTimeNodeView(rowToTimeNodeView(selectedIndex));
        }
    }


    override function onKeyUp from (e is KeyboardEvent) to () {
    }

    override function onKeyInput from (e is KeyboardEvent) to () {
    }

    function selectTimeNodeView from (x is TimeNodeView) to () {
	if (x <> null) {
            temporalHierarchy.selectTimeNode(x.target);
	}
	selectedTimeNodeView = x;
    }

    protected function makeTangent from (ch is Channel, k is KeyFrame.Key of Number, 
                                         interp is KeyFrame.Interpolator of Number, 
                                         valueBounds is Vec2,
                                         viewHeight is Number) to TangentTool 
    {
        const ty = valueBounds.x;
        var dy = (valueBounds.y - valueBounds.x);
        const sy = if (dy == 0 or viewHeight == 0) then 1.0 else (0.5 * viewHeight) / dy;
        println("VALUE BOUNDS {valueBounds}");
        println("ty={ty}, sy={sy}");
        var x1 is Number;
        var y1 is Number;
        var x2 is Number;
        var y2 is Number;
        if (interp is KeyFrame.Tangent) {
            const t = interp as KeyFrame.Tangent;
            const kix = t.kix;
            const kiy = t.kiy;
            const kox = t.kox;
            const koy = t.koy;
            const value1 = k.prev.value;
            const value2 =  k.value;
            const p0 = value1;
            const p3 = value2;
            const frame1 = (k.prev.position / (1s/24))  as Integer;
            const frame2 = (k.position / (1s/24))  as Integer;
            const outTan = if (kox == 0) then 0 else koy / (kox * 24.0);
            const inTan = if (kix == 0) then 0 else  kiy / (kix * 24.0);
            const oneThirdDelta = (frame2 - frame1) / 3.0;
            const p1Delta = outTan * oneThirdDelta;
            const p2Delta = -inTan * oneThirdDelta;
            x1 = oneThirdDelta;
            y1 = p1Delta;
            x2 = oneThirdDelta;
            y2 = -p2Delta;
        } else {
            const frame1 = (k.prev.position / (1s/24))  as Integer;
            const frame2 = (k.position / (1s/24))  as Integer;
            x1 = frame1;
            x2 = frame2;
            y1 = k.prev.value;
            y2 = k.value;
        }

        y1 -= ty;
        y2 -= ty;

        y1 *= sy;
        y2 *= sy;

        const outAngle = Math.atan2(y1, x1);
        const inAngle = Math.atan2(y2, x2);
        const outLength = Math.sqrt(x1*x1+y1*y1);
        const inLength = Math.sqrt(x2*x2+y2*y2);

        const tool = TangentTool {
            editable: false;
            transform: bind translate(durationToX(k.prev.position), -viewHeight/2.0);
            p1: bind new Vec2(0, (k.prev.value - ty)*sy);
            p2: bind new Vec2(durationToX(k.position-k.prev.position) / ch.toSceneTransform.rate,
                              (k.value - ty)*sy);
            inAngle: inAngle;
            inLength: inLength;
            outAngle: outAngle;
            outLength: outLength;
            isPointOnly: k.prev == null and k.next == null;
        }

        tool.valueScale = new Vec2(1.0, 1.0 / sy);
        return tool;
    }

    protected function getValueBounds from (keys is (Key of Number)[]) to Vec2 {
        var min = Number.MAX_VALUE;
        var max = Number.MIN_VALUE;
        for (k in keys) {
            const n is Number = k.value;
            if (n > max) max = n;
            if (n < min) min = n;
        }
        return new Vec2(min, max);
    }

    protected function makeCurveContent from (ch is Channel, k is KeyFrame.Key of Number, 
                                              interp is KeyFrame.Interpolator of Number, 
                                              valueBounds is Vec2,
                                              viewHeight is Number) to PathElement[]
    {
        makeCurveFromTangent(makeTangent(ch, k, interp, valueBounds, viewHeight), durationToX(k.prev.position));
    }

    protected function makeCurveFromTangent from (t is TangentTool, x is Number) to PathElement[]
    {
        const off = new Vec2(x, 0); 
        if (t.isPointOnly) then [] else [moveTo(t.p1 + off), 
                                                cubicTo(t.cp1+off, t.cp2+off, t.p2+off)];
    }

    function makePathElements from (ch is Channel, keys is (KeyFrame.Key of Number)[]) to Shape2D.PathElement[] 
    {
        foreach (k in keys) makeCurveContent(ch, k, k.interpolator, getValueBounds(keys), getViewHeight()) 
    }

    protected function makeCurve from (ch is Channel of Number) to Node {
        Path {
            strokePaint: ColorPaint(Color.GREEN);
            content: bind makePathElements(ch, ch.keys);
        }
    }

    public function setKey of a from (ch is Channel of a, i is Interpolator of a) to ()
    {
        if (not ch.pickable) { return }
        ch.setKey(i);
    }

    public function frameSelection to ()
    {
        var bounds is Interval;
        if (selectedTimeNodeView <> null) {
            const n = selectedTimeNodeView.target;
            if (not n.hasIndefiniteDuration()) {
                bounds = n.bounds;
            }
        } else {
            for (t in timeNodeViews) {
                const n = t.target;
                if (not n.hasIndefiniteDuration()) {
                    bounds = Interval.merge(bounds, n.bounds);
                }
            }
        }
        if (bounds.duration() == 0s) {
            return;
        }
        bounds.add(target.playhead);
        const margin = 10;
        const pixels = (width - 10.0) - margin;
        const ticks = pixels / TICK_PIXELS;
        const seconds = bounds.duration() / 1s;
        frameRateN = Math.max(ticks / seconds, 1.0);
        scrollOffset = durationToFrame(bounds.start);
        fixupPlayhead();
    }

    protected function setKeys to () 
    {
    }

    public function moveKeyTo of a from (ch is Channel of a, k is KeyFrame.Key of a, pos is Duration) to Key of a
    {
        ch.moveKey(k, pos - k.position);
    }
}
