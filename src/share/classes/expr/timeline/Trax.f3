package expr.timeline;
import expr.*;
import expr.Names.*;
import f3.media.scene.*;
import f3.media.scene.Shape2D.*;
import f3.media.input.*;
import f3.util.*;
import f3.util.Observer.*;
import f3.math.*;
import f3.math.LinearMath.*;
import java.lang.Math;
import expr.undo.*;

public const CLIP_COLOR = Color.rgb(50, 50, 50);
public const CLIP_SELECTED_COLOR = Color.rgb(77, 77, 77);
public const CLIP_LABEL_COLOR = Color.rgb(180, 180, 180);
public const CLIP_SELECTED_LABEL_COLOR = Color.rgb(230, 230, 230);

public const CHANNEL_COLOR = Color.rgb(140, 140, 140);
public const CHANNEL_LABEL_COLOR = Color.rgb(51, 51, 51);
public const CHANNEL_SELECTED_COLOR = Color.rgb(166, 166, 166);
public const CHANNEL_SELECTED_LABEL_COLOR = Color.rgb(26, 26, 26);

public const MODEL_COLOR = Color.rgb(80, 50, 50);
public const MODEL_SELECTED_COLOR = Color.rgb(130, 50, 50);

public const SOUND_COLOR = Color.rgb(50, 80, 50);
public const SOUND_SELECTED_COLOR = Color.rgb(50, 130, 50);

public const MOVIE_COLOR = Color.rgb(50, 50, 80);
public const MOVIE_SELECTED_COLOR = Color.rgb(50, 50, 130);


public const CLIP_PAINT = ColorPaint(CLIP_COLOR);
public const CLIP_SELECTED_PAINT = ColorPaint(CLIP_SELECTED_COLOR);

public const CLIP_LABEL_PAINT = ColorPaint(CLIP_LABEL_COLOR);
public const CLIP_SELECTED_LABEL_PAINT = ColorPaint(CLIP_SELECTED_LABEL_COLOR);

function debugPrint of a (label is String, value is a) to a {
    println("{label}: {value}");
    return value;
}

class TimeNodeView is AbstractNode 
{
    public var cy is Number;
    public var row is Integer;
    public var trax is Trax;
    public var target is TimeNode;
    public var playX is Number = bind getPlayX(target.playTime);
    public var content is TransformNode[] = bind getContent(target);
    public var expanded = false;

    function updateRows from (row is Integer) to Integer
    {
        this.row = row;
        var j = row+1;
        if (expanded) {
            for (k in content) {
                const i = k.content[0] as TimeNodeView;
                j = i.updateRows(j);
            }
        } 
        rowCount = j - row;
        return j;
    }

    override function toString to String 
    {
        "TimeNodeView {target}";
    }

    public function close to ()
    {
        expanded = false;
    }

    public function open to ()
    {
        getParentTimeNodeView().open();
        expanded = true;
    }

    public function getParentTimeNodeView to TimeNodeView {
        var p = parent;
        while (p <> null and not (p is TimeNodeView)) {
            p = p.parent;
            if (p is Trax) {
                return null;
            }
        }
        return p as TimeNodeView;
    }

    public function getRow from (row is Integer) to TimeNodeView {
        if (row == 0) {
            return this;
        }
        if (expanded) {
            var j = 1;
            for (k in content) {
                const i = k.content[0] as TimeNodeView;
                if (j + i.rowCount > row) {
                    return i.getRow(row-j);
                }
                j += i.rowCount;
            }
        }
        return null;
    }

    public var rowCount is Integer;

    bound function getRowCount from (content is Group[], result is Integer) to Integer {
        if (content == []) then result else {
                var x = content[0].content[0] as TimeNodeView;
                var xs = content[1..];
                var dummy = getRowCount(xs, result + x.rowCount);
            }
    }

    public var selected is Boolean;

    function getPlayX from (d is Duration) to Number 
    {
        trax.durationToX(d, false);
    }

    function getWidth from (i0 is Interval, visible is Interval) to Number 
    {
        const i = if (i0.duration() == 0s) then visible.end - i0.start else i0.duration();
    	trax.durationToX(i);
    }

    var selected1 = bind selected and trax.focused;

    bound function blendColor from (c is Color, a is Number) to ColorPaint {
        ColorPaint(if (a == 1.0) then c else Color.color(c.red, c.green, c.blue, c.opacity * a));
    }

    bound function getFill from (target is TimeNode) to Paint 
    {
	if (selected) then blendColor(CLIP_SELECTED_COLOR, target.sceneBlendWeight) else blendColor(CLIP_COLOR, target.sceneBlendWeight);
    }

    bound function getContent from (target is TimeNode) to TransformNode[]
    {
        if (target is TimeGroup) {
            var g = target as TimeGroup;
            foreach (x in g.content) TransformNode { content: bind trax.makeTimeNodeView(null, x) }
        } else []
    }

    override function update to () 
    {
        if (expanded) {
            var y = -trax.getViewHeight();
            for (i in content) {
                i.ty = y;
                const tv = i.content[0] as TimeNodeView;
                y -= trax.getViewHeight() * tv.rowCount;
            }
        }
        super.update();
    }
    const self = this;
    var w = bind getWidth(target.bounds, trax.visibleInterval);
    var h = bind trax.getViewHeight();
    var fg = bind if w == 0 then bg else if (selected1) then CLIP_SELECTED_LABEL_PAINT else CLIP_LABEL_PAINT;//ColorPaint(Color.color(.7, .7, .7, 1));
    var bg = bind getFill(target);
    var bg1 = ColorPaint(Color.color(.83, .83, .83));
    override var transform = bind translate(playX + w / 2.0, 0);
    function getTrackName from (target is TimeNode) to String
    {
        println("target: {target.id} <= {target.getClass()}");
        println("parent: {target.parent.id} <= {target.parent.getClass()}");
        if ((target.parent is ResourceTimeNode and not (target.parent is ResourceTimeNodeWrapper)) and target.parent.id == target.id) then "Main Timeline" else formatName(target.id);
    }   
    override var internalContent = Group {
	content:
	Group {
            var dx is Number;
	    content: bind
	    [if (target == null) then null else Group { 
                visible: bind row > trax.scrollY;
		content: 
                [Rectangle {
                     width: bind w + trax.durationToX(target.contentBounds.start);               
                     height: bind h;
		     fillPaint: bind bg1;
                },
                Rectangle is MouseInputHandler {
                     transform: bind translate(trax.durationToX(target.contentBounds.start), 0)
                     height: bind h;
                     width: bind w;
		     fillPaint: bind bg;
		     strokePaint: bind CLIP_LABEL_PAINT;
		     blocksPointer: true;
		     override function onMouseDown from (event is MouseEvent) to ()
		     {
			 dx = trax.durationToX(target.playTime);
			 trax.selectTimeNodeView(self)
		     }
		     override function onMouseDrag from (event is MouseEvent) to ()
		     {
			 dx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
			 target.playTime = trax.frameTo(trax.xToDuration(dx));
			 trax.updatePlayhead();
		     }
		     override function onMouseUp from (event is MouseEvent) to ()
		     {
			 //println("commit playTime={target.playTime}, pickable={target.pickable}");
                         MasterUndoable.commit();
		     }
		 },
		 Text.Label {
		     blocksPointer: false;
                     transform: bind translate(20+trax.durationToX(target.contentBounds.start), font.descent);
		     //height: bind h;
		     width: bind Math.max(w, 100);
		     background: null;
		     foreground: bind fg;
		     text: bind getTrackName(target);
		     font: bind timeNodeViewFont;
		 },
		 Rectangle is MouseInputHandler {
		     transform: bind translate(-w/2+5.0/2+2, 0);
		     height: 9.0;
		     width: 5.0;
		     fillPaint: bind if target.pickable then fg else TransparentPaint;
		     strokePaint: bind if not target.pickable then fg else TransparentPaint;
		     override function onMouseDown from (event is MouseEvent) to ()
		     {
			 target.pickable = not target.pickable;
		     }
                     blocksPointer: true;
		 },
                 TransformNode {
                     visible: bind target is TimeGroup and { var g = target as TimeGroup; g.content.size() > 0 }
                     tx: bind -w/2 + 13;
                     rz: bind if (expanded) then -90 else 0;
                     content: Polygon is MouseInputHandler {
                         points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
                         fillPaint: bind fg;
                         override function onMouseDown from (event is MouseEvent) to ()
                         {
                             expanded = not expanded;
                         }
                     }
                 }]
              },
              Group {
                  transform: bind translate(-w/2, 0);
                  content: bind if (target is Channel of ?) then {
                          var ch = target as Channel of Object;
                          foreach (k in ch.keys) {
                              Image {
                                  url: "{__DIR__}keybubblemarker.png";
                                  transform: bind translate(trax.durationToX(k.position), 0);
                              }
                          }
                      } else null;
              },
              Group {
                  transform: bind translate(-w/2, 0);
                  content: bind if (target is Channel of Number) then makeCurve(target as Channel of Number) else null;
              },
              Group { 
                  transform: bind translate(-w/2, 0);
                  content: bind if (expanded) then content else [] 
	      }]
	 }
    }
}

public class Playhead is AbstractNode 
{
    public var x is Number;
    public var height is Number = 500;
    public var trax is Trax;

    override var transform = bind translate(x, 0);

    const playhead_top = Image { 
	url: "{__DIR__}playhead_top.png" 
	transform: bind translate(0, height/2-5);
    };

    const playhead_middle = Image { 
	url: "{__DIR__}playhead_middle.png";
	transform: bind translate(0, -5) * scale(1, (height-15)/8)
    };

    const playhead_bottom = Image { 
	url: "{__DIR__}playhead_bottom.png" 
	transform: bind translate(0, -height / 2);
    };

    const playhead_marker is Image = Image { 
	url: "{__DIR__}playhead_marker.png";
	transform: bind translate(0, height/2 -5);
    };

    override var internalContent = Group {
	content: bind [playhead_middle, playhead_bottom, playhead_top, playhead_marker];
    } 

    var tx = 0.0;
    var dragging = false;

    const onDown = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    dragging = true;
	    tx = trax.frameToX(trax.currentFrame-trax.scrollOffset);
	}
    }

    const onDrag = DefaultObserver of MouseEvent {

	override function onNext from (event is MouseEvent) to ()
	{
	    tx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
	    println("drag {tx}");
	    trax.movePlayheadTo(tx);
	}
    };

    const onUp = DefaultObserver of MouseEvent {
	override function onNext from (event is MouseEvent) to ()
	{
	    dragging = false;
	}
    };
	
    const down = observeMouseDown().subscribe(onDown);
    const drag = observeMouseDrag().subscribe(onDrag);
    const up = observeMouseUp().subscribe(onUp);
}

public class Trax is ResizableNode, Focusable, KeyboardInputHandler, Scrollable {

    const arrow is Polygon = Polygon {
	points: [-3.5, -4.5, -3.5, 4.5, 3.5, 0];
	fillPaint: ColorPaint(Color.WHITE);
    };

    bound function arrowIcon (p is Paint, f is function from () to ()) to Node 
    {
	MeshNode is MouseInputHandler {
            blocksPointer: true;
            override function onMouseDown from (e is MouseEvent) to () 
            {
                println("mouse down {e}");
                f();
            }
	    mesh: bind arrow.fillMesh.mesh;
	    shader: bind effectLoader.loadPaintShader(p);
	}
    }

    public function onDrop from (where is Pick, clip is TimeNode, add is function from TimeNode to ()) to ()
    {
	//println("ON DROP {where} {clip}");
        const pt = toSceneTransform.inverse() * where.scenePoint;
        println("ON DROP {pt}");
        println("row={yToRow(pt.y)}");
        const row = yToRow(pt.y);
        const tv = rowToTimeNodeView(row);
        const targetNode = tv.target;
        println("targetNode={targetNode}");
        if (targetNode is TimeGroup) {
            tv.getParentTimeNodeView().open();
            insert clip into (targetNode as TimeGroup).content;
        } else if (targetNode <> null) {
            tv.open();
            const g = targetNode as TimeGroup;
            insert clip after g.content[Sequences.indexOf(g.content, targetNode)];
        } else {
            add(clip);
        }
    }

    var timelineListener is Disposable;
    
    public var loop is Boolean;

    const onPlayhead = DefaultObserver of Duration {
	override function onNext from (event is Duration) to () {
	    const d = if (loop and not target.paused and targetNode.contentBounds.duration() > 0s) event.rem(targetNode.bounds.start + targetNode.contentBounds.duration()) else event;
	    currentFrame = (d.toMillis() / 1000) * frameRate;
	    //println("currentFrame {event} => {currentFrame}");
            refreshPlayhead();
	    if (target.paused) {
		playhead.x = frameToX(currentFrame);
	    } else {
		playhead.x = durationToX(d);
	    }
	}
    }

    public var target is Timeline on replace {
	timelineListener.dispose();
	timelineListener = target.observePlayhead().subscribe(onPlayhead);
    }

    public var targetNode is TimeNode;

    public var temporalHierarchy is TemporalHierarchy;

    public var removeClip is function from TimeNode to ();


    var selectedTimeNodeView is TimeNodeView = null on replace old {
	old.selected = false;
	selectedTimeNodeView.selected = true;
    }
    
    const undoList = UndoList {};

    readonly var visibleInterval = bind
	new Interval(frameToDuration(scrollOffset), 
		     frameToDuration(scrollOffset+visibleFrameCount));

    public var clips is TimeNode[] on replace deleted[i..j] = inserted {
	for (x in deleted[i..j]) {
	    undoList.removeTarget(&x.playTime);
	    undoList.removeTarget(&x.pickable);
	}
	for (x in inserted) {
	    undoList.addTarget("{x.id}.playtime", &x.playTime);
	    undoList.addTarget("{x.id}.pickable", &x.pickable);
	}
    };

    override function update {
        root.updateRows(0);
        rowCount = root.rowCount;
    }

    const root is TimeNodeView = TimeNodeView {
        expanded: true;
        trax: this;
        override var content = bind foreach (tv in timeNodeViews) TransformNode { content: bind tv }
    }

    var rowCount is Integer;

    readonly var timeNodeViews is TimeNodeView[] = bind getTimeNodes(clips);
    
    bound function getTimeNodes from (content is TimeNode[]) to TimeNodeView[] 
    {
	foreach (t in content) makeTimeNodeView(null, t)
    }

    var frameRate is Number = bind frameRateN;
    var frameRateN is Number = 24.0;

    const lineMesh = LineMesh {};
    const backgroundColor is Color = Color.color(0.6, 0.6, 0.6);//Color.color(0.90, 0.90, 0.90);
    const backgroundPaint is Paint = ColorPaint(backgroundColor);
    const foregroundPaint is Paint = ColorPaint(Color.color(0.2, 0.2, 0.2));

    function autoScrollLeft {
    }

    function autoScrollRight {
    }

    public var currentFrame is Number on replace { refreshPlayhead() }

    function refreshPlayhead from () to () 
    {
	if (not playhead.dragging and not backgroundDragging and not horizontalScrolling) {
	    if (currentFrame < scrollOffset) {
		scrollOffset = currentFrame;
	    } else if (currentFrame > scrollOffset + visibleFrameCount) {
		scrollOffset = currentFrame - visibleFrameCount / 2;
	    }
	} else {
	    if (currentFrame < scrollOffset) {
		autoScrollLeft();
	    } else if (currentFrame > scrollOffset + visibleFrameCount) {
		autoScrollRight();
	    }
	}
    }
    
    const PIXELS_PER_FRAME = 10;
    
    var visibleFrameCount is Number = bind (width-10) / pixelsPerFrame();

    bound function durationToFrame from (d is Duration) to Number
    {
	Math.round((d / 1s) * frameRate);
    }

    bound function frameToDuration from (frames is Number) to Duration {
	(1s / frameRate) * frames
    }
    
    bound function frameTo from (d is Duration) to Duration {
	var seconds = d / 1s;
	var frames = Math.round((seconds * frameRate));
	return (1s / frameRate) * frames;
    }
    
    function rowToTimeNodeView from (row is Integer) to TimeNodeView
    {
        var j = 0;
        for (i in timeNodeViews) {
            if (j + i.rowCount > row) {
                return i.getRow(row-j);
            }
            j += i.rowCount;
        }
        return null;
    }

    function yToRow from (y0 is Number) to Integer 
    {
        const y = y0 - height/2;
        -Math.round(y / getViewHeight() + 2) as Integer;
    }

    bound function xToDuration from (x is Number) to Duration
    {
	1s * x / (pixelsPerFrame() * frameRate);
    }

    bound function xToFrame from (x is Number) to Number
    {
	Math.round(x / pixelsPerFrame());
    }

    bound function durationToX from (d0 is Duration) to Number
    {
	durationToX(d0, false);
    }

    bound function durationToX from (d0 is Duration, loop is Boolean) to Number
    {
        var dur = targetNode.contentBounds.duration();
	var d = if (loop and dur > 0s) d0.rem(dur) else d0;
	var pixels = d / 1s * pixelsPerSecond();
	return pixels;
    }
    
    bound function pixelsPerSecond to Number {  
	pixelsPerFrame() * frameRate;
    }

    bound function pixelsPerFrame to Number { 
        frameRateN / 24.0 * PIXELS_PER_FRAME;
    }
    
    bound function frameToX from (frame is Number) to Number 
    {
	frame * pixelsPerFrame();
    }

    function getViewHeight to Number {
	15
    }

    function updatePlayhead {
        const value = target.paused;
        target.paused = true;
	target.setPlayhead(target.playhead);
        target.paused = value;
    }

    function advancePlayhead from (frames is Number) to ()
    {
	target.setPlayhead(target.playhead + frameToDuration(frames));
    }

    function movePlayheadTo from (x is Number) to ()
    {
	const scrollX = frameToX(scrollOffset);
	const d = xToDuration(x+scrollX);
	target.setPlayhead(frameToDuration(durationToFrame(d)));
	println("move playhead to {x}, scrollX={scrollX} d={d} frame={durationToFrame(d)}");
    }

    function getSelf to Trax { this }


    override bound function getTx to Number { 
        if (dur == 0s) then 0.0 else frameToDuration(scrollOffset) /  dur;
    }

    override bound function getSx to Number { 
        targetSx(visibleInterval.duration(), targetNode.contentBounds) * (frameRate / frameRateN)
    }

    function targetSx from (dur is Duration, bounds is Interval) to Number {
        if (0s == bounds.end) then 1.0 else dur/(dur + bounds.end);
    }

    var dur = bind visibleInterval.duration() + targetNode.contentBounds.end;
    var traxHeight = bind height - 20;
    var sy0 = bind Math.min(traxHeight / Math.max(root.bounds.height(), 1), 1.0);
    var ty0 = bind if root.bounds.height() == 0 then 0.0 else (scrollY * getViewHeight()) / root.bounds.height();

    override bound function getSy to Number { sy0 }

    override bound function getTy to Number { ty0 }

    override public function setY from (ty is Number, sy is Number) to () {
        scrollY = (ty * root.bounds.height() / getViewHeight()) as Integer;
    }

    override public function setX from (tx is Number, sx is Number) to ()
    {
        //println("tx={tx} sx={sx}");
        const cur = getSx();
        // println("cur={cur}");
        // println("pixelsPerFrame={pixelsPerFrame()}");
        //println("frameRateN={frameRateN}");
        if (sx <> 0) {
            frameRateN *= cur / sx;
            //println("tx=>{getTx()} sx=>{getSx()}");
            //println("pixelsPerFrame={pixelsPerFrame()}");
            //println("frameRateN={frameRateN}");
        }
        scrollOffset = durationToFrame(dur * tx);
        //println("scrollOffset => {scrollOffset}");
    }

    const playhead is Playhead = Playhead {
	id: "playhead";
	trax: this;
	override var height = bind getSelf().height;
    }
    var scrollY is Integer;
    public var scrollOffset is Number;
    var visibleDuration is Duration = bind visibleInterval.duration();
    var labels is Node[] = bind drawLabels(width, height, scrollOffset, frameRate);
    var font = bind layoutEngine.createFont("font-size:8;font-family:Lucida Grande");
    var timeNodeViewFont = bind layoutEngine.createFont("font-size:10;font-family:Lucida Grande;font-weight:bold");

    function makeTimeNodeView from (parent is TimeNodeView, t0 is TimeNode) to TimeNodeView 
    {
        var t = t0;
        if (t0 is ResourceTimeNode and (t0 as ResourceTimeNode).content[0] is TransitionLayer) {
            t = (t0 as ResourceTimeNode).content[0] as TransitionLayer;
        }
        TimeNodeView {
            trax: this;
            target: t;
        }
    }


    bound function drawLabels from (w is Number, h is Number, offset is Number, frameRateN is Number) to Node[] 
    {
	//println("draw labels {offset}");
	var x = -w / 2 + 15 + 15;
	var y = h / 2 - 19;
        var pp = pixelsPerFrame();
        var off0 = offset mod pp;
	var off = (offset - off0) * pp;
        var off1 = off0 * pp;
	foreach (i in [0..(w+100) step 100]) {
	    var t = Text.Label {
		height: 10;
		width: 30;
		background: bind this.backgroundPaint;
		foreground: bind this.foregroundPaint;
		transform: bind translate(-off1+x+i, y+10);
		font: bind font;
		text: bind "{Math.round((off+i)/pp) as Integer}"
	    }
            TransformNode {
                tx: bind -t.content.textShape.getBounds().width() / 2
                content: t
            }
	}
    }

    function drawLines from (w is Number, h is Number, viewHeight is Number, offset is Number) to AbstractMesh {
	//println("TIMELINE={target} pp={pixelsPerFrame()}");
	const x0 = -w / 2 + 15;
	const y0 = Math.round(h / 2 - viewHeight-5);
	var x is Number = x0;
	var y is Number = y0;
	var mid is Boolean = false;
	lineMesh.reset();
	lineMesh.moveTo(x, y);
        var pp is Integer = PIXELS_PER_FRAME;
        var off0 = offset mod pp;
	var off = (offset - off0) * pp;
        var off1 = off0 * pp;
        //x += off1;
        //println("OFF={offset}");
	for (i in [0..(w+off) step pp]) {
	    var n = if (mid) then 3 else 5;
	    mid = not mid;
            const x1 = -off1+x+i;
            if (x1 >= x) {
                lineMesh.moveTo(x1, y);
                lineMesh.lineTo(x1, y+n);
            }
	}
        x = x0;
	for (i in [0..<h step pp]) {
	    lineMesh.moveTo(x, y);
	    lineMesh.lineTo(x + width, y);
	    y -= viewHeight;
	    //println("y={y}");
	}
	const mesh = lineMesh.getMesh();
	mesh.updateBounds();
	//println("draw lines: {mesh.bounds} {mesh.vertices.getVertexCount()}");
	return mesh;
    }

    public function selectClip from (clip is TimeNode) to ()
    {
	for (i in timeNodeViews) {
	    if (i.target == clip) {
		selectTimeNodeView(i);
		break;
	    }
	}
    }

    var horizontalScrolling = false;
    
    override function onScrollHorizontally from (b is Boolean) to ()
    {
        horizontalScrolling = b;
        if (not b) {
            frameRateN = Math.round(frameRateN);
        }
    }

    var backgroundDragging = false;
    
    override var internalContent = Group {
	content: 
	[Rectangle is MouseInputHandler {
		id: "background"
		override var height = bind getSelf().height;
		override var width = bind getSelf().width;
		fillPaint: bind ColorPaint(backgroundColor);
		override function onMouseDown from (event is MouseEvent) to ()
		{
		    if (event.location.y >= height / 2 - 20) {
			movePlayheadTo(event.location.x+width/2-15);
		    } else {
                        backgroundDragging = true;
                    }
		    dx = 0;
		    startOff = scrollOffset;
		}
		var dx = 0.0;
		var startOff = 0.0;
		override function onMouseUp from (event is MouseEvent) to () 
                {
                    backgroundDragging = false;
                }
		override function onMouseDrag from (event is MouseEvent) to ()
		{
		    if (backgroundDragging) {
			dx += (event.picked.dragPoint1 - event.picked.dragPoint0).x;
			const off = scrollOffset;
			scrollOffset = Math.round(-xToFrame(dx) + startOff);
			const delta = scrollOffset - off;
                        if (target.playhead < visibleInterval.start) {
                            target.setPlayhead(visibleInterval.start);
                        } else if (target.playhead > visibleInterval.end) {
                            target.setPlayhead(visibleInterval.end - frameToDuration(1));
                        } else {
                            target.setPlayhead(target.playhead);
                        }
		    }
		}
	 },
	 Group { pickable: false, content: bind labels },
         MeshNode {
	     id: "lines"
	     pickable: false;
	     override var mesh = bind getSelf().drawLines(getSelf().width, getSelf().height, getViewHeight(), scrollOffset);
	     shader: bind effectLoader.loadPaintShader(foregroundPaint);
	 },
	 TransformNode { 
	     tx: bind -getSelf().width/2+15-frameToX(scrollOffset);
	     content:
	     [TransformNode {
                 ty: bind height / 2 + 2 - 15 + scrollY * getViewHeight(); 
                 content: bind root;
	     },
	     TransformNode { ty: -6, content: bind playhead }]
	 }]
    }

    override function onKeyDown from (e is KeyboardEvent) to () {
	var i = selectedTimeNodeView.row;
	if (e.keyCode == Keys.Down) {
	    const n = rowToTimeNodeView(i+1);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Up) {
	    const n = rowToTimeNodeView(i-1);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Home) {
	    const n = rowToTimeNodeView(0);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.End) {
	    const n = rowToTimeNodeView(rowCount-1);
	    if (n <> null) {
		selectTimeNodeView(n);
	    }
	} else if (e.keyCode == Keys.Left) {
	    if (e.metaKey) {
		advancePlayhead(-1);
	    } else  if (selectedTimeNodeView.expanded) {
                selectedTimeNodeView.close();
            } else {
		selectedTimeNodeView.target.playTime -= frameToDuration(1);
		updatePlayhead()
	    }
	} else if (e.keyCode == Keys.Right) {
	    if (e.metaKey) {
		advancePlayhead(1);
	    } else {
                if (not selectedTimeNodeView.expanded) {
                    selectedTimeNodeView.open();
                } else {
                    selectedTimeNodeView.target.playTime += frameToDuration(1);
                    updatePlayhead();
                }
	    }
        } else if (e.keyCode == Keys.Spacebar) {
            target.paused = not target.paused;
	} else if (e.keyCode == Keys.Delete or e.keyCode == Keys.Backspace) {
	    if (selectedTimeNodeView.target <> null) {
		var selectedIndex = selectedTimeNodeView.row;
		removeClip(selectedTimeNodeView.target);
		selectedIndex = Math.min(selectedIndex, rowCount-1);
		selectTimeNodeView(rowToTimeNodeView(selectedIndex));
	    }
	}
    }
    override function onKeyUp from (e is KeyboardEvent) to () {
    }

    override function onKeyInput from (e is KeyboardEvent) to () {
    }

    function selectTimeNodeView from (x is TimeNodeView) to () {
	if (x <> null) {
            temporalHierarchy.selectTimeNode(x.target);
	}
	selectedTimeNodeView = x;
    }

    function makeTangent from (ch is Channel, k is KeyFrame.Key of Number, 
                               interp is KeyFrame.Interpolator of Number, 
                               valueBounds is Vec2,
                               viewHeight is Number) to TangentTool 
    {
        const ty = valueBounds.x;
        var dy = (valueBounds.y - valueBounds.x);
        const sy = if (dy == 0) then 1.0 else viewHeight / dy;
        println("VALUE BOUNDS {valueBounds}");
        println("ty={ty}, sy={sy}");
        var x1 is Number;
        var y1 is Number;
        var x2 is Number;
        var y2 is Number;
        if (interp is KeyFrame.Tangent) {
            const t = interp as KeyFrame.Tangent;
            const kix = t.kix;
            const kiy = t.kiy;
            const kox = t.kox;
            const koy = t.koy;
            const value1 = k.prev.value;
            const value2 =  k.value;
            const p0 = value1;
            const p3 = value2;
            const frame1 = (k.prev.position / (1s/24))  as Integer;
            const frame2 = (k.position / (1s/24))  as Integer;
            const outTan = if (kox == 0) then 0 else koy / (kox * 24.0);
            const inTan = if (kix == 0) then 0 else  kiy / (kix * 24.0);
            const oneThirdDelta = (frame2 - frame1) / 3.0;
            const p1Delta = outTan * oneThirdDelta;
            const p2Delta = -inTan * oneThirdDelta;
            x1 = oneThirdDelta;
            y1 = p1Delta;
            x2 = oneThirdDelta;
            y2 = -p2Delta;
        } else {
            const frame1 = (k.prev.position / (1s/24))  as Integer;
            const frame2 = (k.position / (1s/24))  as Integer;
            x1 = frame1;
            x2 = frame2;
            y1 = k.prev.value;
            y2 = k.value;
        }

        y1 -= ty;
        y2 -= ty;

        y1 *= sy;
        y2 *= sy;

        const outAngle = Math.atan2(y1, x1);
        const inAngle = Math.atan2(y2, x2);
        const outLength = Math.sqrt(x1*x1+y1*y1);
        const inLength = Math.sqrt(x2*x2+y2*y2);

        TangentTool {
            editable: false;
            transform: bind translate(durationToX(k.prev.position), -viewHeight/2.0);
            p1: bind new Vec2(0, (k.prev.value - ty)*sy);
            p2: bind new Vec2(durationToX(k.position-k.prev.position) / ch.toSceneTransform.rate,
                              (k.value - ty)*sy);
            inAngle: inAngle;
            inLength: inLength;
            outAngle: outAngle;
            outLength: outLength;
            isPointOnly: k.prev == null and k.next == null;
        }
    }

    function getValueBounds from (ch is Channel of Number) to Vec2 {
        var min = Number.MAX_VALUE;
        var max = Number.MIN_VALUE;
        for (k in ch.keys) {
            const n is Number = k.value;
            if (n > max) max = n;
            if (n < min) min = n;
        }
        return new Vec2(min, max);
    }

    function makeCurveContent from (ch is Channel, k is KeyFrame.Key of Number, 
                                    interp is KeyFrame.Interpolator of Number, 
                                    valueBounds is Vec2,
                                    viewHeight is Number) to PathElement[]
    {
        makeCurve(makeTangent(ch, k, interp, valueBounds, viewHeight));
    }

    function makeCurve from (t is TangentTool) to PathElement[]
    {
        [moveTo(t.p1), cubicTo(t.cp1, t.cp2, t.p2)];
    }

    function makeCurve from (ch is Channel of Number) to Node {
        Path {
            strokePaint: ColorPaint(Color.GREEN);
            content: foreach (k in ch.keys) makeCurveContent(ch, k, k.interpolator, getValueBounds(ch), getViewHeight());
        }
    }

    public function setKey of a from (ch is Channel of a) to ()
    {
        if (not ch.pickable) { return }
        ch.setKey();
    }
}
